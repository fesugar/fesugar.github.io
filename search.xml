<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>18位身份证号码合法性计算</title>
    <url>/zh-CN/2016/10/13/18%E4%BD%8D%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E7%A0%81%E5%90%88%E6%B3%95%E6%80%A7%E8%AE%A1%E7%AE%97.html</url>
    <content><![CDATA[<h5 id="来看下合法性计算方法"><a href="#来看下合法性计算方法" class="headerlink" title="来看下合法性计算方法"></a>来看下合法性计算方法</h5><h6 id="1、将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。"><a href="#1、将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。" class="headerlink" title="1、将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。"></a>1、将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。</h6><h6 id="2、将这17位数字和系数相乘的结果相加。"><a href="#2、将这17位数字和系数相乘的结果相加。" class="headerlink" title="2、将这17位数字和系数相乘的结果相加。"></a>2、将这17位数字和系数相乘的结果相加。</h6><h6 id="3、用加出来和除以11，看余数是多少？"><a href="#3、用加出来和除以11，看余数是多少？" class="headerlink" title="3、用加出来和除以11，看余数是多少？"></a>3、用加出来和除以11，看余数是多少？</h6><h6 id="4、余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。其分别对应的最后一位身份证的号码为1－0－X-－9－8－7－6－5－4－3－2。-即馀数0对应1，馀数1对应0，馀数2对应X…"><a href="#4、余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。其分别对应的最后一位身份证的号码为1－0－X-－9－8－7－6－5－4－3－2。-即馀数0对应1，馀数1对应0，馀数2对应X…" class="headerlink" title="4、余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。其分别对应的最后一位身份证的号码为1－0－X －9－8－7－6－5－4－3－2。(即馀数0对应1，馀数1对应0，馀数2对应X…)"></a>4、余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。其分别对应的最后一位身份证的号码为1－0－X －9－8－7－6－5－4－3－2。(即馀数0对应1，馀数1对应0，馀数2对应X…)</h6><h6 id="5、通过上面得知如果余数是3，就会在身份证的第18位数字上出现的是9。如果对应的数字是2，身份证的最后一位号码就是罗马数字x。"><a href="#5、通过上面得知如果余数是3，就会在身份证的第18位数字上出现的是9。如果对应的数字是2，身份证的最后一位号码就是罗马数字x。" class="headerlink" title="5、通过上面得知如果余数是3，就会在身份证的第18位数字上出现的是9。如果对应的数字是2，身份证的最后一位号码就是罗马数字x。"></a>5、通过上面得知如果余数是3，就会在身份证的第18位数字上出现的是9。如果对应的数字是2，身份证的最后一位号码就是罗马数字x。</h6><h6 id="例如：某男性的身份证号码为【53010219200508011x】，我们看看这个身份证是不是合法的身份证。"><a href="#例如：某男性的身份证号码为【53010219200508011x】，我们看看这个身份证是不是合法的身份证。" class="headerlink" title="例如：某男性的身份证号码为【53010219200508011x】，我们看看这个身份证是不是合法的身份证。"></a>例如：某男性的身份证号码为【53010219200508011x】，我们看看这个身份证是不是合法的身份证。</h6><h6 id="首先我们得出前17位的乘积和【-5-7-3-9-0-10-1-5-0-8-2-4-1-2-9-1-2-6-0-3-0-7-5-9-0-10-8-5-0-8-1-4-1-2-】是189，然后用189除以11得出的结果是189-11-17—-2，也就是说其余数是2。最后通过对应规则就可以知道余数2对应的检验码是X。所以，可以判定这是一个正确的身份证号码。"><a href="#首先我们得出前17位的乘积和【-5-7-3-9-0-10-1-5-0-8-2-4-1-2-9-1-2-6-0-3-0-7-5-9-0-10-8-5-0-8-1-4-1-2-】是189，然后用189除以11得出的结果是189-11-17—-2，也就是说其余数是2。最后通过对应规则就可以知道余数2对应的检验码是X。所以，可以判定这是一个正确的身份证号码。" class="headerlink" title="首先我们得出前17位的乘积和【(5*7)+(3*9)+(0*10)+(1*5)+(0*8)+(2*4)+(1*2)+(9*1)+(2*6)+(0*3)+(0*7)+(5*9)+(0*10)+(8*5)+(0*8)+(1*4)+(1*2)】是189，然后用189除以11得出的结果是189/11=17—-2，也就是说其余数是2。最后通过对应规则就可以知道余数2对应的检验码是X。所以，可以判定这是一个正确的身份证号码。"></a>首先我们得出前17位的乘积和【(5*7)+(3*9)+(0*10)+(1*5)+(0*8)+(2*4)+(1*2)+(9*1)+(2*6)+(0*3)+(0*7)+(5*9)+(0*10)+(8*5)+(0*8)+(1*4)+(1*2)】是189，然后用189除以11得出的结果是189/11=17—-2，也就是说其余数是2。最后通过对应规则就可以知道余数2对应的检验码是X。所以，可以判定这是一个正确的身份证号码。</h6><a id="more"></a>
<h5 id="这里使用-VB-NET-写了一个方法，返回布尔值-true-合法-false-非法"><a href="#这里使用-VB-NET-写了一个方法，返回布尔值-true-合法-false-非法" class="headerlink" title="这里使用 VB.NET 写了一个方法，返回布尔值  true 合法  false  非法"></a>这里使用 VB.NET 写了一个方法，返回布尔值  true 合法  false  非法</h5><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">'''</span> 检查18位身份证号是否合法</span></span><br><span class="line"><span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;param name="str"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Function</span> sfzxy(str <span class="keyword">As</span> <span class="built_in">String</span>) <span class="keyword">As</span> <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">If</span> Trim(str).Length &lt;&gt; <span class="number">18</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> wi <span class="keyword">As</span> <span class="built_in">String</span> = (str.Substring(<span class="number">0</span>, <span class="number">1</span>) * <span class="number">7</span> + str.Substring(<span class="number">1</span>, <span class="number">1</span>) * <span class="number">9</span> + str.Substring(<span class="number">2</span>, <span class="number">1</span>) * <span class="number">10</span> +</span><br><span class="line">             str.Substring(<span class="number">3</span>, <span class="number">1</span>) * <span class="number">5</span> + str.Substring(<span class="number">4</span>, <span class="number">1</span>) * <span class="number">8</span> + str.Substring(<span class="number">5</span>, <span class="number">1</span>) * <span class="number">4</span> +</span><br><span class="line">            str.Substring(<span class="number">6</span>, <span class="number">1</span>) * <span class="number">2</span> + str.Substring(<span class="number">7</span>, <span class="number">1</span>) * <span class="number">1</span> + str.Substring(<span class="number">8</span>, <span class="number">1</span>) * <span class="number">6</span> +</span><br><span class="line">             str.Substring(<span class="number">9</span>, <span class="number">1</span>) * <span class="number">3</span> + str.Substring(<span class="number">10</span>, <span class="number">1</span>) * <span class="number">7</span> + str.Substring(<span class="number">11</span>, <span class="number">1</span>) * <span class="number">9</span> +</span><br><span class="line">             str.Substring(<span class="number">12</span>, <span class="number">1</span>) * <span class="number">10</span> + str.Substring(<span class="number">13</span>, <span class="number">1</span>) * <span class="number">5</span> + str.Substring(<span class="number">14</span>, <span class="number">1</span>) * <span class="number">8</span> +</span><br><span class="line">             str.Substring(<span class="number">15</span>, <span class="number">1</span>) * <span class="number">4</span> + str.Substring(<span class="number">16</span>, <span class="number">1</span>) * <span class="number">2</span>) <span class="keyword">Mod</span> <span class="number">11</span></span><br><span class="line">    <span class="keyword">Select</span> <span class="keyword">Case</span> wi</span><br><span class="line">        <span class="keyword">Case</span> <span class="string">"0"</span></span><br><span class="line">            <span class="keyword">If</span> str.Substring(<span class="number">17</span>, <span class="number">1</span>) = <span class="number">1</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">Case</span> <span class="string">"1"</span></span><br><span class="line">            <span class="keyword">If</span> str.Substring(<span class="number">17</span>, <span class="number">1</span>) = <span class="number">0</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">Case</span> <span class="string">"2"</span></span><br><span class="line">            <span class="keyword">If</span> str.Substring(<span class="number">17</span>, <span class="number">1</span>) = <span class="string">"X"</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">Case</span> <span class="string">"3"</span></span><br><span class="line">            <span class="keyword">If</span> str.Substring(<span class="number">17</span>, <span class="number">1</span>) = <span class="number">9</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">Case</span> <span class="string">"4"</span></span><br><span class="line">            <span class="keyword">If</span> str.Substring(<span class="number">17</span>, <span class="number">1</span>) = <span class="number">8</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">Case</span> <span class="string">"5"</span></span><br><span class="line">            <span class="keyword">If</span> str.Substring(<span class="number">17</span>, <span class="number">1</span>) = <span class="number">7</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">Case</span> <span class="string">"6"</span></span><br><span class="line">            <span class="keyword">If</span> str.Substring(<span class="number">17</span>, <span class="number">1</span>) = <span class="number">6</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">Case</span> <span class="string">"7"</span></span><br><span class="line">            <span class="keyword">If</span> str.Substring(<span class="number">17</span>, <span class="number">1</span>) = <span class="number">5</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">Case</span> <span class="string">"8"</span></span><br><span class="line">            <span class="keyword">If</span> str.Substring(<span class="number">17</span>, <span class="number">1</span>) = <span class="number">4</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">Case</span> <span class="string">"9"</span></span><br><span class="line">            <span class="keyword">If</span> str.Substring(<span class="number">17</span>, <span class="number">1</span>) = <span class="number">3</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">Case</span> <span class="string">"10"</span></span><br><span class="line">            <span class="keyword">If</span> str.Substring(<span class="number">17</span>, <span class="number">1</span>) = <span class="number">2</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">Case</span> <span class="keyword">Else</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">Return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Select</span></span><br><span class="line">    <span class="keyword">Return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br></pre></td></tr></table></figure>

<p>下图是以前写的小工具 <img data-src="https://cdn.fesugar.com/2016/10/2016-10-13-05111565.png" alt="20161013130810"></p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>VB.NET</tag>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>BAT批处理修复Windows桌面快捷图标问题</title>
    <url>/zh-CN/2016/04/05/BAT%E6%89%B9%E5%A4%84%E7%90%86%E4%BF%AE%E5%A4%8DWindows%E6%A1%8C%E9%9D%A2%E5%BF%AB%E6%8D%B7%E5%9B%BE%E6%A0%87%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>XP 、Win7桌面快捷图标错误及exe文件错误关联的批处理修复方案<br>以前写的一个脚本</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">::显示或者隐藏命令 //ECHO \[ON | OFF\]</span><br><span class="line">@ ECHO OFF</span><br><span class="line">REM 修复桌面快捷方式变成了相同的图标或者未知图标，exe快捷方式或者文件无法运行。</span><br><span class="line">::设置颜色为 淡蓝色背景色，白色前景色</span><br><span class="line">COLOR 9F</span><br><span class="line">::设置运行窗口标题</span><br><span class="line">TITLE XP 、Win7桌面快捷图标错误及exe文件错误关联--修复</span><br><span class="line">::提示以管理员身份运行</span><br><span class="line">ECHO ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■</span><br><span class="line">ECHO ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</span><br><span class="line">ECHO ☆ ☆</span><br><span class="line">ECHO ☆ 为了能够成功修复，请使用管理员身份运行 \[鼠标右键单击--以管理员身份运行\] ☆</span><br><span class="line">ECHO ☆ ☆</span><br><span class="line">ECHO ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</span><br><span class="line"></span><br><span class="line">::检测系统版本，如果需要并跳转到相应的系统标签处进行执行</span><br><span class="line">VER|FINDSTR /I <span class="string">"5.1"</span> &amp;&amp; GOTO XP || GOTO Win7</span><br><span class="line">:: XP 系统的方案</span><br><span class="line">:XP</span><br><span class="line">::说明可能导致此问题的相关原因</span><br><span class="line">ECHO 主要症状：</span><br><span class="line">ECHO 桌面多数或全部快捷方式图标变成了某一个相同、未知的图标,或者exe文件无法运行。</span><br><span class="line">ECHO 1.可能由于注册表异常导致。</span><br><span class="line">ECHO 2.缓存过旧导致的异常。</span><br><span class="line">ECHO =====================================</span><br><span class="line">::信息提示并作出选择</span><br><span class="line">::暂不使用此句 CHOICE /C YN /T 10 /D Y /M <span class="string">"您好，键入 Y 执行修复，N 退出，如未操作，默认十秒后自动执行修复。</span></span><br><span class="line"><span class="string">set /P IS=您好，键入 Y 执行修复，N 退出。(不区分大小写，输入错误将直接退出) 输入后回车</span></span><br><span class="line"><span class="string">::判断输入的字符</span></span><br><span class="line"><span class="string">::暂不使用此句 IF ERRORLEVEL 2 (EXIT) ELSE (GOTO R)</span></span><br><span class="line"><span class="string">IF /I %IS% EQU Y (GOTO R) ELSE (EXIT)</span></span><br><span class="line"><span class="string">:: Win7 系统的方案</span></span><br><span class="line"><span class="string">:Win7</span></span><br><span class="line"><span class="string">::说明可能导致此问题的相关原因</span></span><br><span class="line"><span class="string">ECHO.</span></span><br><span class="line"><span class="string">ECHO 主要症状：</span></span><br><span class="line"><span class="string">ECHO.</span></span><br><span class="line"><span class="string">ECHO 桌面多数或全部快捷方式图标变成了某一个相同的图标,exe文件无法运行。</span></span><br><span class="line"><span class="string">ECHO.</span></span><br><span class="line"><span class="string">ECHO 1.可能由于注册表异常导致。</span></span><br><span class="line"><span class="string">ECHO.</span></span><br><span class="line"><span class="string">ECHO 2.缓存过旧导致的异常。</span></span><br><span class="line"><span class="string">ECHO.</span></span><br><span class="line"><span class="string">ECHO =====================================</span></span><br><span class="line"><span class="string">::信息提示并作出选择</span></span><br><span class="line"><span class="string">CHOICE /C YN /T 10 /D Y /M "</span>您好，键入 Y 执行修复，N 退出，如未操作，默认十秒后自动执行修复。</span><br><span class="line">::暂不使用此句 <span class="built_in">set</span> /P IS=您好，键入 Y 执行修复，N 退出。(不区分大小写，输入错误将直接退出) 输入后回车</span><br><span class="line">::判断输入的字符</span><br><span class="line">IF ERRORLEVEL 2 (EXIT) ELSE (GOTO R)</span><br><span class="line">::暂不使用此句 IF /I %IS% EQU Y (GOTO R) ELSE (EXIT)</span><br><span class="line"></span><br><span class="line">::标签R</span><br><span class="line">:R</span><br><span class="line">ECHO.</span><br><span class="line">ECHO /////////////////////////////////</span><br><span class="line">ECHO //如遇到安全软件拦截请解除拦截。/</span><br><span class="line">ECHO /////////////////////////////////</span><br><span class="line">::使用REG命令对注册表进行操作</span><br><span class="line"></span><br><span class="line">::首先执行备份至临时目录</span><br><span class="line">ECHO.</span><br><span class="line">ECHO ■■■■ 备份注册表 ■■■■</span><br><span class="line">ECHO ┌────────────┐</span><br><span class="line">REG EXPORT HKCR.exe %TEMP%HKCR.exe.reg /y</span><br><span class="line">REG EXPORT HKCR.lnk %TEMP%HKCR.lnk.reg /y</span><br><span class="line">REG EXPORT HKCRexefile %TEMP%HKCR.exefile.reg /y</span><br><span class="line">REG EXPORT HKCUSoftwareMicrosoftWindowsCurrentVersionExplorerFileExts.lnk %TEMP%HKCU.lnk.reg /y</span><br><span class="line">REG EXPORT HKCUSoftwareMicrosoftWindowsCurrentVersionExplorerFileExts.exe %TEMP%HKCU.exe.reg /y</span><br><span class="line">ECHO └────────────┘</span><br><span class="line">ECHO ☆☆注册表备份完毕☆☆</span><br><span class="line">ECHO.</span><br><span class="line">ECHO ■■■■ 修复注册表 ■■■■</span><br><span class="line">ECHO ┌────────────┐</span><br><span class="line">::HKEY\_CLASSES\_ROOTexefile</span><br><span class="line">REG DELETE <span class="string">"HKEY\_CLASSES\_ROOTexefileDefaultIcon"</span> /f</span><br><span class="line">REG ADD <span class="string">"HKEY\_CLASSES\_ROOTexefileDefaultIcon"</span> /ve /t REG_SZ /d <span class="string">"%%1"</span> /f</span><br><span class="line">::设置变量并赋值</span><br><span class="line"><span class="built_in">set</span> exe=<span class="string">""</span><span class="string">""</span>%%1<span class="string">""</span><span class="string">" %%*"</span></span><br><span class="line">REG DELETE <span class="string">"HKEY\_CLASSES\_ROOTexefileshellopen"</span> /f</span><br><span class="line">REG DELETE <span class="string">"HKEY\_CLASSES\_ROOTexefileshellrunas"</span> /f</span><br><span class="line">REG ADD <span class="string">"HKEY\_CLASSES\_ROOTexefileshellopencommand"</span> /ve /t REG_SZ /d %exe% /f</span><br><span class="line">REG ADD <span class="string">"HKEY\_CLASSES\_ROOTexefileshellopencommand"</span> /v <span class="string">"IsolatedCommand"</span> /t REG_SZ /d %exe% /f</span><br><span class="line">REG ADD <span class="string">"HKEY\_CLASSES\_ROOTexefileshellrunascommand"</span> /ve /t REG_SZ /d %exe% /f</span><br><span class="line">REG ADD <span class="string">"HKEY\_CLASSES\_ROOTexefileshellrunascommand"</span> /v <span class="string">"IsolatedCommand"</span> /t REG_SZ /d %exe% /f</span><br><span class="line"></span><br><span class="line">::HKEY\_CLASSES\_ROOT.exe</span><br><span class="line">REG ADD <span class="string">"HKEY\_CLASSES\_ROOT.exe"</span> /ve /t REG_SZ /d <span class="string">"exefile"</span> /f</span><br><span class="line">assoc.exe=exefile</span><br><span class="line"></span><br><span class="line">::HKEY\_CLASSES\_ROOT.lnk</span><br><span class="line">REG ADD <span class="string">"HKEY\_CLASSES\_ROOT.lnk"</span> /ve /t REG_SZ /d lnkfile /f</span><br><span class="line">assoc.lnk=lnkfile</span><br><span class="line"></span><br><span class="line">::HKEY\_CURRENT\_USERSoftwareMicrosoftWindowsCurrentVersionExplorerFileExts.lnk</span><br><span class="line">REG DELETE <span class="string">"HKEY\_CURRENT\_USERSoftwareMicrosoftWindowsCurrentVersionExplorerFileExts.lnk"</span> /f</span><br><span class="line">REG ADD <span class="string">"HKEY\_CURRENT\_USERSoftwareMicrosoftWindowsCurrentVersionExplorerFileExts.lnkOpenWithProgids"</span> /ve /f</span><br><span class="line">REG ADD <span class="string">"HKEY\_CURRENT\_USERSoftwareMicrosoftWindowsCurrentVersionExplorerFileExts.lnkOpenwithlist"</span> /ve /f</span><br><span class="line">REG DELETE <span class="string">"HKEY\_CURRENT\_USERSoftwareMicrosoftWindowsCurrentVersionExplorerFileExts.lnkOpenWithProgids"</span> /va /f</span><br><span class="line">REG DELETE <span class="string">"HKEY\_CURRENT\_USERSoftwareMicrosoftWindowsCurrentVersionExplorerFileExts.lnkOpenwithlist"</span> /va /f</span><br><span class="line"></span><br><span class="line">::HKEY\_CURRENT\_USERSoftwareMicrosoftWindowsCurrentVersionExplorerFileExts.exe</span><br><span class="line">REG DELETE <span class="string">"HKEY\_CURRENT\_USERSoftwareMicrosoftWindowsCurrentVersionExplorerFileExts.exe"</span> /f</span><br><span class="line">REG ADD <span class="string">"HKEY\_CURRENT\_USERSoftwareMicrosoftWindowsCurrentVersionExplorerFileExts.exeOpenWithProgids"</span> /ve /f</span><br><span class="line">REG ADD <span class="string">"HKEY\_CURRENT\_USERSoftwareMicrosoftWindowsCurrentVersionExplorerFileExts.exeOpenwithlist"</span> /ve /f</span><br><span class="line">REG DELETE <span class="string">"HKEY\_CURRENT\_USERSoftwareMicrosoftWindowsCurrentVersionExplorerFileExts.exeOpenWithProgids"</span> /va /f</span><br><span class="line">REG DELETE <span class="string">"HKEY\_CURRENT\_USERSoftwareMicrosoftWindowsCurrentVersionExplorerFileExts.exeOpenwithlist"</span> /va /f</span><br><span class="line"></span><br><span class="line">::REG DELETE <span class="string">"HKEY\_LOCAL\_MACHINESOFTWAREMicrosoftWindowsCurrentVersionExplorerShellIcons"</span> /f</span><br><span class="line"></span><br><span class="line">::判断图标缓存文件 IconCache.db 是否存在 ，是则删除文件</span><br><span class="line">IF EXIST <span class="string">"%USERPROFILE%AppDataLocalIconCache.db"</span> (DEL /F /Q /A <span class="string">"%USERPROFILE%AppDataLocalIconCache.db"</span>) ELSE (ECHO 未发现图标缓存文件)</span><br><span class="line">IF EXIST <span class="string">"%USERPROFILE%LocalSettingsApplication DataIconCache.db"</span> (DEL /F /Q /A <span class="string">"%USERPROFILE%LocalSettingsApplication DataIconCache.db"</span>) ELSE (ECHO 未发现图标缓存文件)</span><br><span class="line">::重启 explorer 进程</span><br><span class="line">TASKKILL /IM explorer.exe /F</span><br><span class="line">start <span class="string">""</span> <span class="string">"explorer.exe"</span></span><br><span class="line">ECHO └────────────┘</span><br><span class="line">ECHO ☆☆注册表修复完成☆☆</span><br><span class="line">ECHO.</span><br><span class="line">::等待按键继续</span><br><span class="line">ECHO .......................................................................</span><br><span class="line"><span class="built_in">echo</span> 操作完毕,如果提示成功并且还存在问题建议重启计算机后查看是否已经修复.</span><br><span class="line">pause&gt;nul</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>CMD</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>18位身份证信息解析</title>
    <url>/zh-CN/2019/03/19/18%E4%BD%8D%E8%BA%AB%E4%BB%BD%E8%AF%81%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90.html</url>
    <content><![CDATA[<p><strong>软件名称：18位身份证信息解析</strong><br><strong>软件介绍：解析18位身份证号码，地址区域信息</strong><br><strong>软件大小：2MB</strong><br><strong>下载链接：<a href="https://cdn.fesugar.com/download/Identity" target="_blank" rel="noopener">https://cdn.fesugar.com/download/Identity</a> Search.zip</strong><br><strong>发布时间：2013/3</strong><br><strong>新增功能：</strong> <strong>1. 对于星座进行个性分析</strong><br><strong>宣传版本号：1.0.0.6</strong><br><strong>支持操作系统（含多少位）： Windows 7 SP1, Windows 8.1, Windows 10 （ 32&amp;64）</strong><br><strong>语言种类：中文简体</strong><br><strong>是否收费：免费软件</strong><br><strong>软件截图：</strong> <img data-src="https://cdn.fesugar.com/2019/03/2019-03-19-0403059.jpg" alt=""></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>Windows</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>An error occurred during local report processing</title>
    <url>/zh-CN/2016/10/18/an-error-occurred-during-local-report-processing.html</url>
    <content><![CDATA[<p>在.net平台使用 RDLC 进行报表开发，本机测试正常，到别的机器不是没反应就是报 An error occurred during local report processing 等错误<br>最后发现要确保报表所需的控件存在以及版本正确。</p>
<pre><code>Microsoft.ReportViewer.Common.dll 
Microsoft.ReportViewer.DataVisualization.dll 
Microsoft.ReportViewer.ProcessingObjectModel.dll 
Microsoft.ReportViewer.WinForms.dll</code></pre><p>这四个搞定后终于正常了！ 最后别忘了语言资源的使用<br>─zh-Hans </p>
<pre><code>Microsoft.ReportViewer.Common.resources.dll
Microsoft.ReportViewer.DataVisualization.resources.dll 
Microsoft.ReportViewer.Design.resources.dll 
Microsoft.ReportViewer.WinForms.resources.dll</code></pre>]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>RDLC</tag>
      </tags>
  </entry>
  <entry>
    <title>ajax jsonp跨域请求数据出错 Uncaught SyntaxError: Unexpected token :</title>
    <url>/zh-CN/2016/10/12/ajax%20jsonp%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%87%BA%E9%94%99%20Uncaught%20SyntaxError%20Unexpected%20token.html</url>
    <content><![CDATA[<p>解决使用 ajax 的 jsonp 出现 Uncaught SyntaxError: Unexpected token :   偶然使用 ajax 处理 jsonp 时居然提示“Uncaught SyntaxError: Unexpected token :“ 检查了json数据没有问题，搜集了一番发现使用回掉的方式可以解决  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type: <span class="string">"get"</span>,</span><br><span class="line">    url: <span class="string">"xxxxxx"</span>,</span><br><span class="line">    dataType: <span class="string">"jsonp"</span>,</span><br><span class="line">    jsonp: <span class="string">"callback"</span>,</span><br><span class="line">    jsonpCallback: <span class="string">"success"</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">        $(<span class="string">"msg"</span>).html(json.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>  需要注意服务端这样写 php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$_GET[<span class="string">'callback'</span>].<span class="string">"("</span>.json_encode($json).<span class="string">")"</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>C# MySql “Parameter &#39;@??&#39; must be defined”</title>
    <url>/zh-CN/2016/10/18/c-mysql-parameter-must-be-defined.html</url>
    <content><![CDATA[<p>C# 一段程序如下，执行出错，错误信息是 “Parameter ‘@rowNum’ must be defined” 但是直接在 mySql workbatch 中运行是正确的！！ 原因和在？ 搜索一下， 看到老外的网站说 连接串要加上 ： “Allow User Variables=True”, 再试验一次，发现可以了！！ string mySqlConnString = @”Database=testDB ; User Id = root; Password =password;Data source=10.10.10.107;”; MySql.Data.MySqlClient.MySqlConnection mySqlConn = new MySql.Data.MySqlClient.MySqlConnection(); mySqlConn.ConnectionString = mySqlConnString; mySqlConn.Open(); MySql.Data.MySqlClient.MySqlCommand mySqlCmd = new MySql.Data.MySqlClient.MySqlCommand(); //declare @rowNumber as integer; mySqlCmd.Connection = mySqlConn; mySqlCmd.CommandText = “set @rowNum:=0; create temporary table T_729540255 as ( Select @rowNum:=ifnull(@rowNum,0)+1 as Temp_id, A.employee_id,A.employee_no From employee A)”; mySqlCmd.ExecuteNonQuery();</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# VB .NET 解析 JSON</title>
    <url>/zh-CN/2016/10/10/csharp%20VB.NET%20%E8%A7%A3%E6%9E%90%20JSON.html</url>
    <content><![CDATA[<p>如何在 .NET 程序中解析 JSON 使用 Newtonsoft.Json 第三方类来操纵 Newtonsoft.Json 是.NET 下开源的json格式序列号和反序列化的类库 官方网站: <a href="http://json.codeplex.com/" target="_blank" rel="noopener">http://json.codeplex.com/</a></p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Imports</span> System.<span class="keyword">Text</span>.RegularExpressions</span><br><span class="line"><span class="keyword">Imports</span> Newtonsoft.Json</span><br><span class="line"><span class="keyword">Imports</span> Newtonsoft.Json.Linq</span><br><span class="line"><span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">'''</span> json序列化</span></span><br><span class="line"><span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Class</span> json</span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> 解析JSON数据</span></span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;param name="empData"&gt;</span>源数据<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;param name="key"&gt;</span>指定值下的数据，可省略。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;returns&gt;</span>0 非 json 数据<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="keyword">Public</span> <span class="keyword">Shared</span> <span class="keyword">Function</span> JsonDecode(<span class="keyword">ByVal</span> empData, <span class="keyword">Optional</span> <span class="keyword">ByVal</span> key1 = <span class="literal">Nothing</span>, <span class="keyword">Optional</span> <span class="keyword">ByVal</span> key2 = <span class="literal">Nothing</span>, <span class="keyword">Optional</span> <span class="keyword">ByVal</span> arry_i = <span class="literal">Nothing</span>) <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line">        <span class="keyword">Try</span></span><br><span class="line">            <span class="keyword">If</span> IsJson(empData) = <span class="literal">False</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">If</span> arry_i <span class="keyword">IsNot</span> <span class="literal">Nothing</span> <span class="keyword">Then</span></span><br><span class="line">                <span class="comment">'http://blog.csdn.net/goodelephant/article/details/24769421</span></span><br><span class="line">                <span class="keyword">Return</span> <span class="built_in">CType</span>(JsonConvert.DeserializeObject(empData), JObject)(key1)(arry_i)(key2).ToString()   <span class="comment">'这个是解析数组  下标。。</span></span><br><span class="line">            <span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">If</span> key1 = <span class="literal">Nothing</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="built_in">CType</span>(JsonConvert.DeserializeObject(empData), JObject).ToString</span><br><span class="line"></span><br><span class="line">            <span class="keyword">If</span> key2 = <span class="literal">Nothing</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="built_in">CType</span>(JsonConvert.DeserializeObject(empData), JObject)(key1).ToString()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Return</span> <span class="built_in">CType</span>(JsonConvert.DeserializeObject(empData), JObject)(key1)(key2).ToString()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">Catch</span> ex <span class="keyword">As</span> Exception</span><br><span class="line">            <span class="keyword">Return</span> ex.Message</span><br><span class="line">        <span class="keyword">End</span> <span class="keyword">Try</span></span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Function</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">'''</span> 序列化 json</span></span><br><span class="line"><span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;param name="str"&gt;</span>对象<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;remarks&gt;</span><span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Shared</span> <span class="keyword">Function</span> JsonEncode(<span class="keyword">ByVal</span> str <span class="keyword">As</span> <span class="built_in">Object</span>) <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line">    <span class="keyword">Try</span></span><br><span class="line">        <span class="keyword">Return</span> JsonConvert.SerializeObject(str)</span><br><span class="line">    <span class="keyword">Catch</span> ex <span class="keyword">As</span> Exception</span><br><span class="line">        <span class="keyword">Return</span> ex.Message</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Try</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br></pre></td></tr></table></figure>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Shared</span> <span class="keyword">Function</span> JsonSerializeMore_HttpJson(<span class="keyword">ByVal</span> code <span class="keyword">As</span> <span class="built_in">String</span>, <span class="keyword">ByVal</span> msg <span class="keyword">As</span> <span class="built_in">String</span>, <span class="keyword">Optional</span> <span class="keyword">ByVal</span> data <span class="keyword">As</span> <span class="built_in">Object</span> = <span class="literal">Nothing</span>)</span><br><span class="line">    <span class="comment">'http://bbs.csdn.net/topics/390910345</span></span><br><span class="line">    <span class="comment">'http://www.cnblogs.com/08shiyan/p/3464028.html</span></span><br><span class="line">    <span class="comment">'  Dim cusList As New List(Of httpjson)()</span></span><br><span class="line">    <span class="comment">'Dim cusList As New List(Of HttpJson)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">'cusList.Add(New HttpJson("6902083881405", "娃哈哈饮用纯净水", ""))</span></span><br><span class="line">    <span class="comment">'cusList.Add(New HttpJson("6902083893736", "娃哈哈营养快线原味"))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">'Dim dic As Dictionary(Of String, HttpJson) = New Dictionary(Of String, HttpJson)</span></span><br><span class="line">    <span class="comment">'dic.Add("1", New HttpJson("1", "2", 1.1))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">''dic.Add("2222", New HttpJson("1", "2", 1.1))</span></span><br><span class="line">    <span class="comment">'' dic.Add("3333", New HttpJson("1", "2", 1.1))</span></span><br><span class="line">    <span class="comment">'Dim jsonStr As String = Newtonsoft.Json.JsonConvert.SerializeObject(dic)</span></span><br><span class="line">    <span class="comment">'MsgBox(jsonStr)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">'MsgBox(JsonConvert.SerializeObject(cusList))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">Return</span> JsonEncode(<span class="keyword">New</span> HttpJson(code, data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br></pre></td></tr></table></figure>

<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> json转换datatable</span></span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;param name="strJson"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;returns&gt;</span>返回 0  非json 数据<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="keyword">Public</span> <span class="keyword">Shared</span> <span class="keyword">Function</span> JsonToDataTable(<span class="keyword">ByVal</span> strJson <span class="keyword">As</span> <span class="built_in">String</span>) <span class="keyword">As</span> DataTable</span><br><span class="line"></span><br><span class="line">        <span class="keyword">Dim</span> rg <span class="keyword">As</span> <span class="keyword">New</span> Regex(<span class="string">"(?&lt;=&#123;)\[^:\]+(?=:\\\[)"</span>, RegexOptions.IgnoreCase)</span><br><span class="line">        <span class="keyword">Dim</span> strName <span class="keyword">As</span> <span class="built_in">String</span> = rg.Match(strJson).Value</span><br><span class="line">        <span class="keyword">Dim</span> dt <span class="keyword">As</span> DataTable = <span class="literal">Nothing</span></span><br><span class="line">        strJson = strJson.Substring((strJson.IndexOf(<span class="string">"\["</span>) + <span class="number">1</span>))</span><br><span class="line">        strJson = strJson.Substring(<span class="number">0</span>, strJson.IndexOf(<span class="string">"\]"</span>))</span><br><span class="line">        <span class="keyword">Dim</span> matchs <span class="keyword">As</span> MatchCollection = <span class="keyword">New</span> Regex(<span class="string">"(?&lt;=&#123;)\[^&#125;\]+(?=&#125;)"</span>).Matches(strJson)</span><br><span class="line">        <span class="keyword">Dim</span> i <span class="keyword">As</span> <span class="built_in">Integer</span></span><br><span class="line">        <span class="keyword">For</span> i = <span class="number">0</span> <span class="keyword">To</span> matchs.Count - <span class="number">1</span></span><br><span class="line">            <span class="keyword">Dim</span> strRow <span class="keyword">As</span> <span class="built_in">String</span> = matchs(i).Value</span><br><span class="line">            <span class="keyword">Dim</span> strRows <span class="keyword">As</span> <span class="built_in">String</span>() = Split(strRow, <span class="string">","</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">If</span> (dt <span class="keyword">Is</span> <span class="literal">Nothing</span>) <span class="keyword">Then</span></span><br><span class="line">                dt = <span class="keyword">New</span> DataTable</span><br><span class="line">                dt.TableName = strName</span><br><span class="line">                <span class="keyword">For</span> <span class="keyword">Each</span> str <span class="keyword">As</span> <span class="built_in">String</span> <span class="keyword">In</span> strRows</span><br><span class="line">                    <span class="keyword">Dim</span> dc <span class="keyword">As</span> <span class="keyword">New</span> DataColumn</span><br><span class="line">                    <span class="keyword">Dim</span> strCell <span class="keyword">As</span> <span class="built_in">String</span>() = Split(str, <span class="string">":"</span>)</span><br><span class="line">                    dc.ColumnName = strCell(<span class="number">0</span>).Replace(<span class="string">""""</span>, <span class="string">""</span>)</span><br><span class="line">                    dc.ColumnName = Trim(dc.ColumnName.Replace(Chr(<span class="number">13</span>), <span class="string">""</span>))</span><br><span class="line">                    dc.ColumnName = Trim(dc.ColumnName.Replace(Chr(<span class="number">10</span>), <span class="string">""</span>))</span><br><span class="line">                    dt.Columns.Add(dc)</span><br><span class="line">                <span class="keyword">Next</span></span><br><span class="line">                dt.AcceptChanges()</span><br><span class="line">            <span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">Dim</span> dr <span class="keyword">As</span> DataRow = dt.NewRow()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">For</span> j <span class="keyword">As</span> <span class="built_in">Integer</span> = <span class="number">0</span> <span class="keyword">To</span> strRows.Length - <span class="number">1</span></span><br><span class="line">                dr(j) = Trim(strRows(j).Split(<span class="string">":"</span>)(<span class="number">1</span>).Replace(<span class="string">""""</span>, <span class="string">""</span>))</span><br><span class="line">            <span class="keyword">Next</span> j</span><br><span class="line">            dt.Rows.Add(dr)</span><br><span class="line">            dt.AcceptChanges()</span><br><span class="line">        <span class="keyword">Next</span> i</span><br><span class="line">        <span class="keyword">Return</span> dt</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Function</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> 验证是否 JSON 数据</span></span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;param name="input"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">'''</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="keyword">Public</span> <span class="keyword">Shared</span> <span class="keyword">Function</span> IsJson(<span class="keyword">ByVal</span> input <span class="keyword">As</span> <span class="built_in">String</span>) <span class="keyword">As</span> <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">If</span> input = <span class="string">""</span> <span class="keyword">Then</span> <span class="keyword">Return</span> <span class="literal">False</span> <span class="comment">'为空字符时会出现异常，这里直接返回，不进行检测</span></span><br><span class="line">        input = input.Trim</span><br><span class="line">        <span class="keyword">Return</span> ((input.StartsWith(<span class="string">"&#123;"</span>) <span class="keyword">AndAlso</span> input.EndsWith(<span class="string">"&#125;"</span>)) <span class="keyword">OrElse</span> (input.StartsWith(<span class="string">"\["</span>) <span class="keyword">AndAlso</span> input.EndsWith(<span class="string">"\]"</span>)))</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Function</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Class</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.ComponentModel;</span><br><span class="line">using System.Data;</span><br><span class="line">using System.Drawing;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Windows.Forms;</span><br><span class="line"></span><br><span class="line">namespace test</span><br><span class="line">&#123;</span><br><span class="line">    public partial class Form1 : Form</span><br><span class="line">    &#123;</span><br><span class="line">        public Form1()</span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void button1_Click(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            string jsonstr &#x3D; &quot;json 待解析的字符&quot;;</span><br><span class="line"></span><br><span class="line">            MessageBox.Show(</span><br><span class="line"></span><br><span class="line">                ((Newtonsoft.Json.Linq.JObject)Newtonsoft.Json.JsonConvert.DeserializeObject(jsonstr))\[&quot;data&quot;\]\[&quot;name&quot;\].ToString()</span><br><span class="line"></span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>VB.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法之希尔排序</title>
    <url>/zh-CN/2016/09/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html</url>
    <content><![CDATA[<p>希尔排序是按照该算法的设计者的名字希尔 命名的，其产生是希尔在插入排序的基础上改进的，可以说是一种特殊的插入排序。<br>下面先介绍一下插入排序的性质：<br>首先，插入排序算法对于已经有序的数据进行操作的时候，效率很高，可以达到线性排序的效率。<br>其次，插入排序进行排序的时候，每一趟排序只能移动一个数据。所以说这样的排序方法相对来说效率又比较低。<br>基于此性质，希尔排序的设计者发明了希尔排序算法，其基本思想是：<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，分割子序列的方法就是设定一个增量，待当下的每个子序列有序的时候，将增量减一半（除以2，取整），再次进行子序列的排序。<br>依次进行，待整个序列中的记录基本上有序的时候，再对全体记录进行依次直接插入排序，此时增量减为1，因为直接插入排序在元素基本有序的情况下（根据上述第一点，接近最好的情况），效率是很高的。 </p>
<a id="more"></a>
<p>因此，对于希尔排序，总结一句话，就是一种分组插入方法。因为设定了一个增量，并且依次将增量减1，所以希尔排序又称为递减增量排序算法。<br>对于希尔排序的算法步骤，可以用下图来表示<br><img data-src="https://cdn.fesugar.com/2016/09/2016-09-23-12334768.png" alt="1-1601050tu0148"><br><img data-src="https://cdn.fesugar.com/2016/09/2016-09-23-1234088.png" alt="1-1601050tuc06"><br><img data-src="https://cdn.fesugar.com/2016/09/2016-09-23-12344069.png" alt="1-1601050tzn20"><br>在这里需要说一下，希尔排序是稳定排序，我们可以设定一组数据按照上述方式进行排序，可以发现其为稳定排序。<br>希尔排序在按照增量分组以后，其组内的排序可以使用插入排序，当然也可以使用冒泡排序、选择排序等等 下面奉上希尔排序的PHP实现代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$arr = <span class="keyword">array</span>(<span class="number">10</span>, <span class="number">6</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">30</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">1</span>, <span class="number">17</span>);</span><br><span class="line">/\*</span><br><span class="line">\* 首先初始化 增量  数组长度/<span class="number">2</span> 取整 floor() 函数向下取整  对于增量每次循环都由 当前增量/<span class="number">2</span></span><br><span class="line">*/</span><br><span class="line"><span class="keyword">for</span> ($dl = floor(count($arr) / <span class="number">2</span>); $dl &gt;= <span class="number">1</span>; $dl = floor($dl / <span class="number">2</span>)) &#123;</span><br><span class="line">    /\*</span><br><span class="line">\* 每次从 增量的位置开始，直到数组递增变量达到数组的长度</span><br><span class="line">*/</span><br><span class="line">    <span class="keyword">for</span> ($j = $dl; $j &lt; count($arr); $j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> ($i = $j - $dl; $i &gt;= <span class="number">0</span>; $i -= $dl) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($arr\[$i + $dl\] &lt; $arr\[$i\]) &#123;</span><br><span class="line">                $temp = $arr\[$i + $dl\];</span><br><span class="line">                $arr\[$i + $dl\] = $arr\[$i\];</span><br><span class="line">                $arr\[$i\] = $temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  以上代码只是其中的一种实现方式，其代码实现有很多种，仅仅针对组内的排序方式就有很多，如果大家有什么好的方法，欢迎从下面留言，大家共同讨论，共同提高。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
  </entry>
  <entry>
    <title>提取网页标题</title>
    <url>/zh-CN/2019/10/03/%E6%8F%90%E5%8F%96%E7%BD%91%E9%A1%B5%E6%A0%87%E9%A2%98.html</url>
    <content><![CDATA[<div>
<li>来源:<a href="http://renwu.mingrisoft.com/" target="_blank" rel="external nofollow">明日科技</a></li>
</div>

<h2 id="提取网页标题"><a href="#提取网页标题" class="headerlink" title="提取网页标题"></a>提取网页标题</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例实现了根据网址提取HTML网页标题的功能。运行程序，在文本框中输入正确的网址，单击”提取”按钮，即可将网页的标题显示在下面的文本框中。运行结果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0839_1-1.png" alt=""></p>
<p>图1 提取网页标题</p>
<h3 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h3><p>实现本实例功能主要用到了<br>System.Net命名空间下的<br>WebRequest类的Create方法、GetResponse方法、<br>WebResponse类的GetResponseStream方法、<br>StreamReader System.Text.RegularExpressions命名空间下的Regex类的IsMatch方法、Match方法、<br>System.IO命名空间下的StreamReader类的ReadLine方法和Stream类。<br>System.Net命名空间下的类和方法、system.Text.RegularExpressions命名空间下类和方法在前面已经做过介绍，详细说明请参见实例515。<br>这里主要讲解一下Regex类的Match方法、System.IO命名空间下的StreamReader类和Stream类。 </p>
<a id="more"></a>
<p>（1）Match方法 此方法在指定的输入字符串中搜索pattern参数中提供的正则表达式的匹配项。其语法格式如下：</p>
<p>public static Match Match (string input,string pattern)</p>
<p>参数说明如下。</p>
<p>l input：要搜索匹配项的字符串。</p>
<p>l pattern：要匹配的正则表达式模式。</p>
<p>l 返回值：一个正则表达式的Match对象。</p>
<p>（2）System.IO命名空间 System.IO命名空间包含允许读写文件和数据流的类型以及提供基本文件和目录支持的类型。<br>（3）StreamReader类 此类实现一个TextReader，使其以一种特定的编码从字节流中读取字符。<br>（4）ReadLine方法  此方法从当前流中读取一行字符并将数据作为字符串返回。其语法格式如下：</p>
<p>public override string ReadLine ()</p>
<p>l 返回值：输入流中的下一行；如果到达了输入流的末尾，则为空引用。</p>
<p>（5）Stream类  此类提供字节序列的一般视图。</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>（1）新建一个Windows应用程序，将其命名为”提取网页标题”，默认窗体为Form1。 （2）在Form1窗体中主要添加两个TextBox控件，用于输入网址和显示网页标题信息；添加一个Button控件，用来执行提取网页标题信息的操作。<br>（3）主要程序代码。 提取网页标题的实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (textBox1.Text &#x3D;&#x3D; &quot;&quot;)                                        &#x2F;&#x2F;如果文本框为空</span><br><span class="line"></span><br><span class="line">    &#123; MessageBox.Show(&quot;请输入网址&quot;); return; &#125;                        &#x2F;&#x2F;提示输入网址</span><br><span class="line"></span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if (ValidateDate1(textBox1.Text.TrimEnd()))</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            string strl;                                        &#x2F;&#x2F;存储编码</span><br><span class="line"></span><br><span class="line">            WebRequest wb &#x3D; WebRequest.Create(textBox1.Text.Trim());    &#x2F;&#x2F;请求资源</span><br><span class="line"></span><br><span class="line">            WebResponse webRed &#x3D; wb.GetResponse();                &#x2F;&#x2F;响应请求</span><br><span class="line"></span><br><span class="line">            Stream redweb &#x3D; webRed.GetResponseStream();            &#x2F;&#x2F;返回数据存入流中</span><br><span class="line"></span><br><span class="line">            StreamReader sr &#x3D; new StreamReader(redweb, Encoding.Default);     &#x2F;&#x2F;从流中读出数据</span><br><span class="line"></span><br><span class="line">            StringBuilder sb &#x3D; new StringBuilder();                    &#x2F;&#x2F;可变字符</span><br><span class="line"></span><br><span class="line">            while ((strl &#x3D; sr.ReadLine()) !&#x3D; null)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                sb.Append(strl);                                &#x2F;&#x2F;读出数据存入可变字符中</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Getstr(sb.ToString());                                &#x2F;&#x2F;调用正则表达式方法读出标题</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else &#123; MessageBox.Show(&quot;请输入正确的网址&quot;); return; &#125;;            &#x2F;&#x2F;网址不合法则提示输入正确网址</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义方法Getstr用来实现提取网页标题功能。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void Getstr(string strUrl)                                    &#x2F;&#x2F;自定义方法用于获取网页标题</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    string d &#x3D; @&quot;&lt;title&gt;(?&lt;title&gt;\[^&lt;\]*)&lt;&#x2F;title&gt;&quot;;                         &#x2F;&#x2F;设置提取的类型</span><br><span class="line"></span><br><span class="line">    textBox2.Text &#x3D; Regex.Match(strUrl, d).ToString();                &#x2F;&#x2F;获取网页标题</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>书籍文档</category>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>收集整理 Mysql 的一些用法</title>
    <url>/zh-CN/2016/12/06/%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86%20Mysql%20%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95.html</url>
    <content><![CDATA[<p>1、说明：创建数据库 <code>Create DATABASE database-name</code></p>
<p>2、说明：删除数据库 <code>drop database dbname</code></p>
<p>3、说明：备份sql server —<br>创建 备份数据的 device <code>USE master EXEC sp_addumpdevice &#39;disk&#39;, &#39;testBack&#39;, &#39;c:\mssql7backup\MyNwind_1.dat&#39;</code> ---<br>开始 备份 <code>BACKUP DATABASE pubs TO testBack</code></p>
<p>4、说明：创建新表 <code>create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)</code><br>    根据已有的表创建新表：<br>    A：<code>create table tab_new like tab_old (使用旧表创建新表)</code><br>    B：<code>create table tab_new as select col1,col2… from tab_old definition only</code></p>
<p>5、说明：删除新表 <code>drop table tabname</code></p>
<p>6、说明：增加一个列 <code>Alter table tabname add column col type</code> 注：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型 的长度。</p>
<p>7、说明：添加主键： <code>Alter table tabname add primary key(col)</code> 说明：删除主键： <code>Alter table tabname drop primary key(col)</code></p>
<p>8、说明：创建索引：<code>create [unique] index idxname on tabname(col….)</code> 删除索引：<code>drop index idxname</code> 注：索引是不可更改的，想更改必须删除重新建。</p>
<p>9、说明：创建视图：<code>create view viewname as select statement</code> 删除视图：<code>drop view viewname</code></p>
<a id="more"></a>
<p>10、说明：几个简单的基本的sql语句<br>    选择：<code>select * from table1 where 范围</code><br>    插入：<code>insert into table1(field1,field2) values(value1,value2)</code> 删除：<code>delete from table1 where 范围</code><br>    更新：<code>update table1 set field1=value1 where 范围</code><br>    查找：<code>select * from table1 where field1 like &#39;%value1%&#39; ---like的语法很精妙，查资料!</code><br>    排序：<code>select * from table1 order by field1,field2 [desc]</code><br>    总数：<code>select count as totalcount from table1</code><br>    求和：<code>select sum(field1) as sumvalue from table1</code><br>    平均：<code>select avg(field1) as avgvalue from table1</code><br>    最大：<code>select max(field1) as maxvalue from table1</code><br>    最小：<code>select min(field1) as minvalue from table1</code></p>
<p>11、说明：几个高级查询运算词<br>    A： UNION 运算符 UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生 出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派 生表的每一行不是来自 TABLE1 就是来自 TABLE2。<br>    B： EXCEPT 运算符 EXCEPT 运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个 结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。<br>    C： INTERSECT 运算符 INTERSECT 运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果 表。当 ALL 随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。<br>注：使用运算词的几个查询结果行必须是一致的。</p>
<p>12、说明：使用外连接<br>    A、left outer join： 左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。<br>    sql: <code>select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c</code><br>    B：right outer join: 右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。<br>    C：full outer join： 全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。</p>
<p>13、说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用)<br>    法一：<code>select * into b from a where 1&lt;&gt;1</code><br>    法二：<code>select top 0 * into b from a</code></p>
<p>14、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用) <code>insert into b(a, b, c) select d,e,f from b;</code></p>
<p>15、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)<br>    <code>insert into b(a, b, c) select d,e,f from b in ‘具体数据库&#39; where 条件 例子：..from b in &#39;&quot;&amp;Server.MapPath(&quot;.&quot;)&amp;&quot;\data.mdb&quot; &amp;&quot;&#39; where..</code></p>
<p>16、说明：子查询(表名1：a 表名2：b)<br>    <code>select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)</code></p>
<p>17、说明：显示文章、提交人和最后回复时间<br>    <code>select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b</code></p>
<p>18.说明：外连接查询(表名1：a 表名2：b)<br>    <code>select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c</code></p>
<p>19、说明：在线视图查询(表名1：a )<br>    <code>select * from (Select a,b,c FROM a) T where t.a &gt; 1;</code></p>
<p>20、说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括<br>    <code>select * from table1 where time between time1 and time2 select a,b,c, from table1 where a not between 数值1 and 数值2</code></p>
<p>21、说明：in 的使用方法<br>    <code>select * from table1 where a [not] in (‘值1&#39;,&#39;值2&#39;,&#39;值4&#39;,&#39;值6&#39;)</code></p>
<p>22、说明：两张关联表，删除主表中已经在副表中没有的信息<br>    <code>delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 )</code></p>
<p>23、说明：四表联查问题：<br>    <code>select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where .....</code></p>
<p>24、说明：日程安排提前五分钟提醒<br>    sql: select * from 日程安排 where datediff(‘minute’,f开始时间,getdate())&gt;5</p>
<p>25、说明：一条sql 语句搞定数据库分页<br>    <code>select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段</code></p>
<p>26、说明：前10条记录<br>    <code>select top 10 * form table1 where 范围</code></p>
<p>27、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用 于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)<br>    <code>select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b)</code></p>
<p>28、说明：包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个 结果表<br>    <code>(select a from tableA ) except (select a from tableB) except (select a from tableC)</code></p>
<p>29、说明：随机取出10条数据<br>    <code>select top 10 * from tablename order by newid()</code></p>
<p>30、说明：随机选择记录<br>    <code>select newid()</code></p>
<p>31、说明：删除重复记录<br>    <code>Delete from tablename where id not in (select max(id) from tablename group by col1,col2,...)</code></p>
<p>32、说明：列出数据库里所有的表名<br>    select name from sysobjects where type=’U’</p>
<p>33、说明：列出表里的所有的<br>    <code>select name from syscolumns where id=object_id(&#39;TableName&#39;)</code></p>
<p>34、说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似 select 中的case。<br>    <code>select type,sum(case vender when &#39;A&#39; then pcs else 0 end),sum(case vender when &#39;C&#39; then pcs else 0 end),sum(case vender when &#39;B&#39; then pcs else 0 end) FROM tablename group by type</code> 显示结果： type vender pcs 电脑 A 1 电脑 A 1 光盘 B 2 光盘 A 2 手机 B 3 手机 C 3</p>
<p>35、说明：初始化表<br>    table1 TRUNCATE TABLE table1</p>
<p>36、说明：选择从10到15的记录<br>    <code>select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc</code><br>随机选择数据库记录的方法（使用Randomize函数，通过SQL语句实现）<br>对存储在数据库中的数据来说，随机数特性能给出上面的效果，但它们可能太慢了些。你不能 要求ASP“找个随机数”然后打印出来。<br>实际上常见的解决方案是建立如下所示的循环：<br>    <code>Randomize RNumber = Int(Rnd*499) +1</code> While Not objRec.EOF If objRec(“ID”) = RNumber THEN … 这里是执行脚本 … end if objRec.MoveNext Wend 这很容易理解。<br>首先，你取出1到500范围之内的一个随机数（假设500就是数据库内记录的总 数）。然后，你遍历每一记录来测试ID 的值、检查其是否匹配RNumber。满足条件的话就执行由 THEN 关键字开始的那一块代码。假如你的RNumber 等于495，那么要循环一遍数据库花的时间可就 长了。虽然500这个数字看起来大了些，但相比更为稳固的企业解决方案这还是个小型数据库了， 后者通常在一个数据库内就包含了成千上万条记录。这时候不就死定了？<br>采用SQL，你就可以很快地找出准确的记录并且打开一个只包含该记录的recordset，如下所示 ：<br>    <code>Randomize RNumber = Int(Rnd*499) + 1</code><br>    sql = “Select * FROM Customers Where ID = “ &amp; RNumber set objRec = ObjConn.Execute(SQL) Response.WriteRNumber &amp; “ = “ &amp; objRec(“ID”) &amp; “ “ &amp; objRec(“c_email”) 不必写出RNumber 和ID，你只需要检查匹配情况即可。<br>    只要你对以上代码的工作满意，你自可 按需操作“随机”记录。Recordset没有包含其他内容，因此你很快就能找到你需要的记录这样就 大大降低了处理时间。 再谈随机数 现在你下定决心要榨干Random 函数的最后一滴油，那么你可能会一次取出多条随机记录或者 想采用一定随机范围内的记录。把上面的标准Random 示例扩展一下就可以用SQL应对上面两种情况 了。<br>    为了取出几条随机选择的记录并存放在同一recordset内，你可以存储三个随机数，然后查询 数据库获得匹配这些数字的记录：<br>        <code>sql = &quot;Select * FROM Customers Where ID = &quot; &amp; RNumber &amp; &quot; or ID = &quot; &amp; RNumber2 &amp; &quot; or ID = &quot; &amp; RNumber3</code> 假如你想选出10条记录（也许是每次页面装载时的10条链接的列表），你可以用BETWEEN 或者 数学等式选出第一条记录和适当数量的递增记录。这一操作可以通过好几种方式来完成，但是 Select 语句只显示一种可能（这里的ID 是自动生成的号码）：<br>            <code>sql = &quot;Select * FROM Customers Where ID BETWEEN &quot; &amp; RNumber &amp; &quot; AND &quot; &amp; RNumber &amp; &quot;+ 9&quot;</code> 注意：以上代码的执行目的不是检查数据库内是否有9条并发记录。 随机读取若干条记录，测试过 Access语法：Select top 10 * From 表名 orDER BY Rnd(id) sql server:select top n * from 表名 order by newid() mysqlelect * From 表名 order By rand() Limit n Access左连接语法(最近开发要用左连接,Access帮助什么都没有,网上没有Access的SQL说明,只有 自己测试, 现在记下以备后查) 语法elect table1.fd1,table1,fd2,table2.fd2 From table1 left join table2 on table1.fd1,table2.fd1 where … 使用SQL语句 用…代替过长的字符串显示 语法： SQL数据库：select case when len(field)&gt;10 then left(field,10)+’…’ else field end as news_name,news_id from tablename Access数据库：Select iif(len(field)&gt;2,left(field,2)+’…’,field) FROM tablename; Conn.Execute说明 Execute方法 该方法用于执行SQL语句。根据SQL语句执行后是否返回记录集，该方法的使用格式分为以下两 种：<br>（1）.执行SQL查询语句时，将返回查询得到的记录集。用法为： Set 对象变量名=连接对象.Execute(“SQL 查询语言”) Execute方法调用后，会自动创建记录集对象，并将查询结果存储在该记录对象中，通过Set 方法，将记录集赋给指定的对象保存，以后对象变量就代表了该记录集对象。<br>（2）．执行SQL的操作性语言时，没有记录集的返回。此时用法为： 连接对象.Execute “SQL 操作性语句” [, RecordAffected][, Option] ?RecordAffected 为可选项，此出可放置一个变量，SQL语句执行后，所生效的记录 数会自动保存到该变量中。通过访问该变量，就可知道SQL语句队多少条记录进行了操作。 ?Option 可选项，该参数的取值通常为adCMDText，它用于告诉ADO，应该将Execute 方法之后的第一个字符解释为命令文本。通过指定该参数，可使执行更高效。 *BeginTrans、RollbackTrans、CommitTrans方法 这三个方法是连接对象提供的用于事务处理的方法。BeginTrans用于开始一个事物； RollbackTrans用于回滚事务；CommitTrans用于提交所有的事务处理结果，即确认事务的处理。 事务处理可以将一组操作视为一个整体，只有全部语句都成功执行后，事务处理才算成功；若 其中有一个语句执行失败，则整个处理就算失败，并恢复到处里前的状态。 BeginTrans和CommitTrans用于标记事务的开始和结束，在这两个之间的语句，就是作为事务 处理的语句。判断事务处理是否成功，可通过连接对象的Error集合来实现，若Error集合的成员个 数不为0，则说明有错误发生，事务处理失败。Error集合中的每一个Error对象，代表一个错误信 息。</p>
<p>37、一道SQL语句面试题，关于group by 表内容： 2005-05-09 胜 2005-05-09 胜 2005-05-09 负 2005-05-09 负 2005-05-10 胜 2005-05-10 负 2005-05-10 负 如果要生成下列结果, 该如何写sql语句? 胜 负 2005-05-09 2 2 2005-05-10 1 2 答：代码如下： <code>create table #tmp(rq varchar(10),shengfu nchar(1)) insert into #tmp values(&#39;2005-05-09&#39;,&#39;胜&#39;) insert into #tmp values(&#39;2005-05-09&#39;,&#39;胜&#39;) insert into #tmp values(&#39;2005-05-09&#39;,&#39;负&#39;) insert into #tmp values(&#39;2005-05-09&#39;,&#39;负&#39;) insert into #tmp values(&#39;2005-05-10&#39;,&#39;胜&#39;) insert into #tmp values(&#39;2005-05-10&#39;,&#39;负&#39;) insert into #tmp values(&#39;2005-05-10&#39;,&#39;负&#39;) 1)select rq, sum(case when shengfu=&#39;胜&#39; then 1 else 0 end)&#39;胜&#39;,sum(case when shengfu=&#39; 负&#39; then 1 else 0 end)&#39;负&#39; from #tmp group by rq 2) select N.rq,N.勝,M.負 from ( select rq,勝=count(*) from #tmp where shengfu=&#39;胜&#39;group by rq)N inner join (select rq,負=count(*) from #tmp where shengfu=&#39;负&#39;group by rq)M on N.rq=M.rq
3)select a.col001,a.a1 胜,b.b1 负 from (select col001,count(col001) a1 from temp1 where col002=&#39;胜&#39; group by col001) a, (select col001,count(col001) b1 from temp1 where col002=&#39;负&#39; group by col001) b where a.col001=b.col001</code></p>
<p>38、请教一个面试中遇到的SQL语句的查询问题 表中有A B C三列,用SQL语句实现：当A列大于B列时选择A列否则选择B列，当B列大于C列时选择B列 否则选择C列。 示例如下: <code>select (case when a&gt;b then a else b end ), (case when b&gt;c then b esle c end) from table_name</code></p>
<p>39、一个日期判断的sql语句？ 请取出tb_send表中日期(SendTime字段)为当天的所有记录?(SendTime字段为datetime型，包含日 期与时间) 示例如下: <code>select * from tb where datediff(dd,SendTime,getdate())=0</code></p>
<p>40、有一张表，里面有3个字段：语文，数学，英语。其中有3条记录分别表示语文70分，数学80分 ，英语58分，请用一条sql语句查询出这三条记录并按以下条件显示出来（并写出您的思路）： 大于或等于80表示优秀，大于或等于60表示及格，小于60分表示不及格。 显示格式： 语文 数学 英语 及格 优秀 不及格 示例如下： <code>select (case when 语文&gt;=80 then &#39;优秀&#39; when 语文&gt;=60 then &#39;及格&#39; else &#39;不及格&#39;) as 语文, (case when 数学&gt;=80 then &#39;优秀&#39; when 数学&gt;=60 then &#39;及格&#39; else &#39;不及格&#39;) as 数学, (case when 英语&gt;=80 then &#39;优秀&#39; when 英语&gt;=60 then &#39;及格&#39; else &#39;不及格&#39;) as 英语, from table</code></p>
<p>41、在sqlserver2000中请用sql创建一张用户临时表和系统临时表，里面包含两个字段ID和 IDValues,类型都是int型，并解释下两者的区别? 用户临时表:create table #xx(ID int, IDValues int) 系统临时表:create table ##xx(ID int, IDValues int) 区别: 用户临时表只对创建这个表的用户的Session可见,对其他进程是不可见的. 当创建它的进程消失时这个临时表就自动删除. 全局临时表对整个SQL Server实例都可见,但是所有访问它的Session都消失的时候,它也自动删除.</p>
<p>42、sqlserver2000是一种大型数据库，他的存储容量只受存储介质的限制，请问它是通过什么方 式实现这种无限容量机制的。 它的所有数据都存储在数据文件中(*.dbf),所以只要文件够大,SQL Server的存储容量是可以扩 大的. SQL Server 2000 数据库有三种类型的文件： 主要数据文件 主要数据文件是数据库的起点，指向数据库中文件的其它部分。每个数据库都有一个主要数据文件 。主要数据文件的推荐文件扩展名是 .mdf。 次要数据文件 次要数据文件包含除主要数据文件外的所有数据文件。有些数据库可能没有次要数据文件，而有些 数据库则有多个次要数据文件。次要数据文件的推荐文件扩展名是 .ndf。 日志文件 日志文件包含恢复数据库所需的所有日志信息。每个数据库必须至少有一个日志文件，但可以不止 一个。日志文件的推荐文件扩展名是 .ldf。</p>
<p>43、请用一个sql语句得出结果 从table1,table2中取出如table3所列格式数据，注意提供的数据及结果不准确，只是作为一个格 式向大家请教。 如使用存储过程也可以。 table1 月份mon 部门dep 业绩yj 一月份 01 10 一月份 02 10 一月份 03 5 二月份 02 8 二月份 04 9 三月份 03 8 table2 部门dep 部门名称dname ——————————– 01 国内业务一部 02 国内业务二部 03 国内业务三部 04 国际业务部 table3 （result） 部门dep 一月份 二月份 三月份 ————————————– 01 10 null null 02 10 8 null 03 null 5 8 04 null null 9 ——————————————</p>
<p>1) <code>select a.部门名称dname,b.业绩yj as &#39;一月份&#39;,c.业绩yj as &#39;二月份&#39;,d.业绩yj as &#39;三月份&#39; from table1 a,table2 b,table2 c,table2 d where a.部门dep = b.部门dep and b.月份mon = &#39;一月份&#39; and a.部门dep = c.部门dep and c.月份mon = &#39;二月份&#39; and a.部门dep = d.部门dep and d.月份mon = &#39;三月份&#39; and
2) select a.dep, sum(case when b.mon=1 then b.yj else 0 end) as &#39;一月份&#39;, sum(case when b.mon=2 then b.yj else 0 end) as &#39;二月份&#39;, sum(case when b.mon=3 then b.yj else 0 end) as &#39;三月份&#39;, sum(case when b.mon=4 then b.yj else 0 end) as &#39;四月份&#39;, sum(case when b.mon=5 then b.yj else 0 end) as &#39;五月份&#39;, sum(case when b.mon=6 then b.yj else 0 end) as &#39;六月份&#39;, sum(case when b.mon=7 then b.yj else 0 end) as &#39;七月份&#39;, sum(case when b.mon=8 then b.yj else 0 end) as &#39;八月份&#39;, sum(case when b.mon=9 then b.yj else 0 end) as &#39;九月份&#39;, sum(case when b.mon=10 then b.yj else 0 end) as &#39;十月份&#39;, sum(case when b.mon=11 then b.yj else 0 end) as &#39;十一月份&#39;, sum(case when b.mon=12 then b.yj else 0 end) as &#39;十二月份&#39;, from table2 a left join table1 b on a.dep=b.dep</code></p>
<p>44、华为一道面试题 一个表中的Id有多个记录，把所有这个id的记录查出来，并显示有多少条记录。 ————————————————-<br><code>select id, Count(*) from tb group by id having count(*)&gt;1 select*from(select count(ID) as count from table group by ID)T where T.count&gt;1</code><br>【mysql】mysql 常用建表语句 . 分类：<br>【07-MySql数据库】<br>【06-基础知识】 2012-03-27 23:31 43383人阅读 评论(3) 收藏 举报 mysqltableemailinsertnullqq<br>【1】建立员工档案表 要求字段：员工员工编号，员工姓名，性别，工资，email，入职时间，部门。<br>【2】合理选择数据类型及字段修饰符，要求有NOT NULL，auto_increment, primary key等。 <code>-- -- make by kakane --</code> DROP TABLE IF EXISTS `workers_info`; CREATE TABLE `workers_info` ( `id` int(11) NOT NULL AUTO_INCREMENT, `workername` varchar(20) NOT NULL, `sex` enum(F,M,S), `salary` int(11) DEFAULT ‘0’, `email` varchar(30), `EmployedDates` date, `department` varchar(30), PRIMARY KEY (`id`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8; mysql&gt; alter table workers_info ADD sex enum(‘F’,’M’,’S’);<br>【3】查看表的结构 <code>mysql&gt; desc workers_info;</code><br>【4】新增qq和tel字段，要求tel字段位于email前，要求入职时间是最后一个字段 <code>mysql&gt; ALTER TABLE workers_info ADD tel varchar(15) after salary; mysql&gt; ALTER TABLE workers_info ADD qq int; ALTER TABLE workers_info MODIFY EmployedDates date after qq;</code><br>【5】把email字段修改成mailbox <code>mysql&gt; ALTER TABLE workers_info CHANGE email mailbox varchar(30);</code><br>【6】向表里添加10条记录 <code>mysql&gt; INSERT INTO workers_info values(NULL,&#39;xing&#39;,10000,&#39;1598232123&#39;,&#39;xing@qq.com&#39;,&#39;yanfa&#39;,736019646,20121221); mysql&gt; INSERT INTO workers_info (workername,salary,tel,mailbox,department,qq,EmployedDates) values(&#39;xing&#39;,10000,&#39;1598232123&#39;,&#39;xing@qq.com&#39;,&#39;yanfa&#39;,736019646,20121221);</code><br>【7】修改其中两条记录的tel和mailbox <code>mysql&gt; UPDATE workers_info SET mailbox = &#39;haha@qq.com&#39; WHERE id = 14; mysql&gt; UPDATE workers_info SET mailbox = &#39;haha@qq.com&#39;,tel=&#39;1246543423&#39; WHERE id = 13;</code><br>【8】查看所添加记录 <code>mysql&gt; select * from workers_info;</code><br>【9】查看姓名和入职时间记录 <code>mysql&gt; select workername,EmployedDates from workers_info;</code><br>【10】查询入职时间在2003年以前的 <code>mysql&gt; select * from workers_info where year(EmployedDates) &lt; 2003;
【11】查询工资最高和最低的员工姓名 mysql&gt; select * from workers_info ORDER BY salary limit 1; mysql&gt; select * from workers_info ORDER BY salary desc limit 1;</code><br>【12】查询平均工资 <code>mysql&gt; select avg(salary) from workers_info;</code><br>【13】统计男员工人数、女员工人数 <code>mysql&gt; select count(男) from workers_info where sex=&quot;M&quot;; mysql&gt; select count(男) from workers_info where sex=&quot;M&quot;;</code><br>【14】按照入职时间先后进行排序，并显示前5位员工姓名 <code>mysql&gt; select * from workers_info ORDER BY EmployedDates limit 5;</code></p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>美化单选按钮控件</title>
    <url>/zh-CN/2019/10/03/%E7%BE%8E%E5%8C%96%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6.html</url>
    <content><![CDATA[<div>
<li>来源:<a href="http://renwu.mingrisoft.com/" target="_blank" rel="external nofollow">明日科技</a></li>
</div>

<h2 id="美化单选按钮控件"><a href="#美化单选按钮控件" class="headerlink" title="美化单选按钮控件"></a>美化单选按钮控件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>用户使用C#自带的控件制作应用程序时，为了使界面更加美观，更具有特色，可以对控件的样式进行重绘，本实例将对单选按钮控件进行重绘，以用户自定义样式进行显示。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0816_1.png" alt=""></p>
<p>图1 美化单选按钮控件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在美化单选按钮控件时，主要是通过重绘单选框实现的，具体实现时，首先需要创建用户控件，然后在用户控件中使用Graphics类的DrawEllipse方法和FillEllipse方法实现重绘单选框操作。下面对本实例中用到的关键技术进行详细讲解。 </p>
<a id="more"></a>
<p>（1）创建用户控件并使用 创建用户控件的步骤如下：<br>①选中当前项目，单击右键，在弹出的快捷菜单中选择”添加”/“新建项”命令，弹出如图2所示的”添加新项”对话框。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0816_2.png" alt=""></p>
<p>图2 “添加新项”对话框<br>②在图2所示对话框中找到”用户控件”并选中，在”名称”文本框中输入用户控件的名称，单击”添加”按钮，即可在当前项目中添加一个用户控件，如图3所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0816_3.png" alt=""></p>
<p>图3 添加的用户控件<br>③在用户控件中，如果需要添加Windows标准控件，可以从”工具箱”中直接拖放使用；如果需要编写代码，则单击”单击此处切换到代码视图”超级链接，进入后台代码视图，以便编写所需的代码。<br>④用户控件制作完成后，选中制作完成的用户控件，用鼠标将其拖拽到工具箱中，如图4所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0816_4.png" alt=""></p>
<p>图4 将用户控件拖拽到工具箱中<br>⑤最后就可以像使用Windows标准控件一样，对用户控件进行拖拽使用了。<br>（2）DrawEllipse方法<br>DrawEllipse方法用来绘制一个由边框（该边框由一对坐标、高度和宽度指定）定义的椭圆，该方法有4种重载形式，本实例中用到的它的重载形式如下：</p>
<p>public void DrawEllipse(Pen pen,Rectangle rect)</p>
<p>参数说明 R pen：Pen对象，它确定曲线的颜色、宽度和样式。<br>rect：Rectangle结构，它定义椭圆的边界。<br>（3）FillEllipse方法 FillEllipse方法用来填充边框所定义的椭圆的内部，该边框由一对坐标、一个宽度和一个高度指定，该方法有4种重载形式，本实例中用到的它的重载形式如下：</p>
<p>public void FillEllipse(Brush brush,Rectangle rect)</p>
<p>参数说明 R brush：确定填充特性的Brush。<br>rect：Rectangle结构，它表示定义椭圆的边框。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为BeautifulRadioButton。<br>（2）在当前项目中添加一个用户控件，将其命名为GlorifyRadioButton。将用户控件继承的UserControl类改为RadioButton类。<br>（3）程序主要代码如下： 在GlorifyRadioButton控件中定义变量，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private bool FontAspect &#x3D; false;                                        &#x2F;&#x2F;判断字体的方向</span><br><span class="line">private int Measurement &#x3D; 255;                                        &#x2F;&#x2F;设置渐变的初始值</span><br><span class="line">LinearGradientBrush Periphery_br;                                    &#x2F;&#x2F;外圆的颜色</span><br><span class="line">LinearGradientBrush Central_br;                                        &#x2F;&#x2F;移入控件时中圆的颜色</span><br><span class="line">LinearGradientBrush NoCentral_br;                                    &#x2F;&#x2F;无操作时中圆的颜色</span><br><span class="line">LinearGradientBrush Stipple_br;                                        &#x2F;&#x2F;内圆选中的颜色</span><br><span class="line">LinearGradientBrush NoStipple_br;                                    &#x2F;&#x2F;内圆无选中的颜色</span><br></pre></td></tr></table></figure>
<p>  在GlorifyRadioButton控件的OnPaint事件中对控件的样式进行重绘，主要是通过SystemInformation类的SmallIconSize属性来获取单选按钮左边单选框的大小及位置，然后对单选框进行重绘。实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 控件在需要重绘时触发</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    e.Graphics.FillRectangle(SystemBrushes.Control, e.ClipRectangle);                &#x2F;&#x2F;填充矩形</span><br><span class="line">                                                                                     &#x2F;&#x2F;清除锯齿</span><br><span class="line">    e.Graphics.SmoothingMode &#x3D; System.Drawing.Drawing2D.SmoothingMode.AntiAlias;</span><br><span class="line">    Rectangle boxrect &#x3D; new Rectangle(e.ClipRectangle.X, e.ClipRectangle.Y, SystemInformation.SmallIconSize.Width, e.ClipRectangle.Height);            &#x2F;&#x2F;获取左面图标的区域</span><br><span class="line">                                                                                                                                                       &#x2F;&#x2F;获取绘制的文本的区域</span><br><span class="line">    Rectangle strrect &#x3D; new Rectangle(e.ClipRectangle.X + SystemInformation.SmallIconSize.Width, e.ClipRectangle.Y, e.ClipRectangle.Width + 2 - SystemInformation.SmallIconSize.Width, e.ClipRectangle.Height);</span><br><span class="line">    if (FontAspect)                                                &#x2F;&#x2F;判断字体的读取方式</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;设置椭圆的位置</span><br><span class="line">        boxrect.X &#x3D; e.ClipRectangle.X + e.ClipRectangle.Width - SystemInformation.SmallIconSize.Width;</span><br><span class="line">        strrect.X &#x3D; e.ClipRectangle.X;                                    &#x2F;&#x2F;设置字体位置</span><br><span class="line">    &#125;</span><br><span class="line">    Point MousePos &#x3D; this.PointToClient(Control.MousePosition);                    &#x2F;&#x2F;获取鼠标的位置</span><br><span class="line">    bool Above &#x3D; e.ClipRectangle.Contains(MousePos);                        &#x2F;&#x2F;获取鼠标是否在当前控件上</span><br><span class="line">    DrawBox(e.Graphics, boxrect, Above);                                &#x2F;&#x2F;绘制单选图案</span><br><span class="line">    DrawText(e.Graphics, strrect);                                    &#x2F;&#x2F;绘制文字</span><br><span class="line">    if (!Enabled)</span><br><span class="line">        e.Graphics.FillRectangle(new SolidBrush(Color.FromArgb(127, SystemColors.Control)), e.ClipRectangle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  自定义方法DrawBox主要通过LinearGradientBrush类来设置单选框的绘制颜色，然后用Graphics类进行绘制。实现代码如下：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 绘制单选控件的图案</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param g&#x3D;&quot;Graphics&quot;&gt;封装一个绘图的对象&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param rect&#x3D;&quot;Rectangle&quot;&gt;单选图案的绘制区域&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param Above&#x3D;&quot;bool&quot;&gt;断判鼠标是否在控件上方&lt;&#x2F;param&gt;</span><br><span class="line">private void DrawBox(Graphics g, Rectangle rect, bool Above)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;设置外椭圆的渐变色</span><br><span class="line">    int opacity &#x3D; Measurement;</span><br><span class="line">    Periphery_br &#x3D; new LinearGradientBrush(rect, Color.FromArgb(opacity &#x2F; 2, PeripheryColor), Color.FromArgb(opacity, PeripheryColor), LinearGradientMode.ForwardDiagonal);</span><br><span class="line">    &#x2F;&#x2F;设置中间椭圆形选中时的渐变色</span><br><span class="line">    opacity &#x3D; (int)(.4f * opacity + .5f);</span><br><span class="line">    Central_br &#x3D; new LinearGradientBrush(rect, Color.FromArgb(opacity &#x2F; 10, CentralColor), Color.FromArgb(opacity, CentralColor), LinearGradientMode.ForwardDiagonal);</span><br><span class="line">    &#x2F;&#x2F;设置中间椭圆形无操作时的渐变色</span><br><span class="line">    opacity &#x3D; (int)(.4f * opacity + .5f);</span><br><span class="line">    NoCentral_br &#x3D; new LinearGradientBrush(rect, Color.FromArgb(opacity &#x2F; 10, NoCentralColor), Color.FromArgb(opacity, NoCentralColor), LinearGradientMode.ForwardDiagonal);</span><br><span class="line">    &#x2F;&#x2F;设置内圆形选中时的渐变色</span><br><span class="line">    opacity &#x3D; Measurement;</span><br><span class="line">    Stipple_br &#x3D; new LinearGradientBrush(rect, Color.FromArgb(opacity &#x2F; 5, StippleColor), Color.FromArgb(opacity, StippleColor), LinearGradientMode.BackwardDiagonal);</span><br><span class="line">    &#x2F;&#x2F;设置内圆形无操作时的渐变色</span><br><span class="line">    opacity &#x3D; (int)(.4f * opacity + .5f);</span><br><span class="line">    NoStipple_br &#x3D; new LinearGradientBrush(rect, Color.FromArgb(opacity &#x2F; 10, NoStippleColor), Color.FromArgb(opacity, NoStippleColor), LinearGradientMode.BackwardDiagonal);</span><br><span class="line">    int size &#x3D; this.Font.Height;                                        &#x2F;&#x2F;获取字体的高度</span><br><span class="line">                                                                        &#x2F;&#x2F;获取外椭圆的区域</span><br><span class="line">    Rectangle box &#x3D; new Rectangle(rect.X + ((rect.Width - size) &#x2F; 2), rect.Y + ((rect.Height - size) &#x2F; 2), size - 2, size - 2);</span><br><span class="line">    Rectangle glyph &#x3D; new Rectangle(box.X + 3, box.Y + 3, box.Width - 6, box.Height - 6);    &#x2F;&#x2F;设置内圆的绘制区域</span><br><span class="line">    g.FillEllipse(new SolidBrush(SystemColors.Window), box);                    &#x2F;&#x2F;以白色填充单选图案</span><br><span class="line">    if (Above &amp;&amp; this.Enabled)                                        &#x2F;&#x2F;如果鼠标移入该控件</span><br><span class="line">    &#123;</span><br><span class="line">        g.DrawEllipse(new Pen(Central_br, (float)(3)), new Rectangle(box.X + 2, box.Y + 2, box.Width - 4, box.Height - 4));    &#x2F;&#x2F;绘制中心椭圆</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        g.DrawEllipse(new Pen(NoCentral_br, (float)(3)), new Rectangle(box.X + 2, box.Y + 2, box.Width - 4, box.Height - 4));    &#x2F;&#x2F;绘制中心椭圆</span><br><span class="line">    &#125;</span><br><span class="line">    g.DrawEllipse(new Pen(Periphery_br, (float)(1.5)), box);                        &#x2F;&#x2F;绘制外椭圆</span><br><span class="line">    g.FillEllipse(new SolidBrush(SystemColors.Window), glyph);                    &#x2F;&#x2F;以白色填充内圆</span><br><span class="line">    if (this.Checked)                                            &#x2F;&#x2F;如果选中当前控件</span><br><span class="line">        g.FillEllipse(Stipple_br, glyph);                                    &#x2F;&#x2F;填充内圆</span><br><span class="line">    else</span><br><span class="line">        g.FillEllipse(NoStipple_br, glyph);                                &#x2F;&#x2F;填充内圆</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  自定义方法DrawText主要是通过判断单选按钮控件的显示方向，并在控件的指定位置绘制文本信息。实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 绘制文本</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param g&#x3D;&quot;Graphics&quot;&gt;封装一个绘图的对象&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param rect&#x3D;&quot;Rectangle&quot;&gt;绘制文本的区域&lt;&#x2F;param&gt;</span><br><span class="line">private void DrawText(Graphics g, Rectangle rect)</span><br><span class="line">&#123;</span><br><span class="line">    StringFormat tem_StringF &#x3D; new StringFormat();                            &#x2F;&#x2F;创建StringFormat对象</span><br><span class="line">    tem_StringF.Alignment &#x3D; StringAlignment.Near;                            &#x2F;&#x2F;指定文本靠近布局对齐</span><br><span class="line">    tem_StringF.LineAlignment &#x3D; StringAlignment.Center;                        &#x2F;&#x2F;文本居中对齐</span><br><span class="line">    if (FontAspect)                                                &#x2F;&#x2F;如果控件是原始方向显示</span><br><span class="line">        tem_StringF.FormatFlags &#x3D; StringFormatFlags.DirectionRightToLeft;            &#x2F;&#x2F;按从右到左的顺序显示文本</span><br><span class="line">    if (!FontAspect)                                                &#x2F;&#x2F;如果控件是反方向显示</span><br><span class="line">                                                                    &#x2F;&#x2F;绘制文本（从左端开始绘制）</span><br><span class="line">        g.DrawString(this.Text, this.Font, SystemBrushes.ControlText, rect, tem_StringF);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        rect.X &#x3D; rect.X - SystemInformation.SmallIconSize.Width &#x2F; 2 + 2;                &#x2F;&#x2F;设置文本的起始位置（在小图标后）</span><br><span class="line">                                                                                        &#x2F;&#x2F;绘制文本</span><br><span class="line">        g.DrawString(this.Text, this.Font, SystemBrushes.ControlText, rect, tem_StringF);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  自定义方法getAspect主要用于获取单选按钮控件的显示方向，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 获取文本的读取方向</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;return&gt;布尔型&lt;&#x2F;return&gt;</span><br><span class="line">private bool getAspect()</span><br><span class="line">&#123;</span><br><span class="line">    bool tem_Aspect &#x3D; false;</span><br><span class="line">    if (this.RightToLeft &#x3D;&#x3D; RightToLeft.Yes)                                &#x2F;&#x2F;从右到左进行读取</span><br><span class="line">        tem_Aspect &#x3D; true;</span><br><span class="line">    if (this.RightToLeft &#x3D;&#x3D; RightToLeft.No)                                &#x2F;&#x2F;从左到右进行读取</span><br><span class="line">        tem_Aspect &#x3D; false;</span><br><span class="line">    return tem_Aspect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟002：RadioButton控件的使用。<br>RadioButton控件，又称为单选按钮控件，它为用户提供由两个或多个互斥选项组成的选项集，当用户选中某单选按钮时，同一组中的其他单选按钮不能同时选定。例如，在开发考试管理系统时，如果考试题中有单项选择题，则可以使用RadioButton控件来表示单项选择题的各个选项。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
  </entry>
  <entry>
    <title>C# 显示空心文字效果</title>
    <url>/zh-CN/2016/07/04/c-e6-98-be-e7-a4-ba-e7-a9-ba-e5-bf-83-e6-96-87-e5-ad-97-e6-95-88-e6-9e-9c.html</url>
    <content><![CDATA[<p>显示空心字的实现方法</p>
<p>using System;<br>using System.Drawing;<br>using System.Collections;<br>using System.ComponentModel;<br>using System.Windows.Forms;<br>using System.Data;</p>
<p>namespace Example040_空心字体效果演示<br>{<br>    /// <summary><br>    /// Form1 的摘要说明。<br>    /// </summary><br>    public class Form1 : System.Windows.Forms.Form<br>    {<br>        private System.Windows.Forms.Button button1;<br>        private System.Windows.Forms.TextBox textBox1;<br>        /// <summary><br>        /// 必需的设计器变量。<br>        /// </summary><br>        private System.ComponentModel.Container components = null;</p>
<pre><code>    public Form1()
    {
        //
        // Windows 窗体设计器支持所必需的
        //
        InitializeComponent();

        //
        // TODO: 在 InitializeComponent 调用后添加任何构造函数代码
        //
    }

    /// &lt;summary&gt;
    /// 清理所有正在使用的资源。
    /// &lt;/summary&gt;
    protected override void Dispose( bool disposing )
    {
        if( disposing )
        {
            if (components != null) 
            {
                components.Dispose();
            }
        }
        base.Dispose( disposing );
    }

    #region Windows Form Designer generated code
    /// &lt;summary&gt;
    /// 设计器支持所需的方法 \- 不要使用代码编辑器修改
    /// 此方法的内容。
    /// &lt;/summary&gt;
    private void InitializeComponent()
    {
        this.button1 = new System.Windows.Forms.Button();
        this.textBox1 = new System.Windows.Forms.TextBox();
        this.SuspendLayout();
        // 
        // button1
        // 
        this.button1.Location = new System.Drawing.Point(24, 104);
        this.button1.Name = &quot;button1&quot;;
        this.button1.Size = new System.Drawing.Size(97, 23);
        this.button1.TabIndex = 0;
        this.button1.Text = &quot;View&quot;;
        this.button1.Click += new System.EventHandler(this.button1_Click);
        // 
        // textBox1
        // 
        this.textBox1.Location = new System.Drawing.Point(24, 80);
        this.textBox1.Name = &quot;textBox1&quot;;
        this.textBox1.Size = new System.Drawing.Size(96, 21);
        this.textBox1.TabIndex = 1;
        this.textBox1.Text = &quot;textBox1&quot;;
        // 
        // Form1
        // 
        this.AutoScaleBaseSize = new System.Drawing.Size(6, 14);
        this.ClientSize = new System.Drawing.Size(152, 141);
        this.Controls.AddRange(new System.Windows.Forms.Control\[\] {
                                                                      this.textBox1,
                                                                      this.button1});
        this.Name = &quot;Form1&quot;;
        this.Text = &quot;Form1&quot;;
        this.ResumeLayout(false);

    }
    #endregion

    /// &lt;summary&gt;
    /// 应用程序的主入口点。
    /// &lt;/summary&gt;
    \[STAThread\]
    static void Main() 
    {
        Application.Run(new Form1());
    }

    \[System.Runtime.InteropServices.DllImport(&quot;gdi32&quot;)\]
    private static extern IntPtr CreateFont(int H,int W,int E,int O,int FW,int I,int u,int S,int C,int OP,int CP,int Q,int PAF,string F);
    \[System.Runtime.InteropServices.DllImport(&quot;gdi32&quot;)\]
    private static extern IntPtr BeginPath(IntPtr hdc);
    \[System.Runtime.InteropServices.DllImport(&quot;gdi32&quot;)\]
    private static extern IntPtr EndPath(IntPtr hdc);
    \[System.Runtime.InteropServices.DllImport(&quot;gdi32&quot;)\]
    private static extern int SetBkMode(IntPtr hdc,int nBkMode);
    \[System.Runtime.InteropServices.DllImport(&quot;gdi32&quot;)\]
    private static extern IntPtr StrokePath(IntPtr hdc);
    \[System.Runtime.InteropServices.DllImport(&quot;gdi32&quot;)\]
    private static extern int TextOut(IntPtr hdc,int x,int y,string lpString,int nCount);
    \[System.Runtime.InteropServices.DllImport(&quot;gdi32&quot;)\]
    private static extern IntPtr SelectObject(IntPtr hdc,IntPtr hObject);
    \[System.Runtime.InteropServices.DllImport(&quot;user32&quot;)\]
    private static extern IntPtr GetDC(IntPtr hwnd);
    const int FW_HEAVY = 900;
    const int ANSI_CHARSET = 0;
    const int OUT\_DEFAULT\_PRECIS = 0;
    const int CLIP\_DEFAULT\_PRECIS = 0;
    const int DEFAULT_QUALITY = 0;
    const int DEFAULT_PITCH = 0;
    const int FF_SWISS = 32;
    const int TRANSPARENT = 1;

    private void button1_Click(object sender, System.EventArgs e)
    {
        IntPtr dc=GetDC(this.Handle);
        IntPtr m\_Font=CreateFont(50, 20, 0, 0, FW\_HEAVY, 1, 0,
            0, ANSI\_CHARSET, OUT\_DEFAULT_PRECIS,
            CLIP\_DEFAULT\_PRECIS, DEFAULT_QUALITY,
            DEFAULT\_PITCH | FF\_SWISS, &quot;Times New Roman&quot;);
        //创建字体
        //这里的字体一定要是TrueType Font

        BeginPath(dc);
        //开始捕获轮廓
        SetBkMode(dc, TRANSPARENT );
        IntPtr m\_OldFont=SelectObject(dc,m\_Font);
        TextOut(dc,10,0,this.textBox1.Text,this.textBox1.Text.Length);
        SelectObject(dc,m_OldFont);
        EndPath(dc);
        //结束捕获
        StrokePath(dc);
        //将捕获的轮廓用当前的Pen画到Canvas上        
    }
}</code></pre><p>}</p>
<p><img data-src="https://cdn.fesugar.com/2016/07/2016-07-04-08485247.png" alt="QQ图片20160704164551"></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 无边框窗体的移动</title>
    <url>/zh-CN/2016/07/04/c-e6-97-a0-e8-be-b9-e6-a1-86-e7-aa-97-e4-bd-93-e7-9a-84-e7-a7-bb-e5-8a-a8.html</url>
    <content><![CDATA[<p>实现无边框窗体的移动</p>
<p>using System;<br>using System.Drawing;<br>using System.Collections;<br>using System.ComponentModel;<br>using System.Windows.Forms;<br>using System.Data;<br>using System.Runtime.InteropServices;  </p>
<p>namespace Example013_无标题窗体的拖动<br>{<br>    /// <summary><br>    /// Form1 的摘要说明。<br>    /// </summary><br>    public class Form1 : System.Windows.Forms.Form<br>    {<br>        /// <summary><br>        /// 必需的设计器变量。<br>        /// </summary><br>        private System.ComponentModel.Container components = null;</p>
<pre><code>    public Form1()
    {
        //
        // Windows 窗体设计器支持所必需的
        //
        InitializeComponent();

        //
        // TODO: 在 InitializeComponent 调用后添加任何构造函数代码
        //
    }

    /// &lt;summary&gt;
    /// 清理所有正在使用的资源。
    /// &lt;/summary&gt;
    protected override void Dispose( bool disposing )
    {
        if( disposing )
        {
            if (components != null) 
            {
                components.Dispose();
            }
        }
        base.Dispose( disposing );
    }

    #region Windows Form Designer generated code
    /// &lt;summary&gt;
    /// 设计器支持所需的方法 \- 不要使用代码编辑器修改
    /// 此方法的内容。
    /// &lt;/summary&gt;
    private void InitializeComponent()
    {
        this.SuspendLayout();
        // 
        // Form1
        // 
        this.AutoScaleBaseSize = new System.Drawing.Size(6, 14);
        this.ClientSize = new System.Drawing.Size(292, 273);
        this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
        this.Name = &quot;Form1&quot;;
        this.Text = &quot;Form1&quot;;
        this.MouseDown += new System.Windows.Forms.MouseEventHandler(this.Form1_MouseDown);
        this.ResumeLayout(false);

    }
    #endregion

    /// &lt;summary&gt;
    /// 应用程序的主入口点。
    /// &lt;/summary&gt;
    \[STAThread\]
    static void Main() 
    {
        Application.Run(new Form1());
    }

    \[DllImport(&quot;user32.dll&quot;)\]
    public static extern bool ReleaseCapture();
    \[DllImport(&quot;user32.dll&quot;)\]
    public static extern bool SendMessage(IntPtr hwnd,int wMsg,int wParam,int lParam);

    public const int WM_SYSCOMMAND=0x0112;
    public const int SC_MOVE=0xF010;
    public const int HTCAPTION=0x0002;

    private void Form1_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
    {
        ReleaseCapture();
        SendMessage(this.Handle,WM\_SYSCOMMAND,SC\_MOVE+HTCAPTION, 0); 
    }
}</code></pre><p>}</p>
<p><img data-src="https://cdn.fesugar.com/2016/07/2016-07-04-07511010.png" alt="QQ图片20160704154934"></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 显示阴影效果文字</title>
    <url>/zh-CN/2016/07/04/c-e6-98-be-e7-a4-ba-e9-98-b4-e5-bd-b1-e6-95-88-e6-9e-9c-e6-96-87-e5-ad-97.html</url>
    <content><![CDATA[<p>阴影文字实现方法</p>
<p>using System;<br>using System.Drawing;<br>using System.Collections;<br>using System.ComponentModel;<br>using System.Windows.Forms;<br>using System.Data;</p>
<p>namespace Example037_阴影效果的文字<br>{<br>    /// <summary><br>    /// Form1 的摘要说明。<br>    /// </summary><br>    public class Form1 : System.Windows.Forms.Form<br>    {<br>        /// <summary><br>        /// 必需的设计器变量。<br>        /// </summary><br>        private System.ComponentModel.Container components = null;</p>
<pre><code>    public Form1()
    {
        //
        // Windows 窗体设计器支持所必需的
        //
        InitializeComponent();

        //
        // TODO: 在 InitializeComponent 调用后添加任何构造函数代码
        //
    }

    /// &lt;summary&gt;
    /// 清理所有正在使用的资源。
    /// &lt;/summary&gt;
    protected override void Dispose( bool disposing )
    {
        if( disposing )
        {
            if (components != null) 
            {
                components.Dispose();
            }
        }
        base.Dispose( disposing );
    }

    #region Windows Form Designer generated code
    /// &lt;summary&gt;
    /// 设计器支持所需的方法 \- 不要使用代码编辑器修改
    /// 此方法的内容。
    /// &lt;/summary&gt;
    private void InitializeComponent()
    {
        // 
        // Form1
        // 
        this.AutoScaleBaseSize = new System.Drawing.Size(6, 14);
        this.ClientSize = new System.Drawing.Size(292, 273);
        this.Name = &quot;Form1&quot;;
        this.Text = &quot;Form1&quot;;
        this.Paint += new System.Windows.Forms.PaintEventHandler(this.Form1_Paint);

    }
    #endregion

    /// &lt;summary&gt;
    /// 应用程序的主入口点。
    /// &lt;/summary&gt;
    \[STAThread\]
    static void Main() 
    {
        Application.Run(new Form1());
    }

    private void Form1_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
    {
        Graphics g=e.Graphics; 
        Font myFont;
        myFont=new Font(&quot;SansSerif&quot;,40); 

        SolidBrush textShadowBrush = new SolidBrush(Color.FromArgb(70, Color.Blue));

        g.DrawString(&quot;Hello C#&quot;,myFont,Brushes.Blue, 25, 25 );
        g.DrawString(&quot;Hello C#&quot;,myFont,textShadowBrush, 30, 30);
        //显示带阴影的文字

    }
}</code></pre><p>}</p>
<p><img data-src="https://cdn.fesugar.com/2016/07/2016-07-04-0823584.png" alt="QQ图片20160704162322"></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 模拟按键操作</title>
    <url>/zh-CN/2016/07/05/c-e6-a8-a1-e6-8b-9f-e6-8c-89-e9-94-ae-e6-93-8d-e4-bd-9c.html</url>
    <content><![CDATA[<p>在控件获取焦点的情况下模拟按键操作</p>
<p>using System;<br>using System.Drawing;<br>using System.Collections;<br>using System.ComponentModel;<br>using System.Windows.Forms;<br>using System.Data;</p>
<p>namespace Example108_模拟键盘操作<br>{<br>    /// <summary><br>    /// Form1 的摘要说明。<br>    /// </summary><br>    public class Form1 : System.Windows.Forms.Form<br>    {<br>        private System.Windows.Forms.RichTextBox richTextBox1;<br>        private System.Windows.Forms.Button button1;<br>        /// <summary><br>        /// 必需的设计器变量。<br>        /// </summary><br>        private System.ComponentModel.Container components = null;</p>
<pre><code>    public Form1()
    {
        //
        // Windows 窗体设计器支持所必需的
        //
        InitializeComponent();

        //
        // TODO: 在 InitializeComponent 调用后添加任何构造函数代码
        //
    }

    /// &lt;summary&gt;
    /// 清理所有正在使用的资源。
    /// &lt;/summary&gt;
    protected override void Dispose( bool disposing )
    {
        if( disposing )
        {
            if (components != null) 
            {
                components.Dispose();
            }
        }
        base.Dispose( disposing );
    }

    #region Windows Form Designer generated code
    /// &lt;summary&gt;
    /// 设计器支持所需的方法 \- 不要使用代码编辑器修改
    /// 此方法的内容。
    /// &lt;/summary&gt;
    private void InitializeComponent()
    {
        this.richTextBox1 = new System.Windows.Forms.RichTextBox();
        this.button1 = new System.Windows.Forms.Button();
        this.SuspendLayout();
        // 
        // richTextBox1
        // 
        this.richTextBox1.Location = new System.Drawing.Point(8, 8);
        this.richTextBox1.Name = &quot;richTextBox1&quot;;
        this.richTextBox1.Size = new System.Drawing.Size(248, 160);
        this.richTextBox1.TabIndex = 0;
        this.richTextBox1.Text = &quot;richTextBox1&quot;;
        // 
        // button1
        // 
        this.button1.Location = new System.Drawing.Point(184, 176);
        this.button1.Name = &quot;button1&quot;;
        this.button1.TabIndex = 1;
        this.button1.Text = &quot;Key&quot;;
        this.button1.Click += new System.EventHandler(this.button1_Click);
        // 
        // Form1
        // 
        this.AutoScaleBaseSize = new System.Drawing.Size(6, 14);
        this.ClientSize = new System.Drawing.Size(264, 205);
        this.Controls.AddRange(new System.Windows.Forms.Control\[\] {
                                                                      this.button1,
                                                                      this.richTextBox1});
        this.Name = &quot;Form1&quot;;
        this.Text = &quot;Form1&quot;;
        this.ResumeLayout(false);

    }
    #endregion

    /// &lt;summary&gt;
    /// 应用程序的主入口点。
    /// &lt;/summary&gt;
    \[STAThread\]
    static void Main() 
    {
        Application.Run(new Form1());
    }

    private void button1_Click(object sender, System.EventArgs e)
    {
        this.richTextBox1.Focus();
        SendKeys.Send(&quot;^a&quot;);
        SendKeys.Send(&quot;{DEL}&quot;);
        SendKeys.Send(&quot;+(ec)&quot;);
        SendKeys.Send(&quot;{ENTER}&quot;);
        SendKeys.Send(&quot;+ec&quot;);
        SendKeys.Send(&quot;{ENTER}&quot;);
        SendKeys.Send(&quot;{h 10}&quot;);
        SendKeys.Send(&quot;{ENTER}&quot;);
    }

}</code></pre><p>}</p>
<p><img data-src="https://cdn.fesugar.com/2016/07/2016-07-05-01284473.png" alt="C# 模拟按键操作"></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 模拟鼠标</title>
    <url>/zh-CN/2016/07/04/c-e6-a8-a1-e6-8b-9f-e9-bc-a0-e6-a0-87.html</url>
    <content><![CDATA[<p>模拟鼠标进行操作</p>
<p>using System;<br>using System.Drawing;<br>using System.Collections;<br>using System.ComponentModel;<br>using System.Windows.Forms;<br>using System.Data;</p>
<p>namespace Example107_模拟鼠标<br>{<br>    /// <summary><br>    /// Form1 的摘要说明。<br>    /// </summary><br>    public class Form1 : System.Windows.Forms.Form<br>    {<br>        /// <summary><br>        /// 必需的设计器变量。<br>        /// </summary><br>        private System.ComponentModel.Container components = null;</p>
<pre><code>    public Form1()
    {
        //
        // Windows 窗体设计器支持所必需的
        //
        InitializeComponent();

        //
        // TODO: 在 InitializeComponent 调用后添加任何构造函数代码
        //
    }

    /// &lt;summary&gt;
    /// 清理所有正在使用的资源。
    /// &lt;/summary&gt;
    protected override void Dispose( bool disposing )
    {
        if( disposing )
        {
            if (components != null) 
            {
                components.Dispose();
            }
        }
        base.Dispose( disposing );
    }

    #region Windows Form Designer generated code
    /// &lt;summary&gt;
    /// 设计器支持所需的方法 \- 不要使用代码编辑器修改
    /// 此方法的内容。
    /// &lt;/summary&gt;
    private void InitializeComponent()
    {
        this.button1 = new System.Windows.Forms.Button();
        this.SuspendLayout();
        // 
        // button1
        // 
        this.button1.Location = new System.Drawing.Point(144, 176);
        this.button1.Name = &quot;button1&quot;;
        this.button1.TabIndex = 0;
        this.button1.Text = &quot;Mouse&quot;;
        this.button1.Click += new System.EventHandler(this.button1_Click);
        // 
        // Form1
        // 
        this.AutoScaleBaseSize = new System.Drawing.Size(6, 14);
        this.ClientSize = new System.Drawing.Size(280, 237);
        this.Controls.AddRange(new System.Windows.Forms.Control\[\] {
                                                                      this.button1});
        this.Name = &quot;Form1&quot;;
        this.Text = &quot;Form1&quot;;
        this.DoubleClick += new System.EventHandler(this.Form1_DoubleClick);
        this.ResumeLayout(false);

    }
    #endregion

    /// &lt;summary&gt;
    /// 应用程序的主入口点。
    /// &lt;/summary&gt;
    \[STAThread\]
    static void Main() 
    {
        Application.Run(new Form1());
    }

    private System.Windows.Forms.Button button1;

    \[System.Runtime.InteropServices.DllImport(&quot;user32&quot;)\]
    private static extern int mouse_event(int dwFlags,int dx,int dy, int cButtons, int dwExtraInfo);
    const int MOUSEEVENTF_MOVE = 0x0001;
    const int MOUSEEVENTF_LEFTDOWN = 0x0002;
    const int MOUSEEVENTF_LEFTUP = 0x0004;
    const int MOUSEEVENTF_RIGHTDOWN = 0x0008;
    const int MOUSEEVENTF_RIGHTUP = 0x0010;
    const int MOUSEEVENTF_MIDDLEDOWN = 0x0020;
    const int MOUSEEVENTF_MIDDLEUP = 0x0040;
    const int MOUSEEVENTF_ABSOLUTE = 0x8000;

    private void Form1_DoubleClick(object sender, System.EventArgs e)
    {
        MessageBox.Show(&quot;Double Click&quot;);
    }

    private void button1_Click(object sender, System.EventArgs e)
    {
        mouse\_event(MOUSEEVENTF\_MOVE,-10,-10,0,0);        
        mouse\_event(MOUSEEVENTF\_LEFTDOWN,0,0,0,0);
        mouse\_event(MOUSEEVENTF\_LEFTUP,0,0,0,0);        
        mouse\_event(MOUSEEVENTF\_LEFTDOWN,0,0,0,0);
        mouse\_event(MOUSEEVENTF\_LEFTUP,0,0,0,0);                
    }
}</code></pre><p>}</p>
<p><img data-src="https://cdn.fesugar.com/2016/07/2016-07-04-09002511.png" alt="QQ图片20160704165622"></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 渐变的窗体背景</title>
    <url>/zh-CN/2016/07/04/c-e6-b8-90-e5-8f-98-e7-9a-84-e7-aa-97-e4-bd-93-e8-83-8c-e6-99-af.html</url>
    <content><![CDATA[<p>窗体渐变背景代码实例</p>
<p>using System;<br>using System.Drawing;<br>using System.Collections;<br>using System.ComponentModel;<br>using System.Windows.Forms;<br>using System.Data;<br>using System.Drawing.Drawing2D; </p>
<p>namespace Example010_渐变的窗口背景<br>{<br>    /// <summary><br>    /// Form1 的摘要说明。<br>    /// </summary><br>    public class Form1 : System.Windows.Forms.Form<br>    {<br>        /// <summary><br>        /// 必需的设计器变量。<br>        /// </summary><br>        private System.ComponentModel.Container components = null;</p>
<pre><code>    public Form1()
    {
        //
        // Windows 窗体设计器支持所必需的
        //
        InitializeComponent();

        //
        // TODO: 在 InitializeComponent 调用后添加任何构造函数代码
        //
    }

    /// &lt;summary&gt;
    /// 清理所有正在使用的资源。
    /// &lt;/summary&gt;
    protected override void Dispose( bool disposing )
    {
        if( disposing )
        {
            if (components != null) 
            {
                components.Dispose();
            }
        }
        base.Dispose( disposing );
    }

    #region Windows Form Designer generated code
    /// &lt;summary&gt;
    /// 设计器支持所需的方法 \- 不要使用代码编辑器修改
    /// 此方法的内容。
    /// &lt;/summary&gt;
    private void InitializeComponent()
    {
        // 
        // Form1
        // 
        this.AutoScaleBaseSize = new System.Drawing.Size(6, 14);
        this.ClientSize = new System.Drawing.Size(292, 273);
        this.Name = &quot;Form1&quot;;
        this.Text = &quot;Form1&quot;;
        this.Resize += new System.EventHandler(this.Form1_Resize);
        this.Paint += new System.Windows.Forms.PaintEventHandler(this.Form1_Paint);

    }
    #endregion

    /// &lt;summary&gt;
    /// 应用程序的主入口点。
    /// &lt;/summary&gt;
    \[STAThread\]
    static void Main() 
    {
        Application.Run(new Form1());
    }

    private void Form1_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
    {
        Graphics g=e.Graphics;
        Color FColor=Color.Blue;
        Color TColor=Color.Yellow;
        Brush b =new LinearGradientBrush(this.ClientRectangle, FColor, TColor, LinearGradientMode.ForwardDiagonal);
        g.FillRectangle(b,this.ClientRectangle);
    }

    private void Form1_Resize(object sender, System.EventArgs e)
    {
        this.Invalidate();
    }
}</code></pre><p>}</p>
<p><img data-src="https://cdn.fesugar.com/2016/07/2016-07-04-07420661.png" alt="QQ图片20160704154023"></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 自定义鼠标光标</title>
    <url>/zh-CN/2016/07/06/c-e8-87-aa-e5-ae-9a-e4-b9-89-e9-bc-a0-e6-a0-87-e5-85-89-e6-a0-87.html</url>
    <content><![CDATA[<p>自定义鼠标光标的方法</p>
<p>using System;<br>using System.Drawing;<br>using System.Collections;<br>using System.ComponentModel;<br>using System.Windows.Forms;<br>using System.Data;<br>using System.Runtime.InteropServices;</p>
<p>namespace Example027_显示动画光标<br>{<br>    /// <summary><br>    /// Form1 的摘要说明。<br>    /// </summary><br>    public class Form1 : System.Windows.Forms.Form<br>    {<br>        /// <summary><br>        /// 必需的设计器变量。<br>        /// </summary><br>        private System.ComponentModel.Container components = null;</p>
<pre><code>    public Form1()
    {
        //
        // Windows 窗体设计器支持所必需的
        //
        InitializeComponent();

        //
        // TODO: 在 InitializeComponent 调用后添加任何构造函数代码
        //
    }

    /// &lt;summary&gt;
    /// 清理所有正在使用的资源。
    /// &lt;/summary&gt;
    protected override void Dispose( bool disposing )
    {
        if( disposing )
        {
            if (components != null) 
            {
                components.Dispose();
            }
        }
        base.Dispose( disposing );
    }

    #region Windows Form Designer generated code
    /// &lt;summary&gt;
    /// 设计器支持所需的方法 \- 不要使用代码编辑器修改
    /// 此方法的内容。
    /// &lt;/summary&gt;
    private void InitializeComponent()
    {
        // 
        // Form1
        // 
        this.AutoScaleBaseSize = new System.Drawing.Size(6, 14);
        this.ClientSize = new System.Drawing.Size(292, 273);
        this.Name = &quot;Form1&quot;;
        this.Text = &quot;Form1&quot;;
        this.Load += new System.EventHandler(this.Form1_Load);

    }
    #endregion

    /// &lt;summary&gt;
    /// 应用程序的主入口点。
    /// &lt;/summary&gt;
    \[STAThread\]
    static void Main() 
    {
        Application.Run(new Form1());
    }
    \[DllImport(&quot;user32&quot;)\]
    private static extern IntPtr SetCursor(IntPtr hCursor);
    \[DllImport(&quot;user32&quot;)\]
    private static extern IntPtr LoadCursorFromFile(string lpFileName);
    const int WM_SETCURSOR = 0x0020;

    private void Form1_Load(object sender, System.EventArgs e)
    {
        IntPtr hCursor;
        hCursor=LoadCursorFromFile(&quot;..\\..\\pic.ani&quot;);
        SetCursor(hCursor);    
    }

    protected override void WndProc(ref System.Windows.Forms.Message m)
    {
        switch(m.Msg)
        {
            case WM_SETCURSOR:
                IntPtr hCursor;
                hCursor=LoadCursorFromFile(&quot;..\\..\\pic.ani&quot;);
                SetCursor(hCursor);    
                break;
            default:
                base.WndProc(ref m);
                break;
        }
    }
}</code></pre><p>}</p>
<p><img data-src="https://cdn.fesugar.com/2016/07/2016-07-06-01103899.png" alt="QQ图片20160706085555"></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 窗口渐显</title>
    <url>/zh-CN/2016/07/04/c-e7-aa-97-e5-8f-a3-e6-b8-90-e6-98-be.html</url>
    <content><![CDATA[<p>窗口渐显实现的效果</p>
<p>using System;<br>using System.Drawing;<br>using System.Collections;<br>using System.ComponentModel;<br>using System.Windows.Forms;<br>using System.Data;</p>
<p>namespace Example002<br>{<br>    /// <summary><br>    /// Form1 的摘要说明。<br>    /// </summary><br>    public class Form1 : System.Windows.Forms.Form<br>    {<br>        private System.Windows.Forms.Timer timer1;<br>        private System.ComponentModel.IContainer components;</p>
<pre><code>    public Form1()
    {
        //
        // Windows 窗体设计器支持所必需的
        //
        InitializeComponent();
        //
        // TODO: 在 InitializeComponent 调用后添加任何构造函数代码
        //
    }

    /// &lt;summary&gt;
    /// 清理所有正在使用的资源。
    /// &lt;/summary&gt;
    protected override void Dispose( bool disposing )
    {
        if( disposing )
        {
            if (components != null) 
            {
                components.Dispose();
            }
        }
        base.Dispose( disposing );
    }

    #region Windows Form Designer generated code
    /// &lt;summary&gt;
    /// 设计器支持所需的方法 \- 不要使用代码编辑器修改
    /// 此方法的内容。
    /// &lt;/summary&gt;
    private void InitializeComponent()
    {
        this.components = new System.ComponentModel.Container();
        this.timer1 = new System.Windows.Forms.Timer(this.components);
        // 
        // timer1
        // 
        this.timer1.Tick += new System.EventHandler(this.timer1_Tick);
        // 
        // Form1
        // 
        this.AutoScaleBaseSize = new System.Drawing.Size(6, 14);
        this.ClientSize = new System.Drawing.Size(256, 141);
        this.Name = &quot;Form1&quot;;
        this.Opacity = 0.5;
        this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
        this.Text = &quot;Form1&quot;;
        this.Load += new System.EventHandler(this.Form1_Load);

    }
    #endregion

    /// &lt;summary&gt;
    /// 应用程序的主入口点。
    /// &lt;/summary&gt;
    \[STAThread\]
    static void Main() 
    {
        Application.Run(new Form1());
    }

    private void Form1_Load(object sender, System.EventArgs e)
    {
        this.timer1.Enabled=true;
        this.Opacity=0;
    }

    private void timer1_Tick(object sender, System.EventArgs e)
    {
        if(this.Opacity&lt;1)
        {
            this.Opacity=this.Opacity+0.05;
        }
        else
        {
            this.timer1.Enabled=false;
        }
    }
}</code></pre><p>}</p>
<p><img data-src="https://cdn.fesugar.com/2016/07/2016-07-04-0736229.png" alt="QQ图片20160704153514"></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 获取光标闪烁频率</title>
    <url>/zh-CN/2018/01/25/c-e8-8e-b7-e5-8f-96-e5-85-89-e6-a0-87-e9-97-aa-e7-83-81-e9-a2-91-e7-8e-87.html</url>
    <content><![CDATA[<p>引入DLL函数</p>
<pre><code>\[DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;GetCaretBlinkTime&quot;)\]

public extern static int GetDoubleClickTime();</code></pre><p>完整代码，创建一个窗体拖入一个文本框控件</p>
<pre><code>\[DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;GetCaretBlinkTime&quot;)\]

public extern static int GetCaretBlinkTime();

public Form1()
{
    InitializeComponent();
}



private void Form1_Load(object sender, EventArgs e)
{
    textBox1.Text = Convert.ToString(GetDoubleClickTime());
}</code></pre><p><img data-src="https://cdn.fesugar.com/2018/01/2018-01-25-04364497.png" alt=""></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 获取鼠标双击间隔时间</title>
    <url>/zh-CN/2018/01/25/c-e8-8e-b7-e5-8f-96-e9-bc-a0-e6-a0-87-e5-8f-8c-e5-87-bb-e9-97-b4-e9-9a-94-e6-97-b6-e9-97-b4.html</url>
    <content><![CDATA[<p>引入DLL函数</p>
<pre><code>\[DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;GetDoubleClickTime&quot;)\]

public extern static int GetDoubleClickTime();</code></pre><p>完整代码，创建一个窗体拖入一个文本框控件</p>
<pre><code>\[DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;GetDoubleClickTime&quot;)\]

public extern static int GetDoubleClickTime();

public Form1()
{
    InitializeComponent();
}



private void Form1_Load(object sender, EventArgs e)
{
    textBox1.Text = Convert.ToString(GetDoubleClickTime());
}</code></pre><p><img data-src="https://cdn.fesugar.com/2018/01/2018-01-25-04364497.png" alt=""></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 获取鼠标按键数量</title>
    <url>/zh-CN/2018/01/25/c-e8-8e-b7-e5-8f-96-e9-bc-a0-e6-a0-87-e6-8c-89-e9-94-ae-e6-95-b0-e9-87-8f.html</url>
    <content><![CDATA[<p>引入DLL函数</p>
<pre><code>\[DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;GetSystemMetrics&quot;)\]

public extern static int GetSystemMetrics(int intcount);</code></pre><p>完整代码，创建一个窗体拖入一个文本框控件</p>
<pre><code>public const int SM_CMOUSEBUTTONS = 43;//定义一个常量值

\[DllImport(&quot;user32.dll&quot;, EntryPoint = &quot;GetSystemMetrics&quot;)\]

public extern static int GetSystemMetrics(int intcount);

public Form1()
{
    InitializeComponent();
}



private void Form1_Load(object sender, EventArgs e)
{
    int jishu = GetSystemMetrics(SM_CMOUSEBUTTONS); //获取鼠标按键数
    textBox1.Text = Convert.ToString(jishu);
}</code></pre>]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 让其程序只能单实例运行</title>
    <url>/zh-CN/2016/07/05/c-e8-ae-a9-e5-85-b6-e7-a8-8b-e5-ba-8f-e5-8f-aa-e8-83-bd-e5-8d-95-e5-ae-9e-e4-be-8b-e8-bf-90-e8-a1-8c.html</url>
    <content><![CDATA[<p>使用 CreateMutex 互斥解决单实例运行</p>
<p>using System;<br>using System.Drawing;<br>using System.Collections;<br>using System.ComponentModel;<br>using System.Windows.Forms;<br>using System.Data;<br>using System.Threading;<br>using System.Runtime.InteropServices;</p>
<p>namespace Example104_使程序只能够运行一个<br>{<br>    /// <summary><br>    /// Form1 的摘要说明。<br>    /// </summary><br>    public class Form1 : System.Windows.Forms.Form<br>    {<br>        /// <summary><br>        /// 必需的设计器变量。<br>        /// </summary><br>        private System.ComponentModel.Container components = null;</p>
<pre><code>    public Form1()
    {
        //
        // Windows 窗体设计器支持所必需的
        //
        InitializeComponent();

        //
        // TODO: 在 InitializeComponent 调用后添加任何构造函数代码
        //
    }

    /// &lt;summary&gt;
    /// 清理所有正在使用的资源。
    /// &lt;/summary&gt;
    protected override void Dispose( bool disposing )
    {
        if( disposing )
        {
            if (components != null) 
            {
                components.Dispose();
            }
        }
        base.Dispose( disposing );
    }

    #region Windows Form Designer generated code
    /// &lt;summary&gt;
    /// 设计器支持所需的方法 \- 不要使用代码编辑器修改
    /// 此方法的内容。
    /// &lt;/summary&gt;
    private void InitializeComponent()
    {
        // 
        // Form1
        // 
        this.AutoScaleBaseSize = new System.Drawing.Size(6, 14);
        this.ClientSize = new System.Drawing.Size(272, 189);
        this.Name = &quot;Form1&quot;;
        this.Text = &quot;Form1&quot;;

    }
    #endregion

    /// &lt;summary&gt;
    /// 应用程序的主入口点。
    /// &lt;/summary&gt;

    \[StructLayout( LayoutKind.Sequential)\]
    public class SECURITY_ATTRIBUTES 
    {
        public int nLength; 
        public int lpSecurityDescriptor; 
        public int bInheritHandle; 
    }

    \[System.Runtime.InteropServices.DllImport(&quot;kernel32&quot;)\]
    private static extern int GetLastError();
    \[System.Runtime.InteropServices.DllImport(&quot;kernel32&quot;)\]
    private static extern IntPtr CreateMutex(SECURITY_ATTRIBUTES lpMutexAttributes,bool bInitialOwner,string lpName);
    \[System.Runtime.InteropServices.DllImport(&quot;kernel32&quot;)\]
    private static extern int ReleaseMutex(IntPtr hMutex);
    const int ERROR\_ALREADY\_EXISTS = 0183;

    \[STAThread\]
    static void Main() 
    {
        IntPtr hMutex;
        hMutex=CreateMutex(null,false,&quot;test&quot;);
        if (GetLastError()!=ERROR\_ALREADY\_EXISTS)
        {
            Application.Run(new Form1());
        }
        else
        {
            MessageBox.Show(&quot;本程序只允许同时运行一个&quot;);
            ReleaseMutex(hMutex);
        }
    }
}</code></pre><p>}</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 设置计算机名称</title>
    <url>/zh-CN/2018/09/06/c-e8-ae-be-e7-bd-ae-e8-ae-a1-e7-ae-97-e6-9c-ba-e5-90-8d-e7-a7-b0.html</url>
    <content><![CDATA[<p>设置修改当前计算机名称  </p>
<p>using System;<br>using System.Collections.Generic;<br>using System.ComponentModel;<br>using System.Windows.Forms;<br>using Microsoft.VisualBasic.Devices;<br>using System.Runtime.InteropServices;</p>
<p>namespace ModifyComputerName<br>{<br>    public partial class Frm_Main : Form<br>    {<br>        public Frm_Main()<br>        {<br>            InitializeComponent();<br>        }</p>
<pre><code>    \[DllImport(&quot;kernel32.dll&quot;)\]
    private static extern int SetComputerName(string ipComputerName);//重写API函数

    private void Frm\_Main\_Load(object sender, EventArgs e)
    {
        Computer computer = new Computer();//创建计算机对象
        textBox1.Text = computer.Name;//显示计算机名称

        SetComputerName(textBox2.Text);//修改计算机名称
    }
}</code></pre><p>}</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 读写ini配置文件</title>
    <url>/zh-CN/2016/07/05/c-e8-af-bb-e5-86-99ini-e9-85-8d-e7-bd-ae-e6-96-87-e4-bb-b6.html</url>
    <content><![CDATA[<p>读写ini文件的方法</p>
<p>using System;<br>using System.Drawing;<br>using System.Collections;<br>using System.ComponentModel;<br>using System.Windows.Forms;<br>using System.Data;<br>using System.Runtime.InteropServices;<br>using System.IO;<br>using System.Text;</p>
<p>namespace Example084_读写ini文件<br>{<br>    /// <summary><br>    /// Form1 的摘要说明。<br>    /// </summary><br>    public class Form1 : System.Windows.Forms.Form<br>    {<br>        /// <summary><br>        /// 必需的设计器变量。<br>        /// </summary><br>        private System.ComponentModel.Container components = null;</p>
<pre><code>    public Form1()
    {
        //
        // Windows 窗体设计器支持所必需的
        //
        InitializeComponent();

        //
        // TODO: 在 InitializeComponent 调用后添加任何构造函数代码
        //
    }

    /// &lt;summary&gt;
    /// 清理所有正在使用的资源。
    /// &lt;/summary&gt;
    protected override void Dispose( bool disposing )
    {
        if( disposing )
        {
            if (components != null) 
            {
                components.Dispose();
            }
        }
        base.Dispose( disposing );
    }

    #region Windows Form Designer generated code
    /// &lt;summary&gt;
    /// 设计器支持所需的方法 \- 不要使用代码编辑器修改
    /// 此方法的内容。
    /// &lt;/summary&gt;
    private void InitializeComponent()
    {
        // 
        // Form1
        // 
        this.AutoScaleBaseSize = new System.Drawing.Size(6, 14);
        this.ClientSize = new System.Drawing.Size(292, 273);
        this.Name = &quot;Form1&quot;;
        this.Text = &quot;Form1&quot;;
        this.Closing += new System.ComponentModel.CancelEventHandler(this.Form1_Closing);
        this.Load += new System.EventHandler(this.Form1_Load);

    }
    #endregion

    /// &lt;summary&gt;
    /// 应用程序的主入口点。
    /// &lt;/summary&gt;
    \[STAThread\]
    static void Main() 
    {
        Application.Run(new Form1());
    }

    \[DllImport(&quot;kernel32&quot;)\]
    private static extern int GetPrivateProfileInt(string lpApplicationName,string lpKeyName,int nDefault,string lpFileName);
    \[DllImport(&quot;kernel32&quot;)\]
    private static extern bool GetPrivateProfileString(string lpApplicationName,string lpKeyName,string lpDefault,StringBuilder lpReturnedString,int nSize,string lpFileName);
    \[DllImport(&quot;kernel32&quot;)\]
    private static extern bool WritePrivateProfileString(string lpApplicationName,string lpKeyName,string lpString,string lpFileName);
    \[DllImport(&quot;kernel32&quot;)\]
    private static extern bool GetPrivateProfileSection(string lpAppName,string lpReturnedString,int nSize,string lpFileName);
    \[DllImport(&quot;kernel32&quot;)\]
    private static extern bool WritePrivateProfileSection(string lpAppName,string lpString,string lpFileName);

    public const int MAX_PATH = 256;
    public const string FILE_NAME=&quot;.\\test.ini&quot;;

    private void Form1_Load(object sender, System.EventArgs e)
    {
        if (File.Exists(FILE_NAME))
        {
            StringBuilder strCaption=new StringBuilder(256);
            GetPrivateProfileString(&quot;Form&quot;,&quot;Caption&quot;,&quot;Default Caption&quot;,strCaption,strCaption.Capacity,FILE_NAME);
            this.Text=strCaption.ToString();
            int myWidth=GetPrivateProfileInt(&quot;Form&quot;,&quot;Width&quot;,this.Width,FILE_NAME);
            this.Width=myWidth;
            int myHeight=GetPrivateProfileInt(&quot;Form&quot;,&quot;Height&quot;,this.Height,FILE_NAME);
            this.Height=myHeight;
            int myLeft=GetPrivateProfileInt(&quot;Form&quot;,&quot;Left&quot;,this.Left,FILE_NAME);
            this.Left=myLeft;
            int myTop=GetPrivateProfileInt(&quot;Form&quot;,&quot;Top&quot;,this.Top,FILE_NAME);
            this.Top=myTop;
        }
    }

    private void Form1_Closing(object sender, System.ComponentModel.CancelEventArgs e)
    {
        string strCaption=this.Text;
        WritePrivateProfileString(&quot;Form&quot;,&quot;Caption&quot;,strCaption,FILE_NAME);
        WritePrivateProfileString(&quot;Form&quot;,&quot;Width&quot;,this.Width.ToString(),FILE_NAME);
        WritePrivateProfileString(&quot;Form&quot;,&quot;Height&quot;,this.Height.ToString(),FILE_NAME);
        WritePrivateProfileString(&quot;Form&quot;,&quot;Left&quot;,this.Left.ToString(),FILE_NAME);
        WritePrivateProfileString(&quot;Form&quot;,&quot;Top&quot;,this.Top.ToString(),FILE_NAME);
    }
}</code></pre><p>}</p>
<p><img data-src="https://cdn.fesugar.com/2016/07/2016-07-05-00130184.png" alt="C# 读写ini"></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C#通用数据库操作类</title>
    <url>/zh-CN/2016/10/18/c-e9-80-9a-e7-94-a8-e6-95-b0-e6-8d-ae-e5-ba-93-e6-93-8d-e4-bd-9c-e7-b1-bb.html</url>
    <content><![CDATA[<p>各种搜集数据库操作完整类，在一篇博文留言中发现了一个开源的 Dbhelper 试了下，用起来很爽。。。 博文地址 <a href="http://www.cnblogs.com/podolski/p/5152537.html" target="_blank" rel="noopener">波多尔斯基</a> <img data-src="https://cdn.fesugar.com/2016/10/2016-10-18-10232965.png" alt="8720161018181711"> DbHelper 开源地址 <a href="https://devlib.codeplex.com/SourceControl/latest#Main/Source/DevLib.Data/DbHelper.cs" target="_blank" rel="noopener">DevLib</a> <img data-src="https://cdn.fesugar.com/2016/10/2016-10-18-10241644.png" alt="8720161018182238"></p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# MySqlHelper 类</title>
    <url>/zh-CN/2016/10/18/c-mysqlhelper-e7-b1-bb.html</url>
    <content><![CDATA[<p>using System;<br>using System.Data;<br>using System.IO;<br>using System.Linq;<br>using System.Text;<br>using MySql.Data.MySqlClient;</p>
<p>namespace Helpers<br>{<br>    /// <summary><br>    /// MySqlHelper操作类<br>    /// </summary><br>    public sealed partial class MySqlHelper<br>    {<br>        /// <summary><br>        /// 批量操作每批次记录数<br>        /// </summary><br>        public static int BatchSize = 2000;</p>
<pre><code>    /// &lt;summary&gt;
    /// 超时时间
    /// &lt;/summary&gt;
    public static int CommandTimeOut = 600;

    /// &lt;summary&gt;
    ///初始化MySqlHelper实例
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    public MySqlHelper(string connectionString)
    {
        this.ConnectionString = connectionString;
    }

    /// &lt;summary&gt;
    /// 数据库连接字符串
    /// &lt;/summary&gt;
    public string ConnectionString { get; set; }

    #region 实例方法

    #region ExecuteNonQuery

    /// &lt;summary&gt;
    /// 执行SQL语句,返回影响的行数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回影响的行数&lt;/returns&gt;
    public int ExecuteNonQuery(string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteNonQuery(ConnectionString, CommandType.Text, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回影响的行数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回影响的行数&lt;/returns&gt;
    public int ExecuteNonQuery(CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteNonQuery(ConnectionString, commandType, commandText, parms);
    }

    #endregion ExecuteNonQuery

    #region ExecuteScalar

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行第一列
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;T&quot;&gt;返回对象类型&lt;/typeparam&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一行第一列&lt;/returns&gt;
    public T ExecuteScalar&lt;T&gt;(string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteScalar&lt;T&gt;(ConnectionString, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行第一列
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一行第一列&lt;/returns&gt;
    public object ExecuteScalar(string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteScalar(ConnectionString, CommandType.Text, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行第一列
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一行第一列&lt;/returns&gt;
    public object ExecuteScalar(CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteScalar(ConnectionString, commandType, commandText, parms);
    }

    #endregion ExecuteScalar

    #region ExecuteDataReader

    /// &lt;summary&gt;
    /// 执行SQL语句,返回只读数据集
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回只读数据集&lt;/returns&gt;
    private MySqlDataReader ExecuteDataReader(string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataReader(ConnectionString, CommandType.Text, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回只读数据集
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回只读数据集&lt;/returns&gt;
    private MySqlDataReader ExecuteDataReader(CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataReader(ConnectionString, commandType, commandText, parms);
    }
    #endregion

    #region ExecuteDataRow

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一行&lt;/returns&gt;
    public DataRow ExecuteDataRow(string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataRow(ConnectionString, CommandType.Text, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一行&lt;/returns&gt;
    public DataRow ExecuteDataRow(CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataRow(ConnectionString, commandType, commandText, parms);
    }

    #endregion ExecuteDataRow

    #region ExecuteDataTable

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一个数据表
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一个数据表&lt;/returns&gt;
    public DataTable ExecuteDataTable(string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataTable(ConnectionString, CommandType.Text, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一个数据表
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一个数据表&lt;/returns&gt;
    public DataTable ExecuteDataTable(CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataSet(ConnectionString, commandType, commandText, parms).Tables\[0\];
    }

    #endregion ExecuteDataTable

    #region ExecuteDataSet

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集&lt;/returns&gt;
    public DataSet ExecuteDataSet(string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataSet(ConnectionString, CommandType.Text, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集&lt;/returns&gt;
    public DataSet ExecuteDataSet(CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataSet(ConnectionString, commandType, commandText, parms);
    }

    #endregion ExecuteDataSet

    #region 批量操作

    /// &lt;summary&gt;
    /// 使用MySqlDataAdapter批量更新数据
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;table&quot;&gt;数据表&lt;/param&gt;
    public void BatchUpdate(DataTable table)
    {
        BatchUpdate(ConnectionString, table);
    }

    /// &lt;summary&gt;
    ///大批量数据插入,返回成功插入行数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;table&quot;&gt;数据表&lt;/param&gt;
    /// &lt;returns&gt;返回成功插入行数&lt;/returns&gt;
    public int BulkInsert(DataTable table)
    {
        return BulkInsert(ConnectionString, table);
    }

    #endregion 批量操作

    #endregion 实例方法

    #region 静态方法

    private static void PrepareCommand(MySqlCommand command, MySqlConnection connection, MySqlTransaction transaction, CommandType commandType, string commandText, MySqlParameter\[\] parms)
    {
        if (connection.State != ConnectionState.Open) connection.Open();

        command.Connection = connection;
        command.CommandTimeout = CommandTimeOut;
        // 设置命令文本(存储过程名或SQL语句)
        command.CommandText = commandText;
        // 分配事务
        if (transaction != null)
        {
            command.Transaction = transaction;
        }
        // 设置命令类型.
        command.CommandType = commandType;
        if (parms != null &amp;&amp; parms.Length &gt; 0)
        {
            //预处理MySqlParameter参数数组，将为NULL的参数赋值为DBNull.Value;
            foreach (MySqlParameter parameter in parms)
            {
                if ((parameter.Direction == ParameterDirection.InputOutput || parameter.Direction == ParameterDirection.Input) &amp;&amp; (parameter.Value == null))
                {
                    parameter.Value = DBNull.Value;
                }
            }
            command.Parameters.AddRange(parms);
        }
    }

    #region ExecuteNonQuery

    /// &lt;summary&gt;
    /// 执行SQL语句,返回影响的行数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回影响的行数&lt;/returns&gt;
    public static int ExecuteNonQuery(string connectionString, string commandText, params MySqlParameter\[\] parms)
    {
        using (MySqlConnection connection = new MySqlConnection(connectionString))
        {
            return ExecuteNonQuery(connection, CommandType.Text, commandText, parms);
        }
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回影响的行数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回影响的行数&lt;/returns&gt;
    public static int ExecuteNonQuery(string connectionString, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        using (MySqlConnection connection = new MySqlConnection(connectionString))
        {
            return ExecuteNonQuery(connection, commandType, commandText, parms);
        }
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回影响的行数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connection&quot;&gt;数据库连接&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回影响的行数&lt;/returns&gt;
    public static int ExecuteNonQuery(MySqlConnection connection, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteNonQuery(connection, null, commandType, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回影响的行数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;transaction&quot;&gt;事务&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回影响的行数&lt;/returns&gt;
    public static int ExecuteNonQuery(MySqlTransaction transaction, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteNonQuery(transaction.Connection, transaction, commandType, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回影响的行数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connection&quot;&gt;数据库连接&lt;/param&gt;
    /// &lt;param name=&quot;transaction&quot;&gt;事务&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回影响的行数&lt;/returns&gt;
    private static int ExecuteNonQuery(MySqlConnection connection, MySqlTransaction transaction, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        MySqlCommand command = new MySqlCommand();
        PrepareCommand(command, connection, transaction, commandType, commandText, parms);
        int retval = command.ExecuteNonQuery();
        command.Parameters.Clear();
        return retval;
    }

    #endregion ExecuteNonQuery

    #region ExecuteScalar

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行第一列
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;T&quot;&gt;返回对象类型&lt;/typeparam&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一行第一列&lt;/returns&gt;
    public static T ExecuteScalar&lt;T&gt;(string connectionString, string commandText, params MySqlParameter\[\] parms)
    {
        object result = ExecuteScalar(connectionString, commandText, parms);
        if (result != null)
        {
            return (T)Convert.ChangeType(result, typeof(T)); ;
        }
        return default(T);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行第一列
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一行第一列&lt;/returns&gt;
    public static object ExecuteScalar(string connectionString, string commandText, params MySqlParameter\[\] parms)
    {
        using (MySqlConnection connection = new MySqlConnection(connectionString))
        {
            return ExecuteScalar(connection, CommandType.Text, commandText, parms);
        }
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行第一列
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一行第一列&lt;/returns&gt;
    public static object ExecuteScalar(string connectionString, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        using (MySqlConnection connection = new MySqlConnection(connectionString))
        {
            return ExecuteScalar(connection, commandType, commandText, parms);
        }
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行第一列
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connection&quot;&gt;数据库连接&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一行第一列&lt;/returns&gt;
    public static object ExecuteScalar(MySqlConnection connection, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteScalar(connection, null, commandType, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行第一列
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;transaction&quot;&gt;事务&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一行第一列&lt;/returns&gt;
    public static object ExecuteScalar(MySqlTransaction transaction, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteScalar(transaction.Connection, transaction, commandType, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行第一列
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connection&quot;&gt;数据库连接&lt;/param&gt;
    /// &lt;param name=&quot;transaction&quot;&gt;事务&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一行第一列&lt;/returns&gt;
    private static object ExecuteScalar(MySqlConnection connection, MySqlTransaction transaction, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        MySqlCommand command = new MySqlCommand();
        PrepareCommand(command, connection, transaction, commandType, commandText, parms);
        object retval = command.ExecuteScalar();
        command.Parameters.Clear();
        return retval;
    }

    #endregion ExecuteScalar

    #region ExecuteDataReader

    /// &lt;summary&gt;
    /// 执行SQL语句,返回只读数据集
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connection&quot;&gt;数据库连接&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回只读数据集&lt;/returns&gt;
    private static MySqlDataReader ExecuteDataReader(string connectionString, string commandText, params MySqlParameter\[\] parms)
    {
        MySqlConnection connection = new MySqlConnection(connectionString);
        return ExecuteDataReader(connection, null, CommandType.Text, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回只读数据集
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connection&quot;&gt;数据库连接&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回只读数据集&lt;/returns&gt;
    private static MySqlDataReader ExecuteDataReader(string connectionString, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        MySqlConnection connection = new MySqlConnection(connectionString);
        return ExecuteDataReader(connection, null, commandType, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回只读数据集
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connection&quot;&gt;数据库连接&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回只读数据集&lt;/returns&gt;
    private static MySqlDataReader ExecuteDataReader(MySqlConnection connection, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataReader(connection, null, commandType, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回只读数据集
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;transaction&quot;&gt;事务&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回只读数据集&lt;/returns&gt;
    private static MySqlDataReader ExecuteDataReader(MySqlTransaction transaction, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataReader(transaction.Connection, transaction, commandType, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回只读数据集
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connection&quot;&gt;数据库连接&lt;/param&gt;
    /// &lt;param name=&quot;transaction&quot;&gt;事务&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回只读数据集&lt;/returns&gt;
    private static MySqlDataReader ExecuteDataReader(MySqlConnection connection, MySqlTransaction transaction, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        MySqlCommand command = new MySqlCommand();
        PrepareCommand(command, connection, transaction, commandType, commandText, parms);
        return command.ExecuteReader(CommandBehavior.CloseConnection);
    }

    #endregion

    #region ExecuteDataRow

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;,返回结果集中的第一行&lt;/returns&gt;
    public static DataRow ExecuteDataRow(string connectionString, string commandText, params MySqlParameter\[\] parms)
    {
        DataTable dt = ExecuteDataTable(connectionString, CommandType.Text, commandText, parms);
        return dt.Rows.Count &gt; 0 ? dt.Rows\[0\] : null;
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;,返回结果集中的第一行&lt;/returns&gt;
    public static DataRow ExecuteDataRow(string connectionString, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        DataTable dt = ExecuteDataTable(connectionString, commandType, commandText, parms);
        return dt.Rows.Count &gt; 0 ? dt.Rows\[0\] : null;
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connection&quot;&gt;数据库连接&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;,返回结果集中的第一行&lt;/returns&gt;
    public static DataRow ExecuteDataRow(MySqlConnection connection, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        DataTable dt = ExecuteDataTable(connection, commandType, commandText, parms);
        return dt.Rows.Count &gt; 0 ? dt.Rows\[0\] : null;
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一行
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;transaction&quot;&gt;事务&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;,返回结果集中的第一行&lt;/returns&gt;
    public static DataRow ExecuteDataRow(MySqlTransaction transaction, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        DataTable dt = ExecuteDataTable(transaction, commandType, commandText, parms);
        return dt.Rows.Count &gt; 0 ? dt.Rows\[0\] : null;
    }

    #endregion ExecuteDataRow

    #region ExecuteDataTable

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一个数据表
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一个数据表&lt;/returns&gt;
    public static DataTable ExecuteDataTable(string connectionString, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataSet(connectionString, CommandType.Text, commandText, parms).Tables\[0\];
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一个数据表
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一个数据表&lt;/returns&gt;
    public static DataTable ExecuteDataTable(string connectionString, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataSet(connectionString, commandType, commandText, parms).Tables\[0\];
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一个数据表
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connection&quot;&gt;数据库连接&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一个数据表&lt;/returns&gt;
    public static DataTable ExecuteDataTable(MySqlConnection connection, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataSet(connection, commandType, commandText, parms).Tables\[0\];
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一个数据表
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;transaction&quot;&gt;事务&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一个数据表&lt;/returns&gt;
    public static DataTable ExecuteDataTable(MySqlTransaction transaction, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataSet(transaction, commandType, commandText, parms).Tables\[0\];
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集中的第一个数据表
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;param name=&quot;tableName&quot;&gt;数据表名称&lt;/param&gt;
    /// &lt;returns&gt;返回结果集中的第一个数据表&lt;/returns&gt;
    public static DataTable ExecuteEmptyDataTable(string connectionString, string tableName)
    {
        return ExecuteDataSet(connectionString, CommandType.Text, string.Format(&quot;select * from {0} where 1=-1&quot;, tableName)).Tables\[0\];
    }

    #endregion ExecuteDataTable

    #region ExecuteDataSet

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集&lt;/returns&gt;
    public static DataSet ExecuteDataSet(string connectionString, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataSet(connectionString, CommandType.Text, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集&lt;/returns&gt;
    public static DataSet ExecuteDataSet(string connectionString, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        using (MySqlConnection connection = new MySqlConnection(connectionString))
        {
            return ExecuteDataSet(connection, commandType, commandText, parms);
        }
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connection&quot;&gt;数据库连接&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集&lt;/returns&gt;
    public static DataSet ExecuteDataSet(MySqlConnection connection, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataSet(connection, null, commandType, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;transaction&quot;&gt;事务&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集&lt;/returns&gt;
    public static DataSet ExecuteDataSet(MySqlTransaction transaction, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        return ExecuteDataSet(transaction.Connection, transaction, commandType, commandText, parms);
    }

    /// &lt;summary&gt;
    /// 执行SQL语句,返回结果集
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connection&quot;&gt;数据库连接&lt;/param&gt;
    /// &lt;param name=&quot;transaction&quot;&gt;事务&lt;/param&gt;
    /// &lt;param name=&quot;commandType&quot;&gt;命令类型(存储过程,命令文本, 其它.)&lt;/param&gt;
    /// &lt;param name=&quot;commandText&quot;&gt;SQL语句或存储过程名称&lt;/param&gt;
    /// &lt;param name=&quot;parms&quot;&gt;查询参数&lt;/param&gt;
    /// &lt;returns&gt;返回结果集&lt;/returns&gt;
    private static DataSet ExecuteDataSet(MySqlConnection connection, MySqlTransaction transaction, CommandType commandType, string commandText, params MySqlParameter\[\] parms)
    {
        MySqlCommand command = new MySqlCommand();

        PrepareCommand(command, connection, transaction, commandType, commandText, parms);
        MySqlDataAdapter adapter = new MySqlDataAdapter(command);

        DataSet ds = new DataSet();
        adapter.Fill(ds);
        if (commandText.IndexOf(&quot;@&quot;) &gt; 0)
        {
            commandText = commandText.ToLower();
            int index = commandText.IndexOf(&quot;where &quot;);
            if (index &lt; 0)
            {
                index = commandText.IndexOf(&quot;\\nwhere&quot;);
            }
            if (index &gt; 0)
            {
                ds.ExtendedProperties.Add(&quot;SQL&quot;, commandText.Substring(0, index - 1));  //将获取的语句保存在表的一个附属数组里，方便更新时生成CommandBuilder
            }
            else
            {
                ds.ExtendedProperties.Add(&quot;SQL&quot;, commandText);  //将获取的语句保存在表的一个附属数组里，方便更新时生成CommandBuilder
            }
        }
        else
        {
            ds.ExtendedProperties.Add(&quot;SQL&quot;, commandText);  //将获取的语句保存在表的一个附属数组里，方便更新时生成CommandBuilder
        }

        foreach (DataTable dt in ds.Tables)
        {
            dt.ExtendedProperties.Add(&quot;SQL&quot;, ds.ExtendedProperties\[&quot;SQL&quot;\]);
        }

        command.Parameters.Clear();
        return ds;
    }

    #endregion ExecuteDataSet

    #region 批量操作

    /// &lt;summary&gt;
    ///使用MySqlDataAdapter批量更新数据
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;param name=&quot;table&quot;&gt;数据表&lt;/param&gt;
    public static void BatchUpdate(string connectionString, DataTable table)
    {
        MySqlConnection connection = new MySqlConnection(connectionString);

        MySqlCommand command = connection.CreateCommand();
        command.CommandTimeout = CommandTimeOut;
        command.CommandType = CommandType.Text;
        MySqlDataAdapter adapter = new MySqlDataAdapter(command);
        MySqlCommandBuilder commandBulider = new MySqlCommandBuilder(adapter);
        commandBulider.ConflictOption = ConflictOption.OverwriteChanges;

        MySqlTransaction transaction = null;
        try
        {
            connection.Open();
            transaction = connection.BeginTransaction();
            //设置批量更新的每次处理条数
            adapter.UpdateBatchSize = BatchSize;
            //设置事物
            adapter.SelectCommand.Transaction = transaction;

            if (table.ExtendedProperties\[&quot;SQL&quot;\] != null)
            {
                adapter.SelectCommand.CommandText = table.ExtendedProperties\[&quot;SQL&quot;\].ToString();
            }
            adapter.Update(table);
            transaction.Commit();/////提交事务
        }
        catch (MySqlException ex)
        {
            if (transaction != null) transaction.Rollback();
            throw ex;
        }
        finally
        {
            connection.Close();
            connection.Dispose();
        }
    }

    /// &lt;summary&gt;
    ///大批量数据插入,返回成功插入行数
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;connectionString&quot;&gt;数据库连接字符串&lt;/param&gt;
    /// &lt;param name=&quot;table&quot;&gt;数据表&lt;/param&gt;
    /// &lt;returns&gt;返回成功插入行数&lt;/returns&gt;
    public static int BulkInsert(string connectionString, DataTable table)
    {
        if (string.IsNullOrEmpty(table.TableName)) throw new Exception(&quot;请给DataTable的TableName属性附上表名称&quot;);
        if (table.Rows.Count == 0) return 0;
        int insertCount = 0;
        string tmpPath = Path.GetTempFileName();
        string csv = DataTableToCsv(table);
        File.WriteAllText(tmpPath, csv);
        using (MySqlConnection conn = new MySqlConnection(connectionString))
        {
            MySqlTransaction tran = null;
            try
            {
                conn.Open();
                tran = conn.BeginTransaction();
                MySqlBulkLoader bulk = new MySqlBulkLoader(conn)
                {
                    FieldTerminator = &quot;,&quot;,
                    FieldQuotationCharacter = &apos;&quot;&apos;,
                    EscapeCharacter = &apos;&quot;&apos;,
                    LineTerminator = &quot;\\r\\n&quot;,
                    FileName = tmpPath,
                    NumberOfLinesToSkip = 0,
                    TableName = table.TableName,
                };
                bulk.Columns.AddRange(table.Columns.Cast&lt;DataColumn&gt;().Select(colum =&gt; colum.ColumnName).ToList());
                insertCount = bulk.Load();
                tran.Commit();
            }
            catch (MySqlException ex)
            {
                if (tran != null) tran.Rollback();
                throw ex;
            }
        }
        File.Delete(tmpPath);
        return insertCount;
    }

    /// &lt;summary&gt;
    ///将DataTable转换为标准的CSV
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;table&quot;&gt;数据表&lt;/param&gt;
    /// &lt;returns&gt;返回标准的CSV&lt;/returns&gt;
    private static string DataTableToCsv(DataTable table)
    {
        //以半角逗号（即,）作分隔符，列为空也要表达其存在。
        //列内容如存在半角逗号（即,）则用半角引号（即&quot;&quot;）将该字段值包含起来。
        //列内容如存在半角引号（即&quot;）则应替换成半角双引号（&quot;&quot;）转义，并用半角引号（即&quot;&quot;）将该字段值包含起来。
        StringBuilder sb = new StringBuilder();
        DataColumn colum;
        foreach (DataRow row in table.Rows)
        {
            for (int i = 0; i &lt; table.Columns.Count; i++)
            {
                colum = table.Columns\[i\];
                if (i != 0) sb.Append(&quot;,&quot;);
                if (colum.DataType == typeof(string) &amp;&amp; row\[colum\].ToString().Contains(&quot;,&quot;))
                {
                    sb.Append(&quot;\\&quot;&quot; + row\[colum\].ToString().Replace(&quot;\\&quot;&quot;, &quot;\\&quot;\\&quot;&quot;) + &quot;\\&quot;&quot;);
                }
                else sb.Append(row\[colum\].ToString());
            }
            sb.AppendLine();
        }

        return sb.ToString();
    }

    #endregion 批量操作

    #endregion 静态方法
}</code></pre><p>}</p>
<p>MySqlHelper.cs</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>CMD 修复文件错误关联问题</title>
    <url>/zh-CN/2019/03/31/cmd-e4-bf-ae-e5-a4-8d-e6-96-87-e4-bb-b6-e9-94-99-e8-af-af-e5-85-b3-e8-81-94-e9-97-ae-e9-a2-98.html</url>
    <content><![CDATA[<p>::┌──────────────────────────┐<br>::│        故障还原方案         │<br>::│        文件错误关联问题     │<br>::└──────────────────────────┘<br>:: 显示或者隐藏命令 //ECHO [ON | OFF]<br>@ ECHO OFF<br>REM 对 lnk 和 exe 文件的错误关联问题进行分析<br>:: 设置颜色为 淡蓝色背景色，白色前景色<br>COLOR 9F<br>:: 设置运行窗口标题<br>TITLE 文件错误关联问题–演示<br>:: 提示以管理员身份运行<br>ECHO ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■<br>ECHO ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆<br>ECHO ☆                                                                          ☆<br>ECHO ☆ 为了能够成功演示，请使用管理员身份运行  [鼠标右键单击–以管理员身份运行] ☆<br>ECHO ☆                                                                          ☆<br>ECHO ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆<br>:: 显示标语信息<br>ECHO ╔═══════════════════════════════╗<br>ECHO ║  _____糖糖-测试  ——————————————- ║<br>ECHO ╚═══════════════════════════════╝</p>
<p>:: 说明可能导致此问题的相关原因<br>ECHO.<br>ECHO 主要症状：<br>ECHO.<br>ECHO 桌面多数或全部快捷方式图标变成了某一个相同的图标,exe文件无法运行。<br>ECHO.<br>ECHO 1.可能由于注册表异常导致。<br>ECHO.<br>ECHO 2.缓存过旧导致的异常。<br>ECHO.<br>ECHO =====================================</p>
<p>:: 空一行<br>ECHO.<br>:: 获取当前相对路径<br>set P=%~dp0<br>echo 当前路径 ╞ %P% ╡</p>
<p>:: 获取当前准确时间<br>set T=%DATE:<del>0,4%%DATE:</del>5,2%%DATE:<del>8,2%%TIME:</del>0,2%%TIME:<del>3,2%%TIME:</del>6,2%<br>echo 当前时间 ╞ %T% ╡</p>
<p>:: 空一行<br>ECHO.<br>:: 检测系统版本，如果需要并跳转到相应的系统标签处进行执行<br>VER|FINDSTR /I “5.1” &amp;&amp; GOTO XP || GOTO Win7</p>
<p>:: XP 系统的方案<br>:XP</p>
<p>:: 信息提示并作出选择<br>:: 暂不使用此句 CHOICE /C YN /T 10 /D Y /M “您好，键入 Y 执行修复，N 退出，如未操作，默认十秒后自动执行修复。<br>set /P IS=您好，键入 Y 执行修复，N 退出。(不区分大小写，输入错误将直接退出) 输入后回车<br>:: 判断输入的字符<br>:: 暂不使用此句 IF ERRORLEVEL 2 (EXIT) ELSE (GOTO R)<br>IF /I %IS% EQU Y (ECHO 记录状态) ELSE (EXIT)</p>
<p>:: 判断当前状态 0-1 ；写入注册表值，记录当前运行状态<br>REG QUERY HKEY_CURRENT_USER\Software\FileExts_Test /ve 1&gt;nul 2&gt;nul<br>:: 判断返回码是否为 1 (命令执行失败)<br>IF ERRORLEVEL 1 (<br>REG ADD “HKEY_CURRENT_USER\Software\FileExts_Test” /ve /f<br>TITLE 文件错误关联问题–制造故障中…<br>GOTO XP_C<br>) ELSE (<br>REG DELETE “HKEY_CURRENT_USER\Software\FileExts_Test” /f<br>TITLE 文件错误关联问题–修复故障中…<br>GOTO XP_R<br>)</p>
<p>:: Win7 系统的方案<br>:Win7</p>
<p>:: 信息提示并作出选择<br>CHOICE /C YN /T 10 /D Y /M “您好，键入 Y 执行修复，N 退出，如未操作，默认十秒后自动执行修复。<br>:: 暂不使用此句 set /P IS=您好，键入 Y 执行修复，N 退出。(不区分大小写，输入错误将直接退出) 输入后回车<br>:: 判断输入的字符<br>IF ERRORLEVEL 2 (EXIT) ELSE (ECHO 记录状态)<br>:: 暂不使用此句 IF /I %IS% EQU Y (GOTO R) ELSE (EXIT)</p>
<p>:: 判断当前状态 0-1 ；写入注册表值，记录当前运行状态<br>REG QUERY HKEY_CURRENT_USER\Software\FileExts_Test /ve 1&gt;nul 2&gt;nul<br>:: 判断返回码是否为 1 (命令执行失败)<br>IF ERRORLEVEL 1 (<br>REG ADD “HKEY_CURRENT_USER\Software\FileExts_Test” /ve /f<br>TITLE 文件错误关联问题–制造故障中…<br>GOTO Win7_C<br>) ELSE (<br>REG DELETE “HKEY_CURRENT_USER\Software\FileExts_Test” /f<br>TITLE 文件错误关联问题–修复故障中…<br>GOTO Win7_R<br>)</p>
<p>::<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p>:: 标签XP_C 制造故障<br>:XP_C</p>
<p>ECHO.<br>ECHO /////////////////////////////////<br>ECHO //如遇到安全软件拦截请解除拦截。/<br>ECHO /////////////////////////////////<br>:: 使用REG命令对注册表进行操作</p>
<p>:: 首先执行备份至临时目录<br>ECHO.<br>ECHO ■■■■ 备份注册表 ■■■■<br>ECHO ┌────────────┐</p>
<p>ECHO 备份路径 - %TEMP%<br>REG EXPORT HKCR\.exe %TEMP%\%T%_HKCR.exe.reg<br>REG EXPORT HKCR\.lnk %TEMP%\%T%_HKCR.lnk.reg<br>REG EXPORT HKCR\exefile %TEMP%\%T%_HKCR.exefile.reg<br>REG EXPORT HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk %TEMP%\%T%_HKCU.lnk.reg<br>REG EXPORT HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe %TEMP%\%T%_HKCU.exe.reg</p>
<p>ECHO └────────────┘<br>ECHO ☆☆注册表备份完毕☆☆<br>ECHO.<br>ECHO ■■■■ 篡改注册表 ■■■■<br>ECHO ┌────────────┐</p>
<p>:: HKEY_CLASSES_ROOT\exefile<br>REG DELETE “HKEY_CLASSES_ROOT\exefile\DefaultIcon” /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\DefaultIcon” /ve /t REG_SZ /d “%%1” /f</p>
<p>:: 设置变量并赋值<br>set exe=””””%%1””” %%*”<br>REG DELETE “HKEY_CLASSES_ROOT\exefile\shell\open” /f<br>REG DELETE “HKEY_CLASSES_ROOT\exefile\shell\runas” /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\open\command” /ve /t REG_SZ /d %exe% /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\open\command” /v “IsolatedCommand” /t REG_SZ /d %exe% /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\runas\command” /ve /t REG_SZ /d %exe% /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\runas\command” /v “IsolatedCommand” /t REG_SZ /d %exe% /f</p>
<p>:: HKEY_CLASSES_ROOT\.exe<br>REG ADD “HKEY_CLASSES_ROOT\.exe” /ve /t REG_SZ /d “lnkfile” /f<br>::assoc.exe=exefile</p>
<p>:: HKEY_CLASSES_ROOT\.lnk<br>REG ADD “HKEY_CLASSES_ROOT\.lnk” /ve /t REG_SZ /d “exefile” /f<br>::assoc.lnk=lnkfile</p>
<p>:: HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk” /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\OpenWithProgids” /ve /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\Openwithlist” /ve /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\OpenWithProgids” /va /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\Openwithlist” /va /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\UserChoice” /ve /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\UserChoice” /va /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\UserChoice” /v “Progid” /t REG_SZ /d “Applications\iexplore.exe” /f</p>
<p>:: HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe” /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\OpenWithProgids” /ve /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\Openwithlist” /ve /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\OpenWithProgids” /va /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\Openwithlist” /va /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\UserChoice” /ve /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\UserChoice” /va /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\UserChoice” /v “Progid” /t REG_SZ /d “Applications\notepad.exe” /f</p>
<p>:: REG DELETE “HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ShellIcons” /f</p>
<p>:: 判断图标缓存文件 IconCache.db 是否存在 ，是则删除文件<br>:: 针对 XP 等系统<br>IF EXIST “%USERPROFILE%\LocalSettings\Application Data\IconCache.db” (DEL /F /Q /A “%USERPROFILE%\LocalSettings\Application Data\IconCache.db”) ELSE (ECHO 未发现图标缓存文件)</p>
<p>:: 重启 explorer 进程<br>:: 强制结束 资源管理器 explorer 进程<br>TASKKILL /IM explorer.exe /F<br>:: 延时<br>ECHO 三秒后自动启动 explorer 进程<br>PING 127.0.0.1 -N 3 1&gt;nul 2&gt;nul<br>:: 启动 资源管理器 explorer 进程<br>start “” “explorer.exe”</p>
<p>ECHO └────────────┘<br>ECHO ☆☆注册表篡改完成☆☆<br>ECHO.<br>:: 等待按键继续<br>ECHO ……………………………………………………………..<br>echo 操作完毕,请查看故障是否制造成功 - 再次运行执行修复.<br>pause&gt;nul</p>
<p>:: 标签XP_R 进行修复<br>:XP_R</p>
<p>ECHO.<br>ECHO /////////////////////////////////<br>ECHO //如遇到安全软件拦截请解除拦截。/<br>ECHO /////////////////////////////////<br>:: 使用REG命令对注册表进行操作</p>
<p>:: 首先执行备份至临时目录<br>ECHO.<br>ECHO ■■■■ 备份注册表 ■■■■<br>ECHO ┌────────────┐</p>
<p>ECHO 备份路径 - %TEMP%<br>REG EXPORT HKCR\.exe %TEMP%\%T%_HKCR.exe.reg<br>REG EXPORT HKCR\.lnk %TEMP%\%T%_HKCR.lnk.reg<br>REG EXPORT HKCR\exefile %TEMP%\%T%_HKCR.exefile.reg<br>REG EXPORT HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk %TEMP%\%T%_HKCU.lnk.reg<br>REG EXPORT HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe %TEMP%\%T%_HKCU.exe.reg</p>
<p>ECHO └────────────┘<br>ECHO ☆☆注册表备份完毕☆☆<br>ECHO.<br>ECHO ■■■■ 修复注册表 ■■■■<br>ECHO ┌────────────┐</p>
<p>:: HKEY_CLASSES_ROOT\exefile<br>REG DELETE “HKEY_CLASSES_ROOT\exefile\DefaultIcon” /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\DefaultIcon” /ve /t REG_SZ /d “%%1” /f</p>
<p>:: 设置变量并赋值<br>set exe=””””%%1””” %%*”<br>REG DELETE “HKEY_CLASSES_ROOT\exefile\shell\open” /f<br>REG DELETE “HKEY_CLASSES_ROOT\exefile\shell\runas” /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\open\command” /ve /t REG_SZ /d %exe% /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\open\command” /v “IsolatedCommand” /t REG_SZ /d %exe% /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\runas\command” /ve /t REG_SZ /d %exe% /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\runas\command” /v “IsolatedCommand” /t REG_SZ /d %exe% /f</p>
<p>:: HKEY_CLASSES_ROOT\.exe<br>REG ADD “HKEY_CLASSES_ROOT\.exe” /ve /t REG_SZ /d “exefile” /f<br>assoc.exe=exefile</p>
<p>:: HKEY_CLASSES_ROOT\.lnk<br>REG ADD “HKEY_CLASSES_ROOT\.lnk” /ve /t REG_SZ /d lnkfile /f<br>assoc.lnk=lnkfile</p>
<p>:: HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\UserChoice” /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk” /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\OpenWithProgids” /ve /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\Openwithlist” /ve /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\OpenWithProgids” /va /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\Openwithlist” /va /f</p>
<p>:: HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\UserChoice” /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe” /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\OpenWithProgids” /ve /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\Openwithlist” /ve /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\OpenWithProgids” /va /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\Openwithlist” /va /f</p>
<p>:: REG DELETE “HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ShellIcons” /f</p>
<p>:: 判断图标缓存文件 IconCache.db 是否存在 ，是则删除文件<br>:: 针对 XP 等系统<br>IF EXIST “%USERPROFILE%\LocalSettings\Application Data\IconCache.db” (DEL /F /Q /A “%USERPROFILE%\LocalSettings\Application Data\IconCache.db”) ELSE (ECHO 未发现图标缓存文件)</p>
<p>:: 重启 explorer 进程<br>:: 强制结束 资源管理器 explorer 进程<br>TASKKILL /IM explorer.exe /F<br>:: 延时<br>ECHO 三秒后自动启动 explorer 进程<br>PING 127.0.0.1 -N 3 1&gt;nul 2&gt;nul<br>:: 启动 资源管理器 explorer 进程<br>start “” “explorer.exe”</p>
<p>ECHO └────────────┘<br>ECHO ☆☆注册表修复完成☆☆<br>ECHO.<br>:: 等待按键继续<br>ECHO ……………………………………………………………..<br>echo 操作完毕,请查看是否已经修复.<br>pause&gt;nul</p>
<p>::<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>::<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p>:: 标签Win7_C 制造故障<br>:Win7_C</p>
<p>ECHO.<br>ECHO /////////////////////////////////<br>ECHO //如遇到安全软件拦截请解除拦截。/<br>ECHO /////////////////////////////////<br>:: 使用REG命令对注册表进行操作</p>
<p>:: 首先执行备份至临时目录<br>ECHO.<br>ECHO ■■■■ 备份注册表 ■■■■<br>ECHO ┌────────────┐</p>
<p>ECHO 备份路径 - %TEMP%<br>REG EXPORT HKCR\.exe %TEMP%\%T%_HKCR.exe.reg /y<br>REG EXPORT HKCR\.lnk %TEMP%\%T%_HKCR.lnk.reg /y<br>REG EXPORT HKCR\exefile %TEMP%\%T%_HKCR.exefile.reg /y<br>REG EXPORT HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk %TEMP%\%T%_HKCU.lnk.reg /y<br>REG EXPORT HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe %TEMP%\%T%_HKCU.exe.reg /y</p>
<p>ECHO └────────────┘<br>ECHO ☆☆注册表备份完毕☆☆<br>ECHO.<br>ECHO ■■■■ 篡改注册表 ■■■■<br>ECHO ┌────────────┐</p>
<p>:: HKEY_CLASSES_ROOT\exefile<br>REG DELETE “HKEY_CLASSES_ROOT\exefile\DefaultIcon” /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\DefaultIcon” /ve /t REG_SZ /d “%%1” /f</p>
<p>:: 设置变量并赋值<br>set exe=””””%%1””” %%*”<br>REG DELETE “HKEY_CLASSES_ROOT\exefile\shell\open” /f<br>REG DELETE “HKEY_CLASSES_ROOT\exefile\shell\runas” /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\open\command” /ve /t REG_SZ /d %exe% /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\open\command” /v “IsolatedCommand” /t REG_SZ /d %exe% /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\runas\command” /ve /t REG_SZ /d %exe% /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\runas\command” /v “IsolatedCommand” /t REG_SZ /d %exe% /f</p>
<p>:: HKEY_CLASSES_ROOT\.exe<br>REG ADD “HKEY_CLASSES_ROOT\.exe” /ve /t REG_SZ /d “lnkfile” /f<br>::assoc.exe=exefile</p>
<p>:: HKEY_CLASSES_ROOT\.lnk<br>REG ADD “HKEY_CLASSES_ROOT\.lnk” /ve /t REG_SZ /d “exefile” /f<br>::assoc.lnk=lnkfile</p>
<p>:: HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk” /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\OpenWithProgids” /ve /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\Openwithlist” /ve /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\OpenWithProgids” /va /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\Openwithlist” /va /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\UserChoice” /ve /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\UserChoice” /va /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\UserChoice” /v “Progid” /t REG_SZ /d “Applications\iexplore.exe” /f</p>
<p>:: HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe” /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\OpenWithProgids” /ve /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\Openwithlist” /ve /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\OpenWithProgids” /va /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\Openwithlist” /va /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\UserChoice” /ve /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\UserChoice” /va /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\UserChoice” /v “Progid” /t REG_SZ /d “Applications\notepad.exe” /f</p>
<p>:: REG DELETE “HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ShellIcons” /f</p>
<p>:: 判断图标缓存文件 IconCache.db 是否存在 ，是则删除文件<br>:: 针对 Win7 等系统<br>IF EXIST “%USERPROFILE%\AppData\Local\IconCache.db” (DEL /F /Q /A “%USERPROFILE%\AppData\Local\IconCache.db”) ELSE (ECHO 未发现图标缓存文件)</p>
<p>:: 重启 explorer 进程<br>:: 强制结束 资源管理器 explorer 进程<br>TASKKILL /IM explorer.exe /F<br>:: 延迟操作<br>ECHO 3 秒后自动启动 explorer 进程<br>TIMEOUT 3<br>:: 启动 资源管理器 explorer 进程<br>start “” “explorer.exe”</p>
<p>ECHO └────────────┘<br>ECHO ☆☆注册表篡改完成☆☆<br>ECHO.<br>:: 等待按键继续<br>ECHO ……………………………………………………………..<br>echo 操作完毕,请查看故障是否制造成功 - 再次运行执行修复.<br>pause&gt;nul</p>
<p>:: 标签Win7_R 进行修复<br>:Win7_R</p>
<p>ECHO.<br>ECHO /////////////////////////////////<br>ECHO //如遇到安全软件拦截请解除拦截。/<br>ECHO /////////////////////////////////<br>:: 使用REG命令对注册表进行操作</p>
<p>:: 首先执行备份至临时目录<br>ECHO.<br>ECHO ■■■■ 备份注册表 ■■■■<br>ECHO ┌────────────┐</p>
<p>ECHO 备份路径 - %TEMP%<br>REG EXPORT HKCR\.exe %TEMP%\%T%_HKCR.exe.reg /y<br>REG EXPORT HKCR\.lnk %TEMP%\%T%_HKCR.lnk.reg /y<br>REG EXPORT HKCR\exefile %TEMP%\%T%_HKCR.exefile.reg /y<br>REG EXPORT HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk %TEMP%\%T%_HKCU.lnk.reg /y<br>REG EXPORT HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe %TEMP%\%T%_HKCU.exe.reg /y</p>
<p>ECHO └────────────┘<br>ECHO ☆☆注册表备份完毕☆☆<br>ECHO.<br>ECHO ■■■■ 修复注册表 ■■■■<br>ECHO ┌────────────┐</p>
<p>:: HKEY_CLASSES_ROOT\exefile<br>REG DELETE “HKEY_CLASSES_ROOT\exefile\DefaultIcon” /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\DefaultIcon” /ve /t REG_SZ /d “%%1” /f</p>
<p>:: 设置变量并赋值<br>set exe=””””%%1””” %%*”<br>REG DELETE “HKEY_CLASSES_ROOT\exefile\shell\open” /f<br>REG DELETE “HKEY_CLASSES_ROOT\exefile\shell\runas” /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\open\command” /ve /t REG_SZ /d %exe% /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\open\command” /v “IsolatedCommand” /t REG_SZ /d %exe% /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\runas\command” /ve /t REG_SZ /d %exe% /f<br>REG ADD “HKEY_CLASSES_ROOT\exefile\shell\runas\command” /v “IsolatedCommand” /t REG_SZ /d %exe% /f</p>
<p>:: HKEY_CLASSES_ROOT\.exe<br>REG ADD “HKEY_CLASSES_ROOT\.exe” /ve /t REG_SZ /d “exefile” /f<br>assoc.exe=exefile</p>
<p>:: HKEY_CLASSES_ROOT\.lnk<br>REG ADD “HKEY_CLASSES_ROOT\.lnk” /ve /t REG_SZ /d lnkfile /f<br>assoc.lnk=lnkfile</p>
<p>:: HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\UserChoice” /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk” /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\OpenWithProgids” /ve /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\Openwithlist” /ve /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\OpenWithProgids” /va /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.lnk\Openwithlist” /va /f</p>
<p>:: HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\UserChoice” /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe” /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\OpenWithProgids” /ve /f<br>REG ADD “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\Openwithlist” /ve /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\OpenWithProgids” /va /f<br>REG DELETE “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.exe\Openwithlist” /va /f</p>
<p>:: REG DELETE “HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ShellIcons” /f</p>
<p>:: 判断图标缓存文件 IconCache.db 是否存在 ，是则删除文件<br>:: 针对 Win7 等系统<br>IF EXIST “%USERPROFILE%\AppData\Local\IconCache.db” (DEL /F /Q /A “%USERPROFILE%\AppData\Local\IconCache.db”) ELSE (ECHO 未发现图标缓存文件)</p>
<p>:: 重启 explorer 进程<br>:: 强制结束 资源管理器 explorer 进程<br>TASKKILL /IM explorer.exe /F<br>:: 延迟操作<br>ECHO 3 秒后自动启动 explorer 进程<br>TIMEOUT 3<br>:: 启动 资源管理器 explorer 进程<br>start “” “explorer.exe”</p>
<p>ECHO └────────────┘<br>ECHO ☆☆注册表修复完成☆☆<br>ECHO.<br>:: 等待按键继续<br>ECHO ……………………………………………………………..<br>echo 操作完毕,请查看是否已经修复.<br>echo.<br>echo 提示：如果存在系统托盘图标部分消失的问题，请打开任务管理器 结束 explorer 进程，新建 explorer 进程即可，或者重启电脑。<br>pause&gt;nul</p>
<p>REM =====END=====</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>CMD</tag>
        <tag>Windows</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CMD 修复XP摄像头功能异常</title>
    <url>/zh-CN/2019/03/31/cmd-e4-bf-ae-e5-a4-8dxp-e6-91-84-e5-83-8f-e5-a4-b4-e5-8a-9f-e8-83-bd-e5-bc-82-e5-b8-b8.html</url>
    <content><![CDATA[<p>:: 显示或者隐藏命令 //ECHO [ON | OFF]<br>@ ECHO OFF<br>REM 摄像头无法正常打开。</p>
<p>:: 设置颜色为 淡蓝色背景色，白色前景色<br>COLOR 9F</p>
<p>:: 设置运行窗口标题<br>TITLE 摄像头异常</p>
<p>:: 提示以管理员身份运行<br>ECHO ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■<br>ECHO ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆<br>ECHO ☆                                                                          ☆<br>ECHO ☆ 为了能够成功修复，请使用管理员身份运行  [鼠标右键单击–以管理员身份运行] ☆<br>ECHO ☆                                                                          ☆<br>ECHO ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</p>
<p>ECHO.<br>::说明可能导致此问题的相关原因<br>ECHO 主要症状：<br>ECHO 摄像头无法使用。<br>ECHO 1.可能由于注册表异常导致。<br>ECHO 2.可能相关组件导致异常。<br>ECHO 3.可能由于摄像头驱动程序导致异常。<br>ECHO 4. ………..<br>ECHO =====================================</p>
<p>:: 空一行<br>ECHO.<br>:: 获取当前相对路径<br>set P=%~dp0<br>echo 当前路径 ╞ %P% ╡</p>
<p>:: 获取当前准确时间<br>set T=%DATE:<del>0,4%%DATE:</del>5,2%%DATE:<del>8,2%%TIME:</del>0,2%%TIME:<del>3,2%%TIME:</del>6,2%<br>echo 当前时间 ╞ %T% ╡</p>
<p>ECHO.<br>::信息提示并作出选择<br>::暂不使用此句 CHOICE /C YN /T 10 /D Y /M “您好，键入 Y 执行修复，N 退出，如未操作，默认十秒后自动执行修复。<br>set /P IS=您好，键入 Y 执行修复，N 退出。(不区分大小写，输入错误将直接退出) 输入后回车<br>::判断输入的字符<br>::暂不使用此句 IF ERRORLEVEL 2 (EXIT) ELSE (GOTO R)<br>IF /I %IS% EQU Y (ECHO 开始修复) ELSE (EXIT)</p>
<p>:: 显示系统信息<br>ECHO.<br>ECHO ■■■■■■ 当前系统版本 ■■■■■■<br>VER|FINDSTR /I “5.1” &gt; nul &amp;&amp; ECHO ■■■■■■  Windows XP  ■■■■■■<br>VER|FINDSTR /I “6.1” &gt; nul &amp;&amp; ECHO ■■■■■■   Windows 7  ■■■■■■<br>VER|FINDSTR /I “6.2” &gt; nul &amp;&amp; ECHO ■■■■■■   Windows 8  ■■■■■■<br>VER|FINDSTR /I “6.3” &gt; nul &amp;&amp; ECHO ■■■■■■  Windows 8.1 ■■■■■■</p>
<p>ECHO “%PROCESSOR_ARCHITECTURE%”|FINDSTR /I “86” &gt; nul &amp;&amp; ECHO ■■■■■■     32 位    ■■■■■■<br>ECHO “%PROCESSOR_ARCHITECTURE%”|FINDSTR /I “64” &gt; nul &amp;&amp; ECHO ■■■■■■     64 位    ■■■■■■</p>
<p>ECHO.<br>:: 备份注册表<br>ECHO ▁▂▃▄▅▆▇█ 备份注册表 █▇▆▅▄▃▂▁<br>ECHO.<br>:: 创建目录<br>MKDIR %TEMP%\%T% &gt; nul<br>IF /I %errorlevel% EQU 0 (<br>    ECHO 备份目录 %TEMP%\%T% 创建成功.<br>) ELSE (<br>     ECHO 创建备份目录 %TEMP%\%T% 出错. &amp;&amp; ECHO 按任意键退出. &amp;&amp; pause&gt;nul &amp;&amp; EXIT<br>)<br>:: 导出注册表项、值<br>REG EXPORT HKEY_CLASSES_ROOT\CLSID\{62BE5D10-60EB-11d0-BD3B-00A0C911CE86} %TEMP%\%T%\HKCR-CLSID-62BE5.reg<br>REG EXPORT HKEY_CLASSES_ROOT\Wow6432Node\CLSID\{62BE5D10-60EB-11d0-BD3B-00A0C911CE86} %TEMP%\%T%\HKCR-Wow6432Node-CLSID-62BE5.reg</p>
<p>REG EXPORT HKEY_CLASSES_ROOT\CLSID\{DA4E3DA0-D07D-11d0-BD50-00A0C911CE86} %TEMP%\%T%\HKCR-CLSID-DA4E3.reg<br>REG EXPORT HKEY_CLASSES_ROOT\Wow6432Node\CLSID\{DA4E3DA0-D07D-11d0-BD50-00A0C911CE86} %TEMP%\%T%\HKCR-Wow6432Node-CLSID-DA4E3.reg</p>
<p>REG EXPORT HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\{6BDD1FC6-810F-11D0-BEC7-08002BE2092F} %TEMP%\%T%\HKLM-6BDD1.reg<br>::REG EXPORT 注册表项 %TEMP%\%T%\导出的名称</p>
<p>ECHO 注册表备份完毕，位置 %TEMP%\%T%<br>ECHO.<br>ECHO ━━━━━━━━━━━━━━━━━━━━</p>
<p>ECHO.<br>:: 修复注册表<br>ECHO ▁▂▃▄▅▆▇█ 重置注册表 █▇▆▅▄▃▂▁<br>ECHO.<br>:: 删除注册表项、值<br>REG DELETE “HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}” /v “UpperFilters” /f<br>:: 添加注册表项、值<br>REG ADD “HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Class\{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}” /v “UpperFilters” /t REG_MULTI_SZ /d “” /f<br>ECHO.<br>ECHO ━━━━━━━━━━━━━━━━━━━━</p>
<p>ECHO.<br>:: 注册 Quartz.dll Proppage.dll directSpy.dll<br>ECHO ▁▂▃▄▅▆▇█ 注册 dll 组件 █▇▆▅▄▃▂▁<br>ECHO.<br>:: devenum.dll<br>regsvr32 /s devenum.dll<br>IF /I %errorlevel% EQU 0 (<br>    ECHO 注册 devenum.dll 成功.<br>) ELSE (<br>    IF /I %errorlevel% EQU 5 (<br>        ECHO 注册 devenum.dll 所需的权限需要提升.<br>    ) ELSE (<br>        IF /I %errorlevel% EQU 3 (<br>            ECHO 文件 devenum.dll 没有找到.<br>        ) ELSE (<br>            ECHO 注册 devenum.dll 出现未知错误.)<br>    )<br>)<br>:: msdmo.dll<br>regsvr32 /s msdmo.dll<br>IF /I %errorlevel% EQU 0 (<br>    ECHO 注册 msdmo.dll 成功.<br>) ELSE (<br>    IF /I %errorlevel% EQU 5 (<br>        ECHO 注册 msdmo.dll 所需的权限需要提升.<br>    ) ELSE (<br>        IF /I %errorlevel% EQU 3 (<br>            ECHO 文件 msdmo.dll 没有找到.<br>        ) ELSE (<br>            ECHO 注册 msdmo.dll 出现未知错误.)<br>    )<br>)<br>:: avicap32.dll<br>regsvr32 /s avicap32.dll<br>IF /I %errorlevel% EQU 0 (<br>    ECHO 注册 avicap32.dll 成功.<br>) ELSE (<br>    IF /I %errorlevel% EQU 5 (<br>        ECHO 注册 avicap32.dll 所需的权限需要提升.<br>    ) ELSE (<br>        IF /I %errorlevel% EQU 3 (<br>            ECHO 文件 avicap32.dll 没有找到.<br>        ) ELSE (<br>            ECHO 注册 avicap32.dll 出现未知错误.)<br>    )<br>)<br>:: msvfw32.dll<br>regsvr32 /s msvfw32.dll<br>IF /I %errorlevel% EQU 0 (<br>    ECHO 注册 msvfw32.dll 成功.<br>) ELSE (<br>    IF /I %errorlevel% EQU 5 (<br>        ECHO 注册 msvfw32.dll 所需的权限需要提升.<br>    ) ELSE (<br>        IF /I %errorlevel% EQU 3 (<br>            ECHO 文件 msvfw32.dll 没有找到.<br>        ) ELSE (<br>            ECHO 注册 msvfw32.dll 出现未知错误.)<br>    )<br>)<br>:: Quartz.dll<br>regsvr32 /s Quartz.dll<br>IF /I %errorlevel% EQU 0 (<br>    ECHO 注册 Quartz.dll 成功.<br>) ELSE (<br>    IF /I %errorlevel% EQU 5 (<br>        ECHO 注册 Quartz.dll 所需的权限需要提升.<br>    ) ELSE (<br>        IF /I %errorlevel% EQU 3 (<br>            ECHO 文件 Quartz.dll 没有找到.<br>        ) ELSE (<br>            ECHO 注册 Quartz.dll 出现未知错误.)<br>    )<br>)<br>:: Proppage.dll<br>regsvr32 /s Proppage.dll<br>IF /I %errorlevel% EQU 0 (<br>    ECHO 注册 Proppage.dll 成功.<br>) ELSE (<br>    IF /I %errorlevel% EQU 5 (<br>        ECHO 注册 Proppage.dll 所需的权限需要提升.<br>    ) ELSE (<br>        IF /I %errorlevel% EQU 3 (<br>            ECHO 文件 Proppage.dll 没有找到.<br>        ) ELSE (<br>            ECHO 注册 Proppage.dll 出现未知错误.)<br>    )<br>)<br>:: directSpy.dll<br>regsvr32 /s directSpy.dll<br>IF /I %errorlevel% EQU 0 (<br>    ECHO 注册 directSpy.dll 成功.<br>) ELSE (<br>    IF /I %errorlevel% EQU 5 (<br>        ECHO 注册 directSpy.dll 所需的权限需要提升.<br>    ) ELSE (<br>        IF /I %errorlevel% EQU 3 (<br>            ECHO 文件 directSpy.dll 没有找到.<br>        ) ELSE (<br>            ECHO 注册 directSpy.dll 出现未知错误.)<br>    )<br>)<br>ECHO.<br>ECHO ━━━━━━━━━━━━━━━━━━━━━━</p>
<p>ECHO.<br>:: 启动 Windows Image Acquisition (WIA) 服务<br>ECHO ▁▂▃▄▅▆▇█ 启动 Windows Image Acquisition (WIA) 服务 █▇▆▅▄▃▂▁<br>ECHO.<br>:: net start 命令启动 stisvc 服务<br>net start stisvc</p>
<p>:: 设置 stisvc 服务为自启动<br>sc config stisvc start= auto</p>
<p>:: 再次启动 stisvc 服务使用 sc start 命令<br>sc start stisvc<br>ECHO.<br>ECHO ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</p>
<p>:: 等待按键继续<br>ECHO ……………………………………………………………..<br>echo 操作完毕.<br>pause&gt;nul</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>CMD</tag>
        <tag>Windows</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CMD 修复电脑磁盘图标</title>
    <url>/zh-CN/2019/03/31/cmd-e4-bf-ae-e5-a4-8d-e6-a1-8c-e9-9d-a2-e5-bf-ab-e6-8d-b7-e6-96-b9-e5-bc-8f-e5-8f-98-e6-88-90-e4-ba-86-e7-9b-b8-e5-90-8c-e7-9a-84-e5-9b-be-e6-a0-87-e6-88-96-e8-80-85-e6-9c-aa-e7-9f-a5-e5-9b-be.html</url>
    <content><![CDATA[<p>::显示或者隐藏命令 //ECHO [ON | OFF]<br>@ ECHO OFF<br>REM 修复电脑磁盘图标。<br>::设置颜色为 淡蓝色背景色，白色前景色<br>COLOR 9F<br>::设置运行窗口标题<br>TITLE XP 、Win7电脑磁盘图标–修复<br>::提示以管理员身份运行<br>ECHO ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■<br>ECHO ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆<br>ECHO ☆                                                                          ☆<br>ECHO ☆ 为了能够成功修复，请使用管理员身份运行  [鼠标右键单击–以管理员身份运行] ☆<br>ECHO ☆                                                                          ☆<br>ECHO ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</p>
<p>::检测系统版本，如果需要并跳转到相应的系统标签处进行执行<br>VER|FINDSTR /I “5.1” &amp;&amp; GOTO XP || GOTO Win7<br>:: XP 系统的方案<br>:XP<br>::说明可能导致此问题的相关原因<br>ECHO 主要症状：<br>ECHO 磁盘图标显示未知或者为其他图标。<br>ECHO 1.可能由于注册表异常导致。<br>ECHO 2.相关服务未启用。<br>ECHO 3.设置了磁盘分区的Antorun.inf。<br>ECHO 4.更改了shell32.dll中分区图标，或者shell32.dll文件损坏。<br>ECHO 5.缓存过旧导致的异常。<br>ECHO =====================================<br>::信息提示并作出选择<br>::暂不使用此句 CHOICE /C YN /T 10 /D Y /M “您好，键入 Y 执行修复，N 退出，如未操作，默认十秒后自动执行修复。<br>set /P IS=您好，键入 Y 执行修复，N 退出。(不区分大小写，输入错误将直接退出) 输入后回车<br>::判断输入的字符<br>::暂不使用此句 IF ERRORLEVEL 2 (EXIT) ELSE (GOTO R)<br>IF /I %IS% EQU Y (GOTO R) ELSE (EXIT)<br>:: Win7 系统的方案<br>:Win7<br>::说明可能导致此问题的相关原因<br>ECHO 主要症状：<br>ECHO.<br>ECHO 磁盘图标显示未知或者为其他图标。<br>ECHO.<br>ECHO 1.可能由于注册表异常导致。<br>ECHO.<br>ECHO 2.相关服务未启用。<br>ECHO.<br>ECHO 3.设置了磁盘分区的Antorun.inf。<br>ECHO.<br>ECHO 4.更改了shell32.dll中分区图标，或者shell32.dll文件损坏。<br>ECHO.<br>ECHO 5.缓存过旧导致的异常。<br>ECHO =====================================<br>::信息提示并作出选择<br>CHOICE /C YN /T 10 /D Y /M “您好，键入 Y 执行修复，N 退出，如未操作，默认十秒后自动执行修复。<br>::暂不使用此句 set /P IS=您好，键入 Y 执行修复，N 退出。(不区分大小写，输入错误将直接退出) 输入后回车<br>::判断输入的字符<br>IF ERRORLEVEL 2 (EXIT) ELSE (GOTO R)<br>::暂不使用此句 IF /I %IS% EQU Y (GOTO R) ELSE (EXIT)</p>
<p>::标签R<br>:R<br>ECHO.<br>ECHO /////////////////////////////////<br>ECHO //如遇到安全软件拦截请解除拦截。/<br>ECHO /////////////////////////////////</p>
<p>::首先执行备份至临时目录<br>ECHO.<br>ECHO ■■■■ 备份autorun.inf文件 ■■■■<br>ECHO ┌────────────┐<br>FOR %%i IN (<br>C D E F G H I J K L M N O P Q R S T U V W X Y Z) DO IF EXIST “%%i:\autorun.inf” (<br>COPY /Y %%i:\autorun.inf %TEMP%\%%iautorun.inf) ELSE (<br>ECHO 未备份 %%i:盘autorun.inf 文件)<br>ECHO └────────────┘<br>ECHO %TEMP%<br>ECHO ☆☆autorun.inf备份至临时目录☆☆</p>
<p>ECHO.<br>ECHO ■■■■ 删除autorun.inf文件 ■■■■<br>ECHO ┌────────────┐<br>FOR %%i IN (<br>C D E F G H I J K L M N O P Q R S T U V W X Y Z) DO IF EXIST “%%i:\autorun.inf” (<br>DEL /F /Q /A %%i:\autorun.inf) ELSE (<br>ECHO %%i:盘未发现autorun.inf 文件)<br>ECHO └────────────┘<br>ECHO ☆☆autorun.inf文件删除完毕☆☆</p>
<p>ECHO.<br>ECHO ■■■■ 备份注册表 ■■■■<br>ECHO ┌────────────┐<br>REG EXPORT HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons %TEMP%\HKLM.DriveIcons.reg /y<br>ECHO └────────────┘<br>ECHO ☆☆注册表备份完毕☆☆</p>
<p>ECHO.<br>ECHO ■■■■ 清理注册表 ■■■■<br>ECHO ┌────────────┐<br>REG DELETE “HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons” /f<br>ECHO └────────────┘<br>ECHO ☆☆注册表清理完毕☆☆</p>
<p>ECHO.<br>ECHO ■■■■ 重启 ShellHWDetection 服务 ■■■■<br>ECHO ┌────────────┐<br>::NET START [service]<br>::NET STOP [service]<br>::sc config [service] start= demand     //手动<br>::sc config [service] start= auto       //自动<br>::sc config [service] start= disabled //禁用<br>::sc start [service]<br>::sc stop   [service]<br>net start ShellHWDetection<br>sc config ShellHWDetection start= auto<br>sc start ShellHWDetection<br>ECHO └────────────┘<br>ECHO ☆☆ShellHWDetection 服务启动完毕☆☆</p>
<p>::判断图标缓存文件 IconCache.db 是否存在 ，是则删除文件<br>IF EXIST “%USERPROFILE%\AppData\Local\IconCache.db” (DEL /F /Q /A “%USERPROFILE%\AppData\Local\IconCache.db”) ELSE (ECHO 未发现图标缓存文件)<br>IF EXIST “%USERPROFILE%\LocalSettings\Application Data\IconCache.db” (DEL /F /Q /A “%USERPROFILE%\LocalSettings\Application Data\IconCache.db”) ELSE (ECHO 未发现图标缓存文件)<br>::重启 explorer 进程<br>TASKKILL /IM explorer.exe /F<br>start “” “explorer.exe”</p>
<p>ECHO.</p>
<p>ECHO ┌────────────┐<br>ECHO 如问题没有有效解决可尝试<br>ECHO 右键单击 “计算机” - “管理” - “磁盘管理”中更改磁盘的盘符来解决。<br>ECHO └────────────┘</p>
<p>ECHO.<br>::等待按键继续<br>ECHO ……………………………………………………………..<br>echo 操作完毕,如果提示成功并且还存在问题建议重启计算机后查看是否已经修复.<br>pause&gt;nul</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>CMD</tag>
        <tag>Windows</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CMD 在Windows7 之后版本添加第三方摄像头工具</title>
    <url>/zh-CN/2019/03/31/cmd-e5-9c-a8windows7-e4-b9-8b-e5-90-8e-e7-89-88-e6-9c-ac-e6-b7-bb-e5-8a-a0-e7-ac-ac-e4-b8-89-e6-96-b9-e6-91-84-e5-83-8f-e5-a4-b4-e5-b7-a5-e5-85-b7.html</url>
    <content><![CDATA[<p>:: 显示或者隐藏命令 //ECHO [ON | OFF]<br>@ ECHO OFF<br>REM 没有摄像头图标。</p>
<p>:: 设置颜色为 淡蓝色背景色，白色前景色<br>COLOR 9F</p>
<p>:: 设置运行窗口标题<br>TITLE 添加摄像头图标</p>
<p>:: 申请提权<br>net session &gt;nul 2&gt;&amp;1<br>if not “%errorLevel%” == “0” (<br>  echo 提示：此工具必须使用管理员权限运行！<br>  echo 它会弹出UAC对话框，请单击[是]继续。<br>  echo Set UAC = CreateObject^(“Shell.Application”^) &gt; “%temp%\578635getadmin.vbs”<br>  echo UAC.ShellExecute “%~s0”, “%*”, “”, “runas”, 1 &gt;&gt; “%temp%\578635getadmin.vbs”<br>  “%temp%\578635getadmin.vbs”<br>  exit /b 2<br>)</p>
<p>ECHO.<br>::说明可能导致此问题的相关原因<br>ECHO 主要症状：<br>ECHO 摄像头图标消失、没有图标。<br>ECHO 1.可能未安装摄像头软件。<br>ECHO 2.可能注册表异常导致。<br>ECHO 3.用户错误操作导致。<br>ECHO 注意：此脚本将创建第三方摄像头软件<br>ECHO =====================================</p>
<p>:: 空一行<br>:: ECHO.<br>:: 获取当前相对路径<br>set P=%~dp0<br>:: echo 当前路径 ╞ %P% ╡</p>
<p>:: 获取当前准确时间<br>set T=%DATE:<del>0,4%%DATE:</del>5,2%%DATE:<del>8,2%%TIME:</del>0,2%%TIME:<del>3,2%%TIME:</del>6,2%<br>:: echo 当前时间 ╞ %T% ╡</p>
<p>:: 显示系统信息<br>ECHO ■■■■■■ 当前系统版本 ■■■■■■<br>VER|FINDSTR /I “5.1” &gt; nul &amp;&amp; ECHO ■■■■■■  Windows XP  ■■■■■■ &amp;&amp; GOTO A<br>VER|FINDSTR /I “6.1” &gt; nul &amp;&amp; ECHO ■■■■■■   Windows 7  ■■■■■■ &amp;&amp; GOTO A<br>VER|FINDSTR /I “6.2” &gt; nul &amp;&amp; ECHO ■■■■■■   Windows 8  ■■■■■■ &amp;&amp; GOTO A<br>VER|FINDSTR /I “6.3” &gt; nul &amp;&amp; ECHO ■■■■■■  Windows 8.1 ■■■■■■ &amp;&amp; GOTO A</p>
<p>wmic os get name<br>:A<br>ECHO “%PROCESSOR_ARCHITECTURE%”|FINDSTR /I “86” &gt; nul &amp;&amp; ECHO ■■■■■■     32 位    ■■■■■■ &amp;&amp; set X=32<br>ECHO “%PROCESSOR_ARCHITECTURE%”|FINDSTR /I “64” &gt; nul &amp;&amp; ECHO ■■■■■■     64 位    ■■■■■■ &amp;&amp; set X=64</p>
<p>:: 判断变量X的值,X为系统位数<br>IF /I %X% EQU 64 (<br>    set exe=”%ProgramFiles(X86)%\MiniCapTool\Cap.exe”<br>    set ico=”%ProgramFiles(X86)%\MiniCapTool\Cap.ico”<br>    set dir=”%ProgramFiles(X86)%\MiniCapTool”<br>) ELSE (<br>    IF /I %X% EQU 32 (<br>        set exe=”%ProgramFiles%\MiniCapTool\Cap.exe”<br>        set ico=”%ProgramFiles%\MiniCapTool\Cap.ico”<br>        set dir=”%ProgramFiles%\MiniCapTool”<br>    ) ELSE (<br>        set exe=”%systemdrive%\Program Files\MiniCapTool\Cap.exe”<br>        set ico=”%systemdrive%\Program Files\MiniCapTool\Cap.ico”<br>        set dir=”%systemdrive%\Program Files\MiniCapTool”<br>    )<br>)</p>
<p>:: 获取当前状态<br>ECHO.<br>ECHO 正在检测当前状态…<br>ECHO.<br>:: 判断文件是否存在<br>IF EXIST %exe% (<br>    echo 发现存在摄像头软件. 路径 &amp;&amp; echo %exe%<br>) ELSE (<br>    echo 未发现摄像头软件.<br>)</p>
<p>:: 检查注册表<br>REG QUERY HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{AC000000-AC00-AC00-AC00-100000000008} /ve &gt;nul 2&gt;nul<br>:: 判断返回码状态<br>IF /I %errorlevel% EQU 0 (<br>    ECHO 检测到注册表有残留.<br>) ELSE (<br>    IF /I %errorlevel% EQU 1 (<br>        ECHO 未发现注册表残留.<br>    ) ELSE (<br>        ECHO 出现未知错误.<br>    )<br>)</p>
<p>ECHO.<br>::信息提示并作出选择<br>::暂不使用此句 CHOICE /C YN /T 10 /D Y /M “您好，键入 Y 执行修复，N 退出，如未操作，默认十秒后自动执行修复。<br>set /P IS=您好，键入1执行添加、修复，2移除，3退出。(输入错误将直接退出) 输入后回车:<br>::判断输入的字符<br>::暂不使用此句 IF ERRORLEVEL 2 (EXIT) ELSE (GOTO R)<br>IF /I %IS% EQU 1 (<br>    ECHO 开始修复 &amp;&amp; GOTO Install<br>) ELSE (<br>    IF /I %IS% EQU 2 (<br>        ECHO 开始移除 &amp;&amp; GOTO uninstall<br>    ) ELSE (<br>        IF /I %IS% EQU 3 (<br>            EXIT<br>        ) ELSE (<br>            ECHO 输入错误，按任意键退出。&amp;&amp; pause&gt;nul &amp;&amp; EXIT<br>        )<br>    )<br>)</p>
<p>REM ———————————————————————————————————-</p>
<p>:Install<br>ECHO.<br>:: 备份注册表<br>ECHO ▁▂▃▄▅▆▇█ 备份注册表 █▇▆▅▄▃▂▁<br>ECHO.<br>:: 创建目录<br>MKDIR %TEMP%\%T% &gt; nul<br>IF /I %errorlevel% EQU 0 (<br>    ECHO 备份目录 %TEMP%\%T% 创建成功.<br>) ELSE (<br>     ECHO 创建备份目录 %TEMP%\%T% 出错. &amp;&amp; ECHO 按任意键退出. &amp;&amp; pause&gt;nul &amp;&amp; EXIT<br>)<br>:: 导出注册表项、值<br>REG EXPORT HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{AC000000-AC00-AC00-AC00-100000000008} %TEMP%\%T%\HKCM-CLSID-AC000.reg<br>REG EXPORT HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{AC000000-AC00-AC00-AC00-100000000008} %TEMP%\%T%\HKCM-NameSpace-CLSID-AC000.reg<br>::REG EXPORT 注册表项 %TEMP%\%T%\导出的名称</p>
<p>ECHO 注册表备份完毕，位置 %TEMP%\%T%<br>ECHO.<br>ECHO ━━━━━━━━━━━━━━━━━━━━</p>
<p>ECHO.<br>ECHO ▁▂▃▄▅▆▇█ 安装摄像头软件 █▇▆▅▄▃▂▁<br>ECHO.<br>ECHO 安装位置 %dir%<br>:: 创建目录<br>MKDIR %dir%</p>
<p>:: 复制文件、目录到系统软件安装目录<br>COPY /y “%P%\MiniCapTool\Cap.exe” %exe%<br>COPY /y “%P%\MiniCapTool\Cap.ico” %ico%</p>
<p>ECHO.<br>ECHO ━━━━━━━━━━━━━━━━━━━━━━</p>
<p>ECHO.<br>:: 修复注册表<br>ECHO ▁▂▃▄▅▆▇█ 修复注册表 █▇▆▅▄▃▂▁<br>ECHO.<br>:: 安装<br>REM ECHO Windows Registry Editor Version 5.00 &gt; %TEMP%\%T%\add.reg<br>REM ECHO. &gt;&gt; %TEMP%\%T%\add.reg<br>REM ECHO [HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{AC000000-AC00-AC00-AC00-100000000008}] &gt;&gt; %TEMP%\%T%\add.reg<br>REM ECHO @=”USB 视频设备” &gt;&gt; %TEMP%\%T%\add.reg<br>REM ECHO. &gt;&gt; %TEMP%\%T%\add.reg<br>REM ECHO [HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{AC000000-AC00-AC00-AC00-100000000008}\DefaultIcon] &gt;&gt; %TEMP%\%T%\add.reg<br>REM ECHO @=”\%ico%” &gt;&gt; %TEMP%\%T%\add.reg<br>REM ECHO. &gt;&gt; %TEMP%\%T%\add.reg<br>REM ECHO [HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{AC000000-AC00-AC00-AC00-100000000008}\shell\Open\Command] &gt;&gt; %TEMP%\%T%\add.reg<br>REM ECHO @=”\%exe%” &gt;&gt; %TEMP%\%T%\add.reg<br>REM ECHO. &gt;&gt; %TEMP%\%T%\add.reg<br>REM ECHO [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{AC000000-AC00-AC00-AC00-100000000008}] &gt;&gt; %TEMP%\%T%\add.reg<br>REM ECHO @=”USB 视频设备” &gt;&gt; %TEMP%\%T%\add.reg</p>
<p>REM :: 导入注册表文件<br>REM regedit /s %TEMP%\%T%\add.reg</p>
<p>REG ADD HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{AC000000-AC00-AC00-AC00-100000000008} /ve /t REG_SZ /d “USB 视频设备” /f<br>REG ADD HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{AC000000-AC00-AC00-AC00-100000000008}\DefaultIcon /ve /t REG_SZ /d %ico% /f<br>REG ADD HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{AC000000-AC00-AC00-AC00-100000000008}\shell /ve /f<br>REG DELETE HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{AC000000-AC00-AC00-AC00-100000000008}\shell /va /f<br>REG ADD HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{AC000000-AC00-AC00-AC00-100000000008}\shell\Open /ve /f<br>REG DELETE HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{AC000000-AC00-AC00-AC00-100000000008}\shell\Open /va /f<br>REG ADD HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{AC000000-AC00-AC00-AC00-100000000008}\shell\Open\Command /ve /t REG_SZ /d %exe% /f</p>
<p>REG ADD HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{AC000000-AC00-AC00-AC00-100000000008} /ve /t REG_SZ /d “USB 视频设备” /f</p>
<p>:: 判断执行状态<br>IF /I %errorlevel% EQU 0 (<br>    ECHO 操作已成功完成..<br>) ELSE (<br>    IF /I %errorlevel% EQU 1 (<br>        ECHO 请尝试使用管理员身份运行脚本程序.<br>    ) ELSE (<br>        IF /I %errorlevel% EQU 3 (<br>            ECHO 注册表文件 没有找到.<br>        ) ELSE (<br>            ECHO 出现未知错误.)<br>    )<br>)<br>ECHO.<br>ECHO ━━━━━━━━━━━━━━━━━━━━━━</p>
<p>:: 结束<br>GOTO END</p>
<p>:uninstall<br>ECHO.<br>ECHO ▁▂▃▄▅▆▇█ 删除摄像头软件 █▇▆▅▄▃▂▁<br>ECHO.<br>:: 删除文件<br>ECHO 正在删除摄像头软件…<br>ECHO 卸载位置 %dir%<br>RMDIR /S /Q %dir%<br>ECHO.<br>ECHO ━━━━━━━━━━━━━━━━━━━━━━</p>
<p>ECHO.<br>ECHO ▁▂▃▄▅▆▇█ 清理注册表 █▇▆▅▄▃▂▁<br>ECHO.<br>:: 删除注册表<br>REM ECHO 正在清理注册表残留…<br>REM ECHO Windows Registry Editor Version 5.00 &gt; %TEMP%\%T%\remove.reg<br>REM ECHO. &gt;&gt; %TEMP%\%T%\remove.reg<br>REM ECHO [-HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{AC000000-AC00-AC00-AC00-100000000008}] &gt;&gt; %TEMP%\%T%\remove.reg<br>REM ECHO. &gt;&gt; %TEMP%\%T%\remove.reg<br>REM ECHO [-HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{AC000000-AC00-AC00-AC00-100000000008}] &gt;&gt; %TEMP%\%T%\remove.reg</p>
<p>REM :: 导入注册表文件<br>REM regedit /s %TEMP%\%T%\remove.reg</p>
<p>REG DELETE HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{AC000000-AC00-AC00-AC00-100000000008} /f<br>REG DELETE HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\{AC000000-AC00-AC00-AC00-100000000008} /f</p>
<p>:: 判断执行状态<br>REM IF /I %errorlevel% EQU 0 (<br>    REM ECHO 操作已成功完成..<br>REM ) ELSE (<br>    REM IF /I %errorlevel% EQU 1 (<br>        REM ECHO 请尝试使用管理员身份运行脚本程序.<br>    REM ) ELSE (<br>        REM IF /I %errorlevel% EQU 3 (<br>            REM ECHO 注册表文件 没有找到.<br>        REM ) ELSE (<br>            REM ECHO 出现未知错误.)<br>    REM )<br>REM )<br>ECHO.<br>ECHO ━━━━━━━━━━━━━━━━━━━━━━</p>
<p>:: 结束标签<br>:END<br>:: 等待按键继续<br>ECHO ……………………………………………………………..<br>echo 操作完毕.<br>pause&gt;nul</p>
<p><a href="https://cdn.fesugar.com/2019/03/2019-03-31-01060131.zip" target="_blank" rel="noopener">第三方摄像头_脚本.zip</a></p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>CMD</tag>
        <tag>Windows</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CMD 脚本带参数运行</title>
    <url>/zh-CN/2019/01/13/cmd-e8-84-9a-e6-9c-ac-e5-b8-a6-e5-8f-82-e6-95-b0-e8-bf-90-e8-a1-8c.html</url>
    <content><![CDATA[<p>CMD 脚本加参数运行示例</p>
<p>@echo off<br>SET DIR=%~dp0%<br>SET ARGS=%*<br>if NOT ‘%1’==’’ SET ARGS=%ARGS:”=\“%<br>if ‘%1’==’/?’ goto usage<br>if ‘%1’==’-?’ goto usage<br>if ‘%1’==’?’ goto usage<br>if ‘%1’==’/help’ goto usage<br>if ‘%1’==’help’ goto usage</p>
<p>@PowerShell -NonInteractive -NoProfile -ExecutionPolicy Bypass -Command ^<br> “&amp; Import-Module ‘%DIR%..\Pester.psm1’;  &amp; { Invoke-Pester -EnableExit %ARGS%}”</p>
<p>goto finish<br>:usage<br>if NOT ‘%2’==’’ goto help</p>
<p>echo To run pester for tests, just call pester or runtests with no arguments<br>echo.<br>echo Example: pester<br>echo.<br>echo For Detailed help information, call pester help with a help topic. See<br>echo help topic about_Pester for a list of all topics at the end<br>echo.<br>echo Example: pester help about_Pester<br>echo.<br>goto finish</p>
<p>:help<br>@PowerShell -NonInteractive -NoProfile -ExecutionPolicy Bypass -Command ^<br>  “&amp; Import-Module ‘%DIR%..\Pester.psm1’; &amp; { Get-Help %2}”</p>
<p>:finish<br>exit /B %errorlevel%</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>CMD</tag>
        <tag>Windows</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CMD 获取 WinRE 状态</title>
    <url>/zh-CN/2019/01/13/cmd-e8-8e-b7-e5-8f-96-winre-e7-8a-b6-e6-80-81.html</url>
    <content><![CDATA[<p>查询 bcdedit /enum 启动项的 ‘recoveryenabled’ 字段判断 Windows RE 开启状态</p>
<p>@echo off<br> for /f “tokens=1,2 delims= “ %%i in (‘bcdedit /enum’) do (<br>  if /i ‘%%i’==’recoveryenabled’ (<br>    if /i ‘%%j’==’yes’ (echo [%time%][%<del>n0] WinRE is Enabled&amp; exit /b 0)<br>  )<br> )<br> echo [%time%][%</del>n0] WinRE is Disabled<br> exit /b 1</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>CMD</tag>
        <tag>Windows</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>csharp 不出现在任务栏上的程序</title>
    <url>/zh-CN/2019/04/14/csharp-e4-b8-8d-e5-87-ba-e7-8e-b0-e5-9c-a8-e4-bb-bb-e5-8a-a1-e6-a0-8f-e4-b8-8a-e7-9a-84-e7-a8-8b-e5-ba-8f.html</url>
    <content><![CDATA[<h2 id="不出现在任务栏上的程序"><a href="#不出现在任务栏上的程序" class="headerlink" title="不出现在任务栏上的程序"></a>不出现在任务栏上的程序</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>一般的Windows应用程序启动后，系统会在任务栏中添加一个工具按钮，表示程序正在运行，该按钮中的文字就是程序或窗口的标题名称。但是一些黑客程序和一些系统程序在启动后，任务栏中不会出现这些程序的按钮，这样的程序通常在后台运行，有时用户根本不会察觉，那么这是怎么实现的呢？本实例将介绍如何控制程序是否显示在任务栏中。运行结果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/04/2019-04-14-14112010.png" alt=""> 图1 不出现在任务栏上的程序</p>
<h3 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h3><p>本实例通过使用Form类的ShowInTaskbar属性来控制程序是否显示在任务栏中。ShowInTaskbar属性用来获取或设置一个值，该值指示是否在Windows任务栏中显示窗体。其语法格式如下： public bool ShowInTaskbar { get; set; } 属性值：如果为True，则运行时在Windows任务栏中显示窗体，否则为False。默认为True。</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>（1）新建一个Windows应用程序，将其命名为“不出现在任务栏上的程序”，默认主窗体为Form1。 （2）在Form1窗体中添加两个RadioButton控件，用来控制程序图标是否出现在任务栏中。 （3）主要程序代码。</p>
<p>private void Form1_Load(object sender, EventArgs e)<br>{<br>    if (radioButton1.Checked)                            //如果选中radioButton1<br>        this.ShowInTaskbar = true;                        //将ShowInTaskbar属性设为true，在任务栏显示<br>    else                                                //否则<br>        this.ShowInTaskbar = false;                        //将ShowInTaskbar属性设为false，不在任务栏显示<br>}</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>csharp 使用正则表达式验证URL</title>
    <url>/zh-CN/2019/04/14/csharp-e4-bd-bf-e7-94-a8-e6-ad-a3-e5-88-99-e8-a1-a8-e8-be-be-e5-bc-8f-e9-aa-8c-e8-af-81url.html</url>
    <content><![CDATA[<h2 id="使用正则表达式验证URL"><a href="#使用正则表达式验证URL" class="headerlink" title="使用正则表达式验证URL"></a>使用正则表达式验证URL</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在浏览网页时，可以在浏览器的地址栏中输入网址信息并按下<Enter>键跳转到指定网页，如果用户输入的网址不正确，则无法显示网页信息。实例中使用了正则表达式判断用户输入的网址信息是否正确。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/04/2019-04-14-13582411.png" alt=""> 图1 使用正则表达式验证URL  </p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍怎样使用正则表达式验证URL，下面对其进行详细讲解。 实例中主要用到了Regex类的IsMatch方法，此方法的使用已经在实例“使用正则表达式验证电话号码”中进行了详细讲解。下面对实例中使用的正则表达式进行详细讲解。 从图2中可以看到，详细的描述了”http(s)?://([\w-]+\.)+[\w-]+(/[\w- ./?%&amp;=]<em>)?”正则表达式，其中http(s)?表示匹配字符串“http”或“https”；[\w-]+\.表示匹配一个或多个以单词字符和连接符号“-”组成的字符串开头的，以字符“.”结尾的字符串；(/[\w- ./?%&amp;=]</em>)?表示匹配出现零次或一次由单词字符“-”、“/”、“.”、“?”、“%”、“&amp;”、“=”组成的长度至少为1的字符串。 图2 正则表达式</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为ValidateURL。 （2）更改默认窗体Form1的Name属性为Frm_Main，向窗体中添加一个TextBox控件，用于输入网址；添加一个Button按钮，用于验证网址格式是否正确。 （3）程序主要代码如下：</p>
<p>public bool IsUrl(string str_url)</p>
<p>{</p>
<pre><code>return System.Text.RegularExpressions.Regex.IsMatch(str_url,                                                  //使用正则表达式判断是否匹配</code></pre><p>@”http(s)?://([\w-]+\.)+[\w-]+(/[\w- ./?%&amp;=]*)?”);</p>
<p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title=" 秘笈心法"></a><img data-src="https://cdn.fesugar.com/2019/04/2019-04-14-13584214.png" alt=""> 秘笈心法</h3><p>心法领悟058：使用正则表达式验证用户名格式是否正确！ 程序运行过程中，经常需要用户注册信息，以得到相应的操作权限，如果在用户注册的过程中，用户添写的用户名格式不正确，有可能会带来不必要的麻烦，使用正则表达式验证用户名格式将是一种不错的选择！</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>csharp 利用图片对文件进行加密与解密</title>
    <url>/zh-CN/2019/04/16/csharp-e5-88-a9-e7-94-a8-e5-9b-be-e7-89-87-e5-af-b9-e6-96-87-e4-bb-b6-e8-bf-9b-e8-a1-8c-e5-8a-a0-e5-af-86-e4-b8-8e-e8-a7-a3-e5-af-86.html</url>
    <content><![CDATA[<h2 id="利用图片对文件进行加密与解密"><a href="#利用图片对文件进行加密与解密" class="headerlink" title="利用图片对文件进行加密与解密"></a>利用图片对文件进行加密与解密</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例在加密时，使用指定的图片生成加密密钥，然后对文本文件进行加密；在解密时，使用加密时的图片生成解密密钥，然后对加密的文本文件进行解密。在本实例的窗体中，首先打开一个图片，用来生成加密或解密的密钥，然后选择要加密或解密的文本文件，最后点击“加密”或“解密”按钮，实现对文本文件的加密或解密。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/04/2019-04-16-02535056.png" alt=""> 图1 利用图片对文件进行加密与解密</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>实现本实例，主要用到了RC2CryptoServiceProvider类、BinaryWriter类的Write方法、File类的Delete方法和Copy方法分别进行介绍。 （1）RC2CryptoServiceProvider类 该类定义访问RC2算法的加密服务提供程序（CSP）实现的包装对象，无法继承此类。 （2）BinaryWriter类 该类以二进制形式将基元类型写入流，并支持用特定的编码写入字符串。它的构造器语法格式如下： public BinaryWriter (Streamoutput) 参数说明 output：表示输出流。 （3）BinaryWriter类的Write方法 该方法将一个无符号字节写入当前流，并将流的位置提升一个字节。其语法格式如下： public virtual void Write (byte value) 参数说明 value：表示要写入的无符号字节。 （4）File类 该类提供用于创建、复制、删除、移动和打开文件的静态方法，并协助创建FileStream对象，该类是个静态类。 （5）File类的Delete方法 该方法删除指定的文件。如果指定的文件不存在，则引发异常。其语法格式如下： public static void Delete (string path) 参数说明 path：表示要删除的文件的名称。 （6）File类的Copy方法 该方法将现有文件复制到新文件，不允许改写同名的文件。其语法格式如下： public static void Copy (string sourceFileName,string destFileName) 参数说明 sourceFileName：要复制的文件。 destFileName：目标文件的名称，不能是一个目录或现有文件。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为EncryptTextFileTwo。 （2）在Form1窗体中，主要添加一个TextBox控件，用来显示加密或解密文件的路径；添加一个OpenFileDialog控件，用来选择要加密或解密的文件和打开密钥的图片；添加4个Button控件，用来执行加密、解密、打开文件和打开图片操作；添加一个PictureBox控件，用于显示密钥图片。 （3）程序主要代码如下： 单击“加密”按钮实现利用图片对文本文件进行加密，“加密”按钮的Click事件代码如下：</p>
<p>private void button3_Click(object sender, EventArgs e)<br>{<br>    try<br>    {<br>        if (pictureBox1.ImageLocation==null)                            //判断是否选择了图片<br>        { MessageBox.Show(“请选择一幅图片用于加密”); return; }            //如果没有选择则弹出提示<br>        if (textBox1.Text == “”)                                    //若未选择需要加密的文件<br>        { MessageBox.Show(“请选择加密文件路径”); return; }                //如果没有选择则弹出提示<br>        //图片流<br>        FileStream fsPic = new FileStream(pictureBox1.ImageLocation, FileMode.Open, FileAccess.Read);<br>        //加密文件流<br>        FileStream fsText = new FileStream(textBox1.Text, FileMode.Open, FileAccess.Read);<br>        //初始化对称算法的密钥和向量<br>        byte[] bykey = new byte[16];                                //定义存储密钥的字节数组<br>        byte[] byIv = new byte[8];                                //定义存储向量的字节数组<br>        fsPic.Read(bykey, 0, 16);                                //把图片流写入密钥缓冲区<br>        fsPic.Read(byIv, 0, 8);                                    //把图片流写入向量缓冲区<br>        //临时加密文件<br>        string strPath = textBox1.Text;                                //加密文件的路径<br>        int intLent = strPath.LastIndexOf(“\&quot;) + 1;<br>        int intLong = strPath.Length;<br>        string strName = strPath.Substring(intLent, intLong - intLent);            //要加密的文件名称<br>        string strLinPath = “C:\&quot; + strName;                            //临时加密文件路径<br>        FileStream fsOut = File.Open(strLinPath, FileMode.Create, FileAccess.Write);<br>        //开始加密，首先创建RC2CryptoServiceProvider对象<br>        RC2CryptoServiceProvider desc = new RC2CryptoServiceProvider();<br>        BinaryReader br = new BinaryReader(fsText);                    //创建BinaryReader对象<br>        //创建CryptoStream对象，用于写入临时加密文件<br>        CryptoStream cs = new CryptoStream(fsOut, desc.CreateEncryptor(bykey, byIv), CryptoStreamMode.Write);<br>        cs.Write(br.ReadBytes((int)fsText.Length), 0, (int)fsText.Length);            //写入加密流<br>        cs.FlushFinalBlock();<br>        cs.Flush();<br>        cs.Close();<br>        fsPic.Close();<br>        fsText.Close();<br>        fsOut.Close();<br>        File.Delete(textBox1.Text.TrimEnd());                            //删除原文件<br>        File.Copy(strLinPath, textBox1.Text);                            //复制加密文件<br>        File.Delete(strLinPath);                                    //删除临时文件<br>        MessageBox.Show(“加密成功”);<br>        pictureBox1.ImageLocation = null;<br>        textBox1.Text = “”;<br>    }<br>    catch (Exception ee)<br>    {<br>        MessageBox.Show(ee.Message);<br>    }<br>}<br>单击“解密”按钮实现利用图片对加密的文本文件进行解密，“解密”按钮的Click事件代码如下：<br>private void button4_Click(object sender, EventArgs e)<br>{<br>    try<br>    {<br>        //图片流<br>        FileStream fsPic = new FileStream(pictureBox1.ImageLocation, FileMode.Open, FileAccess.Read);<br>        //解密文件流<br>        FileStream fsOut = File.Open(textBox1.Text, FileMode.Open, FileAccess.Read);<br>        //初始化对称算法的密钥和向量<br>        byte[] bykey = new byte[16];                                //定义存储密钥的字节数组<br>        byte[] byIv = new byte[8];                                //定义存储向量的字节数组<br>        fsPic.Read(bykey, 0, 16);                                //把图片流写入密钥缓冲区<br>        fsPic.Read(byIv, 0, 8);                                    //把图片流写入向量缓冲区<br>        //创建临时解密文件<br>        string strPath = textBox1.Text;                                //加密文件的路径<br>        int intLent = strPath.LastIndexOf(“\&quot;) + 1;                        //获取不含文件名的路径长度<br>        int intLong = strPath.Length;                                //获取含文件名的路径长度<br>        //获取要解密文件的名称，即加密文件的名称<br>        string strName = strPath.Substring(intLent, intLong - intLent);<br>        string strLinPath = “C:\&quot; + strName;                            //临时解密文件路径<br>        FileStream fs = new FileStream(strLinPath, FileMode.Create, FileAccess.Write);<br>        //开始解密，首先创建RC2CryptoServiceProvider对象<br>        RC2CryptoServiceProvider desc = new RC2CryptoServiceProvider();<br>        //创建CryptoStream对象，用于读取加密文件<br>        CryptoStream csDecrypt = new CryptoStream(fsOut, desc.CreateDecryptor(bykey, byIv), CryptoStreamMode.Read);<br>        BinaryReader sr = new BinaryReader(csDecrypt);                    //创建BinaryReader对象<br>        BinaryWriter sw = new BinaryWriter(fs);                        //创建BinaryWriter对象<br>        sw.Write(sr.ReadBytes(Convert.ToInt32(fsOut.Length)));                //写入解密流<br>        sw.Flush();<br>        sw.Close();<br>        sr.Close();<br>        fs.Close();<br>        fsOut.Close();<br>        fsPic.Close();<br>        csDecrypt.Flush();<br>        File.Delete(textBox1.Text.TrimEnd());                            //删除原文件<br>        File.Copy(strLinPath, textBox1.Text);                            //复制加密文件<br>        File.Delete(strLinPath);                                    //删除临时文件<br>        MessageBox.Show(“解密成功”);                            //弹出提示信息<br>        pictureBox1.ImageLocation = null;                            //清空图片<br>        textBox1.Text = “”;                                    //清空文本框<br>    }<br>    catch (Exception ee)                                        //如果出现异常<br>    {<br>        MessageBox.Show(ee.Message);                            //输出异常<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟002：使用CryptoStream类的FlushFinalBlock方法。 在调用CryptoStream类的Write方法写入加密或解密流之后，需要调用该类的FlushFinalBlock方法，该方法实现用缓冲区的当前状态更新基础数据源或储存库，随后清除缓冲区。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>csharp 利用多饼型图分析企业人力资源情况</title>
    <url>/zh-CN/2019/04/16/csharp-e5-88-a9-e7-94-a8-e5-a4-9a-e9-a5-bc-e5-9e-8b-e5-9b-be-e5-88-86-e6-9e-90-e4-bc-81-e4-b8-9a-e4-ba-ba-e5-8a-9b-e8-b5-84-e6-ba-90-e6-83-85-e5-86-b5.html</url>
    <content><![CDATA[<h2 id="利用多饼型图分析企业人力资源情况"><a href="#利用多饼型图分析企业人力资源情况" class="headerlink" title="利用多饼型图分析企业人力资源情况"></a>利用多饼型图分析企业人力资源情况</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>开发企业人力资源管理系统时，经常使用饼型图分析企业中各个阶层的人员情况，为了让用户更清晰地认识，本实例采用了多饼图表示法实现分析功能。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/04/2019-04-16-02594662.png" alt=""> 图1 利用多饼型图分析企业人力资源情况  </p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现时，首先通过SQL语句分别统计企业总人数和各个阶层人数，然后通过统计的比例绘制饼型图，实现过程中主要用到Graphics类的DrawLine方法、DrawString方法和FillPie方法。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为MultiCAnalyseHR。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个Panel控件，用来显示绘制的多个饼型图。 （3）程序主要代码如下：</p>
<p>private void ShowPic(int Sum)<br>{<br>    using (cmd = new SqlCommand(“select t_Point,sum(t_Num) from tb_manpower group by t_Point order by sum(t_Num) desc”, con))<br>    {<br>        Bitmap bmp = new Bitmap(this.panel1.Width, this.panel1.Height);                    //创建画布<br>        Graphics g = Graphics.FromImage(bmp);                                //创建Graphics对象<br>        cmd.Connection.Open();<br>        SqlDataReader dr = cmd.ExecuteReader();                                //创建SqlDataReader对象<br>        while (dr.Read())                                                //开始读取记录<br>        {<br>            float f = Convert.ToSingle(dr[1]) / Sum;<br>            string str = dr[0].ToString();<br>            drowPic(g, f, str);                                            //调用drowPic方法绘制饼图<br>        }<br>        //绘制线条<br>        g.DrawLine(new Pen(Color.Black), 0, this.panel1.Height / 2, this.panel1.Width, this.panel1.Height / 2);<br>        g.DrawLine(new Pen(Color.Black), this.panel1.Width / 2, 0, this.panel1.Width / 2, this.panel1.Height);<br>        this.panel1.BackgroundImage = bmp;                                    //显示绘制的图形<br>        dr.Close();                                                    //关闭SqlDataReader对象<br>        con.Close();                                                //关闭数据库连接<br>    }<br>}<br>private void drowPic(Graphics g, float f, string str)                                 //根据要求绘制饼图<br>{<br>    if (ConutNum == 0)                                                //如果ConutNum为0时执行<br>    {<br>        //绘制扇形<br>        g.FillPie(new SolidBrush(Color.Black), 0, 0, (this.panel1.Width) / 2, (this.panel1.Height - 10) / 2, 0, 360 * f);<br>//绘制文本<br>        g.DrawString(str, new Font(“宋体”, 10, FontStyle.Bold), new SolidBrush(Color.Black), (this.panel1.Width) / 2 - 70, 10);<br>        g.DrawString(Convert.ToString(f * 100).Substring(0, 5) + “%”, new Font(“宋体”, 10, FontStyle.Bold), new SolidBrush(Color.Black), (this.panel1.Width) / 2 - 70, 25);                                            //绘制文本<br>       floatNum = 360 * f;                                            //计算角度<br>       ConutNum += 1;                                                //使ConutNum为1<br>   }<br>   else if (Conu tNum == 1)                                            //如果ConutNum为1时执行<br>   {<br>//绘制扇形<br>g.FillPie(new SolidBrush(Color.DarkOrange), (this.panel1.Width) / 2, 0, (this.panel1.Width) / 2, (this.panel1.Height - 10) / 2, floatNum, 360 * f);<br>//绘制文本<br>       g.DrawString(str, new Font(“宋体”, 10, FontStyle.Bold), new SolidBrush(Color.DarkOrange), (this.panel1.Width) / 2 + 10, 10);<br>       g.DrawString(Convert.ToString(f * 100).Substring(0, 5) + “%”, new Font(“宋体”, 10, FontStyle.Bold), new SolidBrush(Color.DarkOrange), (this.panel1.Width) / 2 + 10, 25);                                            //绘制文本<br>        floatNum += 360 * f;                                            //计算角度<br>        ConutNum += 1;                                                // ConutNum为2<br>    }<br>    else if (ConutNum == 2)                                            // ConutNum为2时执行<br>    {<br>        g.FillPie(new SolidBrush(Color.Red), 0, (this.panel1.Height - 10) / 2 + 10, (this.panel1.Width) / 2, (this.panel1.Height - 10) / 2, floatNum, 360 * f);                                                            //绘制扇形<br>//绘制文本<br>        g.DrawString(str, new Font(“宋体”, 10, FontStyle.Bold), new SolidBrush(Color.Red), 10, (this.panel1.Height - 10) / 2 + 20);<br>        g.DrawString(Convert.ToString(f * 100).Substring(0, 5) + “%”, new Font(“宋体”, 10, FontStyle.Bold), new SolidBrush(Color.Red), 10, (this.panel1.Height - 10) / 2 + 35);                                            //绘制文本<br>        floatNum += 360 * f;                                            //计算角度<br>        ConutNum += 1;                                                // ConutNum为3<br>    }<br>    else if (ConutNum == 3)                                            // ConutNum为3时执行<br>    {<br>        g.FillPie(new SolidBrush(Color.Blue), (this.panel1.Width) / 2 - 10, (this.panel1.Height - 10) / 2 + 10, (this.panel1.Width) / 2, (this.panel1.Height - 10) / 2, floatNum, 360 * f);                                            //绘制扇形<br>        g.DrawString(str, new Font(“宋体”, 10, FontStyle.Bold), new SolidBrush(Color.Blue), (this.panel1.Width) / 2 + 10, (this.panel1.Height - 10) / 2 + 20);                                                            //绘制文本<br>        g.DrawString(Convert.ToString(f * 100).Substring(0, 5) + “%”, new Font(“宋体”, 10, FontStyle.Bold), new SolidBrush(Color.Blue), (this.panel1.Width) / 2 + 10, (this.panel1.Height - 10) / 2 + 35);                         //绘制文本<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟014：绘制多饼型图的实现原理！ 绘制多饼型图时，首先需要计算各个部分所占的比例，然后依次绘制各个部分在饼型图中所占的比例，在绘制过程中，从第一部分首先开始绘制，绘制结束后，记录其绘制的扇形结束位置，并以该位置为起点，开始绘制第二部分，依次类推，直到绘制完最后一部分，这样就实现了绘制多饼型图的功能。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>csharp 利用饼型图分析产品市场占有率</title>
    <url>/zh-CN/2019/04/16/csharp-e5-88-a9-e7-94-a8-e9-a5-bc-e5-9e-8b-e5-9b-be-e5-88-86-e6-9e-90-e4-ba-a7-e5-93-81-e5-b8-82-e5-9c-ba-e5-8d-a0-e6-9c-89-e7-8e-87.html</url>
    <content><![CDATA[<h2 id="利用饼型图分析产品市场占有率"><a href="#利用饼型图分析产品市场占有率" class="headerlink" title="利用饼型图分析产品市场占有率"></a>利用饼型图分析产品市场占有率</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>开发商品销售管理系统过程中，为了清晰了解产品在市场上的占有率，使用饼图分析产品市场占有率是最佳的选择。本实例通过利用饼型图分析某电子产品市场占有率，实例运行效果如图1所示。 图1 利用饼型图分析产品市场占有率</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现时，首先通过SQL语句统计商品在市场的占有率，并将其字段名与数量存放于Hashtable哈希表中，然后遍历“哈希表”计算出每种商品所占的比例，最后通过Graphics类的FillPie方法绘制饼型图。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为CAnalyseGoodsScale。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个Panel控件，分别用来显示绘制的饼型图和说明信息。 （3）程序主要代码如下：</p>
<p>private void showPic(float f,Brush B)<br>{<br>    Graphics g = this.panel1.CreateGraphics();                        //通过panel1控件创建一个Graphics对象<br>    if (TimeNum == 0.0f)<br>    {<br>        g.FillPie(B, 0, 0, this.panel1.Width, this.panel1.Height, 0, f * 360);//绘制扇形<br>    }<br>    else<br>    {<br>        g.FillPie(B, 0, 0, this.panel1.Width, this.panel1.Height, TimeNum, f * 360);<br>    }<br>    TimeNum += f * 360;<br>}<br>private void Form1_Paint(object sender, PaintEventArgs e)                //在Paint事件中绘制窗体<br>{<br>    ht.Clear();<br>    Conn();                                            //连接数据库<br>    Random rnd = new Random();                            //生成随机数<br>    using (cmd = new SqlCommand(“select t_Name,sum(t_Num) as Num  from tb_14 group by t_Name”, con))<br>    {<br>        Graphics g2 = this.panel2.CreateGraphics();                    //通过panel2控件创建一个Graphics对象<br>        SqlDataReader dr = cmd.ExecuteReader();                    //创建SqlDataReader对象<br>        while (dr.Read())                                    //读取数据<br>        {<br>            ht.Add(dr[0],Convert.ToInt32(dr[1]));                    //将数据添加到Hashtable中<br>        }<br>        float[] flo = new float[ht.Count];<br>        int T = 0;<br>        foreach (DictionaryEntry de in ht)                        //遍历Hashtable<br>        {<br>            flo[T] = Convert.ToSingle((Convert.ToDouble(de.Value) / SumNum).ToString().Substring(0, 6));<br>Brush Bru = new SolidBrush(Color.FromArgb(rnd.Next(255), rnd.Next(255), rnd.Next(255)));<br>//绘制商品及百分比<br>            g2.DrawString(de.Key + “  “ + flo[T] * 100 + “%”, new Font(“Arial”, 8, FontStyle.Regular), Bru, 7, 5 + T * 18);<br>            showPic(flo[T], Bru);                            //调用showPic方法绘制饼型图<br>            T++;<br>        }<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟013：使用Paint事件实现窗体或控件的重绘！ 当重绘窗体或控件时会引发其Paint事件，该事件将PaintEventArgs的实例传递给用来处理Paint事件的方法，从而实现窗体或控件的重绘。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>csharp 利用饼型图分析公司男女比率</title>
    <url>/zh-CN/2019/04/16/csharp-e5-88-a9-e7-94-a8-e9-a5-bc-e5-9e-8b-e5-9b-be-e5-88-86-e6-9e-90-e5-85-ac-e5-8f-b8-e7-94-b7-e5-a5-b3-e6-af-94-e7-8e-87.html</url>
    <content><![CDATA[<h2 id="利用饼型图分析公司男女比率"><a href="#利用饼型图分析公司男女比率" class="headerlink" title="利用饼型图分析公司男女比率"></a>利用饼型图分析公司男女比率</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>开发人力资源管理系统时，利用饼图分析公司男女比例是最佳的选择。本实例对某公司的男女比例使用饼型图进行分析，实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/04/2019-04-16-03064288.png" alt=""> 图1 利用饼型图分析公司男女比率</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时主要用到了Graphics类的FillEllipse方法和FillPie方法，下面分别对它们进行详细讲解。 （1）FillEllipse方法 该方法用于填充Rectangle结构指定的边框所定义的椭圆的内部，其语法格式如下： public void FillEllipse(Brush brush,Rectangle rect) 参数说明 brush：确定填充特性的 Brush。 rect：Rectangle结构，它表示定义椭圆的边框。 （2）FillPie方法 该方法用于填充椭圆所定义的扇形区的内部，该椭圆由Rectangle结构和两条射线指定，其语法格式如下： public void FillPie(Brush brush,Rectangle rect,float startAngle,float sweepAngle) FillPie方法语法中的参数及说明如表1所示。 表1 FillPie方法语法中的参数及说明</p>
<p>参数</p>
<p>说明</p>
<p>brush</p>
<p>确定填充特性的Brush</p>
<p>rect</p>
<p>Rectangle结构，它表示定义该扇形区所属的椭圆的边框</p>
<p>startAngle</p>
<p>从x轴沿顺时针方向旋转到扇形区第一个边所测得的角度（以度为单位）</p>
<p>sweepAngle</p>
<p>从startAngle参数沿顺时针方向旋转到扇形区第二个边所测得的角度（以度为单位）</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为CAnalyseSex。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个Panel控件，分别用来显示绘制的饼型图和说明信息。 （3）程序主要代码如下：</p>
<p>private void ShowPic(string SexCode,float f)<br>{<br>    Graphics g = this.panel1.CreateGraphics();                    //通过panel1控件创建一个Graphics对象<br>    Pen p=new Pen(new SolidBrush(Color.Blue));                //创建画笔<br>    Point p1=new Point(0,0);                            //创建Point对象<br>    Size s=new Size(this.panel1.Width,this.panel1.Height);            //创建Size对象<br>    Rectangle trct = new Rectangle(p1, s);                    //创建Rectangle对象<br>    g.FillEllipse(new SolidBrush(Color.Red), trct);                //绘制椭圆<br>    g.FillPie(new SolidBrush(Color.Blue), trct, 180, f*360);            //绘制扇形<br>    Graphics ginfo = this.panel2.CreateGraphics();                //通过panel2控件创建一个Graphics对象<br>    Font font=new Font(“宋体”,10,FontStyle.Regular);            //设置字体<br>//绘制性别<br>    ginfo.DrawString(SexCode +” “+f.ToString().Substring(0,4), font, new SolidBrush(Color.Blue), 0, 5);<br>    ginfo.DrawString(“女” + “ “ + (1.0 - Convert.ToDouble(f.ToString().Substring(0, 4))).ToString().Substring(0, 4), font, new SolidBrush(Color.Red), 0, 25);                                            //绘制比例<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟012：使用Color结构获取颜色。 Color结构表示一种ARGB颜色（alpha、红色、绿色、蓝色），现在已经命名的颜色都可以使用Color结构的属性来表示，例如，蓝色可以用Color.Blue来表示。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp 制作一个可以旋转的饼型图</title>
    <url>/zh-CN/2019/04/14/csharp-e5-88-b6-e4-bd-9c-e4-b8-80-e4-b8-aa-e5-8f-af-e4-bb-a5-e6-97-8b-e8-bd-ac-e7-9a-84-e9-a5-bc-e5-9e-8b-e5-9b-be.html</url>
    <content><![CDATA[<h2 id="制作一个可以旋转的饼型图"><a href="#制作一个可以旋转的饼型图" class="headerlink" title="制作一个可以旋转的饼型图"></a>制作一个可以旋转的饼型图</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>通过本实例绘制的饼型图可以直观的显示公司员工的性别比例，而且还可以通过单击“旋转”按钮使饼型图旋转起来。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/04/2019-04-14-13334715.png" alt=""> 图1 制作一个可以旋转的饼型图  </p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现时，首先通过Graphics类的FillEllipse方法和FillPie方法绘制饼型图，然后通过使用Timer组件控制饼型图的旋转。下面对本实例中用到的关键技术进行详细讲解。 Timer组件表示一个计时器，它可以按用户定义的时间间隔来引发事件，引发的事件一般为周期性的，每隔若干秒或若干毫秒执行一次，其常用的属性、方法及事件如表1所示。 表1 Timer组件的常用属性、方法及事件</p>
<p>属性、方法及事件</p>
<p>说明</p>
<p>Enabled属性</p>
<p>获取或设置计时器是否正在运行</p>
<p>Interval属性</p>
<p>获取或设置在相对于上一次发生的Tick事件引发Tick事件之前的时间（以毫秒为单位）</p>
<p>Start方法</p>
<p>启动计时器</p>
<p>Stop方法</p>
<p>停止计时器</p>
<p>Tick事件</p>
<p>当指定的计时器间隔已过去而且计时器处于启用状态时发生</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为RoundCaky。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个Panel控件，分别用来显示表示男女比例的饼型图和说明信息；添加两个Button控件，分别用来执行绘制饼型图和旋转饼型图操作；添加一个Timer组件，用来控制饼型图的旋转与停止。 （3）程序主要代码如下：</p>
<p>private void ShowPic(string SexCode, float f)// ShowPic方法用来绘制饼图<br>{<br>    this.Controls.Add(panel1);//将Panel控件添加到窗体中<br>    panel1.Width = 230;//设置Panel控件的宽度<br>    panel1.Height = 230;//设置Panel控件的高度<br>    bt = new Bitmap(panel1.Width,panel1.Height);//创建画布<br>    Graphics g = Graphics.FromImage(bt);//创建Graphics对象<br>    Pen p = new Pen(new SolidBrush(Color.Blue));//创建画笔<br>    Point p1 = new Point(0, 0);//创建一个Point对象<br>    Size s = new Size(this.panel1.Width, this.panel1.Height);//创建Size对象<br>    Rectangle trct = new Rectangle(p1, s);//创建Rectangle对象<br>    g.FillEllipse(new SolidBrush(Color.Red), trct);//绘制椭圆<br>    g.FillPie(new SolidBrush(Color.Blue), trct, flag, f * 360);//绘制扇形<br>    bt1 = new Bitmap(panel2.Width,panel2.Height);//创建画布<br>    Graphics ginfo = Graphics.FromImage(bt1);//创建Graphics对象<br>    Font font = new Font(“宋体”, 10, FontStyle.Regular);//设置字体<br>    ginfo.DrawString(SexCode + “ “ + f.ToString().Substring(0, 4), font, new SolidBrush(Color.Blue), 0, 5);<br>    ginfo.DrawString(“女” + “ “ + (1.0 - Convert.ToDouble(f.ToString().Substring(0, 4))).ToString().Substring(0, 4), font, new SolidBrush(Color.Red), 0, 25);                                                                                                                                                                                                                  //绘制性别及比率<br>    panel1.BackgroundImage = bt;//显示饼图<br>    panel2.BackgroundImage = bt1;//显示性别及比率<br>}<br>private void button1_Click(object sender, EventArgs e)//单击“显示”按钮显示饼图<br>{<br>    Conn();//连接数据库<br>    using (cmd = new SqlCommand(“SELECT sex,COUNT(sex) num FROM tb_sex group by sex”, con))<br>    {<br>        SqlDataReader dr = cmd.ExecuteReader();//创建SqlDataReader对象<br>        string[] str = new string[2];<br>        int i = 0;<br>        while (dr.Read())//读取记录<br>        {<br>            str[i] = dr[0].ToString() + “,” + dr[1].ToString();//获取数据库中存储的性别及比例<br>            i++;<br>        }<br>        float N = Convert.ToInt16(str[0].Substring(2)) + Convert.ToInt16(str[1].Substring(2));              //男女性别比例之和<br>        float f = Convert.ToInt16(str[0].Substring(2)) / N;//男性的比例<br>        flag = 180;//开始绘制的起始角度<br>        ShowPic(str[0].Substring(0, 1), f);//调用ShowPic方法绘制饼图<br>    }<br>    con.Close();<br>}<br>private void timer1_Tick(object sender, EventArgs e)//当单击“旋转”按钮时开始旋转饼图<br>{<br>    flag += 1;//每次转动一度<br>    Conn();//连接数据库<br>    using (cmd = new SqlCommand(“SELECT sex,COUNT(sex) num FROM tb_sex group by sex”, con))<br>    {<br>        SqlDataReader dr = cmd.ExecuteReader();//创建SqlDataReader对象<br>        string[] str = new string[2];//声明数组存储性别及比例<br>        int i = 0;<br>        while (dr.Read())<br>        {<br>            str[i] = dr[0].ToString() + “,” + dr[1].ToString();//获取数据库中存储的性别及比例<br>            i++;<br>        }<br>        float N = Convert.ToInt16(str[0].Substring(2)) + Convert.ToInt16(str[1].Substring(2));               //男女性别比例之和<br>        float f = Convert.ToInt16(str[0].Substring(2)) / N;//男性的比例<br>        ShowPic(str[0].Substring(0, 1), f);//调用ShowPic方法绘制饼图<br>    }<br>    con.Close();//关闭连接<br>}<br>private void button2_Click(object sender, EventArgs e)//“旋转”按钮<br>{<br>    if (button2.Text ==”旋转”)//如果按钮显示“旋转”文本<br>    {<br>        timer1.Start();//开始Timer控件<br>        button2.Text = “停止”;//将按钮的文本设为“停止”<br>    }<br>    else//如果按钮的文本为“停止”<br>    {<br>        timer1.Stop();//停止Timer控件<br>        button2.Text = “旋转”;//将按钮的文本设为“旋转”<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟016：Timer计时器组件的使用。 Timer组件是一个计时器组件，它主要用来按用户定义的时间间隔来引发事件，引发的事件一般为周期性的，每隔若干秒或若干毫秒执行一次。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>csharp 在饼型图的外围显示说明文字</title>
    <url>/zh-CN/2019/04/14/csharp-e5-9c-a8-e9-a5-bc-e5-9e-8b-e5-9b-be-e7-9a-84-e5-a4-96-e5-9b-b4-e6-98-be-e7-a4-ba-e8-af-b4-e6-98-8e-e6-96-87-e5-ad-97.html</url>
    <content><![CDATA[<h2 id="在饼型图的外围显示说明文字"><a href="#在饼型图的外围显示说明文字" class="headerlink" title="在饼型图的外围显示说明文字"></a>在饼型图的外围显示说明文字</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>饼型图可以很直观的显示一些信息的比例，如果信息过多则需要在饼型图上绘制说明文字，这样，才可以更好的了解饼型图所代表的含义。本实例使用C#实现了在饼型图的外围绘制说明文字的功能，实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/04/2019-04-14-13433265.png" alt=""> 图1 在饼型图的外围显示说明文字  </p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时主要使用Graphics 类的FillPie方法绘制饼型图，使用FillRectangle方法和DrawRectangle方法绘制说明文字的矩形框及矩形框的边，使用DrawString方法绘制说明文字。下面对本实例中用到的关键技术进行详细讲解。 DrawRectangle方法用于绘制由坐标对、宽度和高度指定的矩形，其语法格式如下： public void DrawRectangle(Pen pen,int x,int y,int width,int height) DrawRectangle方法语法中的参数及说明如表1所示。 表1 DrawRectangle方法语法中的参数及说明</p>
<p>参数</p>
<p>说明</p>
<p>pen</p>
<p>Pen，它确定矩形的颜色、宽度和样式</p>
<p>x</p>
<p>要绘制的矩形的左上角的x坐标</p>
<p>y</p>
<p>要绘制的矩形的左上角的y坐标</p>
<p>width</p>
<p>要绘制的矩形的宽度</p>
<p>height</p>
<p>要绘制的矩形的高度</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为TextInCaky。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个Panel控件，用来显示带有说明文字的饼型图。 （3）程序主要代码如下：</p>
<p>public void ProtractArea(Graphics g)                                              //绘制饼型图表</p>
<p>{</p>
<pre><code>AreaValue();                                                                  //计算最长说明文字的大小

mypen = new Pen(Color.Black, 1);                                                        //设置画笔的颜色及大小

float f = 0;                                                              //记录百分比

float TimeNum = 0;                                                        //扇形的绘制度数

float AXLeft = 0;                                                            //设置饼型图的X坐标

float AYUp = 0;                                                       //设置饼型图的Y坐标

float AXSize = 0;                                                            //设置饼型图的宽度

float AYSize = 0;                                                            //设置饼型图的高度

float Atop = 0;                                                               //记录饼型的高度为长和宽的最小值

float Aleft = 0;                                                               //记录饼型的高度为长和宽的最小值

TimeNum = AreaAngle;                                                  //设置饼型图的起始度数

//计算饼型图的初始位置

XLeft = panel1.Width - (panel1.Width - 5);                                            //去了边框后饼型图的X位置

XSize = panel1.Width - 10;                                                     //设置饼型图的宽度

temXLeft = AXLeft;                                                              //记录饼型图的X坐标

AXLeft = XLeft;                                                            //记录饼型图的X坐标

AXSize = XSize;                                                            //记录饼型图的宽度

//通过说明文字的大小计算饼型图的位置

AXLeft = AXLeft + AreaXMaxWidth + Aline;                                        //设置去除说明文字后的饼型图X坐标

AYUp = AYUp + AreaXMaxHeight;                                                //设置去除说明文字后的饼型图Y坐标

AXSize = XSize - AreaXMaxWidth * 2 - Aline * 2;                                 //设置去除说明文字后的饼型图宽度

AYSize = YSize - AreaXMaxHeight * 2;                                                 //设置去除说明文字后的饼型图高度

if (AXSize &gt;= AYSize)                                                    //如果饼型图的宽度大于等于高度

{

    Aleft = AXSize - AYSize;                                                //记录饼型图的X坐标

    AXSize = AYSize;                                                   //将高度设为宽度

}

else

{

    Atop = AYSize - AXSize;                                                //记录饼型图的Y坐标

    AYSize = AXSize;                                                   //将宽度设为高度

}

if (Aleft != 0)                                                                 //如果宽大于高

{

    AXLeft = AXLeft + Aleft / 2;                                                  //设置饼型图横向局中

}

if (Atop != 0)                                                                 //如果高大于宽

{

    AYUp = AYUp + Atop / 2;                                               //设置饼型图纵向局中

}

temXLeft = XLeft;

//绘制饼型图

if (AXSize &gt; 0 &amp;&amp; AYSize &gt; 0)                                              //如果饼型图的宽和高大于0

{

    for (int i = 0; i &lt; SzData.Length; i++)                                             //遍历数据

    {

        f = SzData\[i\] / ASum;                                              //获取当前数据的百分比

        //设置当前扇形图的填充颜色

        if (i &gt;= WearColor.Length)                                              //如果没有超出颜色数组

            mybrush = new SolidBrush(WearColor\[i - WearColor.Length\]);

        else

            mybrush = new SolidBrush(WearColor\[i\]);

        g.FillPie(mybrush, AXLeft, AYUp, AXSize, AYSize, TimeNum, f * 360);  //绘制扇形图

        TimeNum += f * 360;                                              //设置下一个扇形图的度数

    }

    ProAreaSign(g);                                                             //绘制饼型图的说明文字

}

else

    return;</code></pre><p>}</p>
<p>#endregion</p>
<p>#region 绘制饼型图标识(Area)</p>
<p>public void ProAreaSign(Graphics g)</p>
<p>{</p>
<pre><code>AreaValue();                                                                  //存储最长的名称

mypen = new Pen(Color.Black, 1);                                                        //设置画笔的颜色及大小

Font LSfont = new System.Drawing.Font(&quot;宋体&quot;, 8);                             //设置说明文字的字体样式

SolidBrush Zbrush = new SolidBrush(Color.Black);                                 //设置存放说明文字边框的画刷

SolidBrush ATbrush = new SolidBrush(Color.Khaki);                              //设置存放说明文字方块的背景画刷

float f = 0;                                                              //记录百分比

float TimeNum = 0;                                                        //扇形的绘制度数

float AXLeft = 0;                                                            //设置饼型图的X坐标

float AYUp = 0;                                                       //设置饼型图的Y坐标

float AXSize = 0;                                                            //设置饼型图的宽度

float AYSize = 0;                                                            //设置饼型图的高度

float Atop = 0;                                                               //记录饼型的高度为长和宽的最小值

float Aleft = 0;                                                               //记录饼型的高度为长和宽的最小值

Graphics TitG = panel1.CreateGraphics();                                              //创建Graphics对象

SizeF XMaxSize = TitG.MeasureString(&quot;&quot;, LSfont);                                //将绘制的字符串进行格式化

float SWidth = 0;                                                            //获取字符串的宽度

float SHeight = 0;                                                           //获取字符串的高度

//计算饼型图的初始位置

XLeft = panel1.Width - (panel1.Width - 5);                                            //去了边框后饼型图的X位置

XSize = panel1.Width - 10;                                                     //设置饼型图的宽度

temXLeft = AXLeft;                                                              //记录饼型图的X坐标

AXLeft = XLeft;                                                            //记录饼型图的X坐标

AXSize = XSize;                                                            //记录饼型图的宽度

//通过说明文字的大小计算饼型图的位置

AXLeft = AXLeft + AreaXMaxWidth + Aline;                                        //设置去除说明文字后的饼型图X坐标

AYUp = AYUp + AreaXMaxHeight;                                                //设置去除说明文字后的饼型图Y坐标

AXSize = XSize - AreaXMaxWidth * 2 - Aline * 2;                                 //设置去除说明文字后的饼型图宽度

AYSize = YSize - AreaXMaxHeight * 2;                                                 //设置去除说明文字后的饼型图高度

if (AXSize &gt;= AYSize)                                                    //如果饼型图的宽度大于等于高度

{

    Aleft = AXSize - AYSize;                                                //记录饼型图的X坐标

    AXSize = AYSize;                                                   //将高度设为宽度

}

else

{

    Atop = AYSize - AXSize;                                                //记录饼型图的Y坐标

    AYSize = AXSize;                                                   //将宽度设为高度

}

if (Aleft != 0)                                                                 //如果宽大于高

{

    AXLeft = AXLeft + Aleft / 2;                                                  //设置饼型图横向局中

}

if (Atop != 0)                                                                 //如果高大于宽

{

    AYUp = AYUp + Atop / 2;                                               //设置饼型图纵向局中

}

temXLeft = XLeft;

//初始化说明文字前横线的变量

float X1 = 0;

float Y1 = 0;

float X2 = 0;

float Y2 = 0;

//初始化说明文字位置的变量

float TX1 = 0;

float TY1 = 0;

float TX2 = 0;

float TY2 = 0;

float temf = 0;                                                                //记录百分比

double radians = 0;                                                         //记录扇形的角度

temf = (this.AreaAngle * (ASum / 360) / ASum);                                    //记录起始位置的度数

TimeNum = this.AreaAngle;                                                   //记录扇形的起始角度

//绘制说明文字

if (AXSize &gt; 0 &amp;&amp; AYSize &gt; 0)

{

    for (int i = 0; i &lt; SzData.Length; i++)                                             //遍历所有说明文字

    {

        f = SzData\[i\] / ASum;                                              //获取当前记录的百分比

        if (f == 0)                                                        //如果当前值为0

            continue;                                                  //执行下一次循环

        radians = ((double)((temf + f / 2) * 360) * Math.PI) / (double)180;

        X1 = Convert.ToSingle(AXLeft + (AXSize / 2.0 + (int)((float)(AXSize / 2.0) * Math.Cos(radians))));

        Y1 = Convert.ToSingle(AYUp + (AYSize / 2.0 + (int)((float)(AYSize / 2.0) * Math.Sin(radians))));

        XMaxSize = TitG.MeasureString(AreaText\[i\].Trim(), LSfont);          //将绘制的字符串进行格式化

        SWidth = XMaxSize.Width;                                             //获取字符串的宽度

        SHeight = XMaxSize.Height;                                            //获取字符串的高度

        if ((temf + f / 2) * 360 &gt; 90 &amp;&amp; (temf + f / 2) * 360 &lt;= 270)

        {

            X2 = X1 - Aline;

            TX1 = X2 - 1 - SWidth;

            TY1 = Y1 - SHeight / 2 - Asash;

            TX2 = SWidth;

            TY2 = SHeight + Asash * 2;

            g.FillRectangle(ATbrush, TX1, TY1, TX2, TY2);                            //绘制内矩形

            g.DrawRectangle(new Pen(Color.Black, 1), TX1, TY1, TX2, TY2);  //绘制矩形

            g.DrawString(AreaText\[i\].Trim(), LSfont, Zbrush, new PointF(X2 - SWidth + Asash - 1, Y1 - SHeight / 2));

       }

       else

       {

           X2 = X1 + Aline;

           TX1 = X2 + 1;

           TY1 = Y1 - SHeight / 2 - Asash;

           TX2 = SWidth;

           TY2 = SHeight + Asash * 2;

           g.FillRectangle(ATbrush, TX1, TY1, TX2, TY2);                       //绘制内矩形

           g.DrawRectangle(new Pen(Color.Black, 1), TX1, TY1, TX2, TY2);   //绘制矩形

           g.DrawString(AreaText\[i\].Trim(), LSfont, Zbrush, new PointF(X2 + Asash + 1, Y1 - SHeight / 2));

        }

        Y2 = Y1;

        g.DrawLine(new Pen(new SolidBrush(Color.Black), 1), X1, Y1, X2, Y2);

        TimeNum += f * 360;

        temf = temf + f;

    }

}

else

    return;</code></pre><p>}</p>
<p>#endregion</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟015：使用DrawString方法实现水印文字。 对于一些有可能侵权的图片，或者要作为宣传的图片，可以通过使用DrawString方法将用到的文字绘制到图片上，从而得到所谓的“水印文字”。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>csharp 多曲线数据分析</title>
    <url>/zh-CN/2019/04/16/csharp-e5-a4-9a-e6-9b-b2-e7-ba-bf-e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90.html</url>
    <content><![CDATA[<h2 id="多曲线数据分析"><a href="#多曲线数据分析" class="headerlink" title="多曲线数据分析"></a>多曲线数据分析</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在人事管理系统中经常会用到统计功能，如统计员工、工资、性别比例等。本实例使用多曲线对员工进行统计，分析公司内正式员工和试用员工的流动情况。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/04/2019-04-16-03153936.png" alt=""> 图1 多曲线数据分析</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时，首先需要通过SQL语句从数据库中检索出相关数据，然后将这些数据信息以适当的比例绘制成多曲线图，实现过程中主要使用Graphics类的DrawLines方法来绘制多曲线。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为MultiCurve。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个ComboBox控件，用来显示年度列表；添加一个Panel控件，用来显示绘制的多曲线图；添加一个Button控件，用来从数据库中查询信息，并根据查询的信息绘制多曲线图。 （3）程序主要代码如下：</p>
<p>private void CreateImage(int ID)<br>{<br>    int height = 440, width = 600;                                        //设置画布宽和高<br>    System.Drawing.Bitmap image = new System.Drawing.Bitmap(width, height);    //创建画布<br>    Graphics g = Graphics.FromImage(image);                                //创建Graphics对象<br>    try<br>    {<br>        g.Clear(Color.White);                                        //清空图片背景色<br>        Font font = new System.Drawing.Font(“Arial”, 9, FontStyle.Regular);            //设置字体<br>        Font font1 = new System.Drawing.Font(“宋体”, 12, FontStyle.Regular);            //设置字体<br>        Font font2 = new System.Drawing.Font(“Arial”, 8, FontStyle.Regular);            //设置字体<br>        System.Drawing.Drawing2D.LinearGradientBrush brush = new System.Drawing.Drawing2D.LinearGradientBrush(new Rectangle(0, 0, image.Width, image.Height), Color.Blue, Color.Blue, 1.2f, true);                    //创建LinearGradientBrush对象<br>        g.FillRectangle(Brushes.AliceBlue, 0, 0, width, height);                    //绘制矩形框<br>        Brush brush1 = new SolidBrush(Color.Blue);                            //创建笔刷<br>        Brush brush2 = new SolidBrush(Color.SaddleBrown);                    //创建笔刷<br>        string str = “SELECT * FROM tb_curve WHERE Years=” + ID + “”;            //声明SQL语句<br>//建立数据库连接<br>        SqlConnection Con = new SqlConnection(“server=mrwxk\\wangxiaoke;pwd=;uid=sa;database=db_TomeOne”);<br>        Con.Open();                                            //打开数据库连接<br>        SqlCommand Com = new SqlCommand(str, Con);                        //创建SqlCommand对象<br>        SqlDataReader dr = Com.ExecuteReader();                            //创建SqlDataReader对象<br>        dr.Read();                                                //开始读取记录<br>        if (dr.HasRows)                                            //如果有记录<br>        {<br>            //绘制标题<br>            g.DrawString(“” + ID + “年公司内部人员统计表”, font1, brush1, new PointF(160, 30));<br>        }<br>        dr.Close();                                                //关闭SqlDataReader对象<br>        //画图片的边框线<br>        g.DrawRectangle(new Pen(Color.Blue), 0, 0, image.Width - 1, image.Height - 1);<br>        Pen mypen = new Pen(brush, 1);                                //创建画笔<br>        Pen mypen2 = new Pen(Color.Red, 2);                                //创建画笔<br>        int x = 60;<br>        for (int i = 0; i &lt; 12; i++)<br>        {<br>            g.DrawLine(mypen, x, 80, x, 340);                            //绘制纵向线条<br>            x = x + 40;<br>        }<br>        Pen mypen1 = new Pen(Color.Blue, 2);                            //创建画笔<br>        g.DrawLine(mypen1, x - 480, 80, x - 480, 340);                        //绘制线条<br>        int y = 106;<br>        for (int i = 0; i &lt; 9; i++)<br>        {<br>            g.DrawLine(mypen, 60, y, 540, y);                            //绘制横向线条<br>            y = y + 26;<br>        }<br>        g.DrawLine(mypen1, 60, y, 540, y);<br>        //x轴<br>        String[] n = {“  一月”, “  二月”, “  三月”, “  四月”, “  五月”, “  六月”, “  七月”,<br>             “  八月”, “  九月”, “  十月”, “十一月”, “十二月”};                //绘制月份<br>        x = 35;<br>        for (int i = 0; i &lt; 12; i++)<br>        {<br>            g.DrawString(n[i].ToString(), font, Brushes.Red, x, 348);                //设置文字内容及输出位置<br>            x = x + 40;<br>        }<br>        //y轴<br>        String[] m = {“900人”, “ 800人”, “ 700人”, “600人”, “ 565人”, “ 400人”, “ 300人”, “ 200人”,<br>             “ 100人”};                                            //绘制人数<br>        y = 100;<br>        for (int i = 0; i &lt; 9; i++)<br>        {<br>            g.DrawString(m[i].ToString(), font, Brushes.Red, 10, y);                 //设置文字内容及输出位置<br>            y = y + 26;<br>        }<br>        int[] Count1 = new int[12];<br>        int[] Count2 = new int[12];<br>        string[] NumChr = new string[12];<br>        string cmdtxt2 = “SELECT * FROM tb_curve WHERE Years=” + ID + “”;        //声明SQL语句<br>        SqlCommand Com1 = new SqlCommand(cmdtxt2, Con);                    //创建SqlCommand对象<br>        SqlDataAdapter da = new SqlDataAdapter();                            //创建SqlDataAdapter对象<br>        da.SelectCommand = Com1;<br>        DataSet ds = new DataSet();                                    //创建DataSet对象<br>        da.Fill(ds);                                                //Fill方法填充DataSet<br>        int j = 0;<br>        for (int i = 0; i &lt; 12; i++)<br>        {<br>            NumChr[i] = ds.Tables[0].Rows[0][i + 1].ToString();<br>        }<br>        for (j = 0; j &lt; 12; j++)<br>        {<br>            Count1[j] = Convert.ToInt32(NumChr[j].Split(‘|’)[0].ToString()) * 26 / 100;<br>        }<br>        for (int k = 0; k &lt; 12; k++)<br>        {<br>            Count2[k] = Convert.ToInt32(NumChr[k].Split(‘|’)[1].ToString()) * 26 / 100;<br>        }<br>        //显示折线效果<br>        SolidBrush mybrush = new SolidBrush(Color.Red);                        //创建SolidBrush对象<br>        Point[] points1 = new Point[12];<br>        points1[0].X = 60; points1[0].Y = 340 - Count1[0];<br>        points1[1].X = 100; points1[1].Y = 340 - Count1[1];<br>        points1[2].X = 140; points1[2].Y = 340 - Count1[2];<br>        points1[3].X = 180; points1[3].Y = 340 - Count1[3];<br>        points1[4].X = 220; points1[4].Y = 340 - Count1[4];<br>        points1[5].X = 260; points1[5].Y = 340 - Count1[5];<br>        points1[6].X = 300; points1[6].Y = 340 - Count1[6];<br>        points1[7].X = 340; points1[7].Y = 340 - Count1[7];<br>        points1[8].X = 380; points1[8].Y = 340 - Count1[8];<br>        points1[9].X = 420; points1[9].Y = 340 - Count1[9];<br>        points1[10].X = 460; points1[10].Y = 340 - Count1[10];<br>        points1[11].X = 565; points1[11].Y = 340 - Count1[11];<br>        g.DrawLines(mypen2, points1);                                    //绘制折线<br>        Pen mypen3 = new Pen(Color.Black, 2);                            //创建画笔<br>        Point[] points2 = new Point[12];<br>        points2[0].X = 60; points2[0].Y = 340 - Count2[0];<br>        points2[1].X = 100; points2[1].Y = 340 - Count2[1];<br>        points2[2].X = 140; points2[2].Y = 340 - Count2[2];<br>        points2[3].X = 180; points2[3].Y = 340 - Count2[3];<br>        points2[4].X = 220; points2[4].Y = 340 - Count2[4];<br>        points2[5].X = 260; points2[5].Y = 340 - Count2[5];<br>        points2[6].X = 300; points2[6].Y = 340 - Count2[6];<br>        points2[7].X = 340; points2[7].Y = 340 - Count2[7];<br>        points2[8].X = 380; points2[8].Y = 340 - Count2[8];<br>        points2[9].X = 420; points2[9].Y = 340 - Count2[9];<br>        points2[10].X = 460; points2[10].Y = 340 - Count2[10];<br>        points2[11].X = 565; points2[11].Y = 340 - Count2[11];<br>        g.DrawLines(mypen3, points2);                                    //绘制折线<br>        //绘制标识<br>        g.DrawRectangle(new Pen(Brushes.Red), 150, 370, 250, 50);                //绘制范围框<br>        g.FillRectangle(Brushes.Red, 250, 380, 20, 10);                        //绘制小矩形<br>        g.DrawString(“试用员工人数”, font2, Brushes.Red, 270, 380);                //绘制试用员工人数<br>        g.FillRectangle(Brushes.Black, 250, 400, 20, 10);                        //绘制小矩形<br>        g.DrawString(“正式员工人数”, font2, Brushes.Black, 270, 400);                //绘制正式员工人数<br>        this.panel1.BackgroundImage = image;                            //显示绘制的图像<br>    }<br>    catch<br>    { }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟010：使用try…catch语句捕获异常。 在大部分情况下，开发人员不希望异常状况发生导致程序结束，因此，可以使用try…catch程序语句块捕捉程序中的Exception对象，再使用自定义的程序逻辑处理异常状况。如果有需要，用户也可以使用多重try…catch语句块（如一个try块后跟一个或多个catch子句构成）。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>csharp 网站人气指数曲线分析</title>
    <url>/zh-CN/2019/04/16/csharp-e7-bd-91-e7-ab-99-e4-ba-ba-e6-b0-94-e6-8c-87-e6-95-b0-e6-9b-b2-e7-ba-bf-e5-88-86-e6-9e-90.html</url>
    <content><![CDATA[<h2 id="网站人气指数曲线分析"><a href="#网站人气指数曲线分析" class="headerlink" title="网站人气指数曲线分析"></a>网站人气指数曲线分析</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>网站访问量可以决定网站的人气，那么对网站月访问量的统计分析，可以让网站管理员准确地判断网民上网的需求周期，从而调整网站的内容，更好地为广大网民服务。本实例通过对数据库中的数据进行分析，将每月份网站访问量以折线形式反映给用户。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/04/2019-04-16-03090799.png" alt=""> 图1 网站人气指数曲线分析</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例主要使用Graphics类的DrawLines方法来绘制网站人气指数曲线图。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为SiteVisterAnalyse。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个Panel控件，用于显示绘制的网站人气指数折线图。 （3）程序主要代码如下：</p>
<p>private void drowPic()<br>{<br>    Graphics g = this.CreateGraphics();                                //创建Graphics对象<br>    g.Clear(Color.WhiteSmoke);                                    //设置背景色<br>    Pen p = new Pen(Color.Blue);                                    //绘制画笔<br>    //设置用到的字体<br>    Font fontO = new System.Drawing.Font(“Arial”, 9, FontStyle.Regular);<br>    Font fontT = new System.Drawing.Font(“华文新魏”, 16, FontStyle.Regular);<br>    Point pointStart = new Point(0, 0);                                //绘制边框与显示字体<br>    Size sizeWindows = new Size(this.Width - 8, this.Height - 34);                //创建Size对象<br>    Rectangle rect = new Rectangle(pointStart, sizeWindows);                //创建Rectangle对象<br>    g.DrawRectangle(p, rect);                                    //绘制矩形<br>    Brush brus = new SolidBrush(Color.Red);                            //创建笔刷<br>    g.DrawString(“网站人气指数曲线分析”, fontT, brus, this.Width / 2.00f - 150, 10.00f);<br>    //绘制网格线<br>    int x = this.Width / 10;<br>    int y = this.Height / 14;<br>    int z = this.Width / 10;<br>    int k = y * 12;<br>    //X<br>    for (int i = 0; i &lt; 12; i++)<br>    {<br>        g.DrawLine(p, x, y * 3 - 10, x, y * 12);                            //绘制水平线条<br>        x = x + (this.Width - 34) / 14;<br>    }<br>    //X轴<br>    String[] n = {“ 1月”, “ 2月”, “ 3月”, “ 4月”, “ 5月”, “ 6月”, “ 7月”,<br>     “ 8月”, “ 9月”, “10月”, “11月”, “12月”};                        //绘制月份<br>    x = this.Width / 10 - 16;<br>    for (int i = 0; i &lt; 12; i++)<br>    {<br>        g.DrawString(n[i].ToString(), fontO, Brushes.Red, x, y * 12);            //设置文字内容及输出位置<br>        x = x + (this.Width - 34) / 14;<br>    }<br>    //Y<br>    for (int i = 0; i &lt; 12; i++)<br>    {<br>        g.DrawLine(p, z, k, x + 10, k);                                //绘制垂直线条<br>        k = k - (y * 12) / 16;<br>    }<br>    //Y轴<br>    int h = k;<br>    String[] m = {“5565”,”5650”,”4565”, “4000”, “3565”, “3000”, “2565”, “2000”, “1565”, “1000”,<br>     “  565”};                                            //绘制Y轴显示的文字<br>    k = y * 12;<br>    for (int i = 0; i &lt; 11; i++)<br>    {<br>        g.DrawString(m[10 - i].ToString(), fontO, Brushes.Red, z - 35, k - y);        //开始绘制文字<br>        k = k - (y * 12) / 16;<br>    }<br>    int[] Count = new int[12];<br>    Pen mypen = new Pen(Color.Red, 2);                            //创建画笔<br>    Point[] points = new Point[12];<br>    x = this.Width / 10;<br>    k = y * 12;<br>    SqlConnection Con = new SqlConnection(“Server=mrwxk\\wangxiaoke;DataBase=db_TomeOne;Uid=sa;Pwd=”);<br>    string cmdtxt2 = “SELECT * FROM tb_reticulation”;                    //声明SQL语句<br>    SqlCommand Com1 = new SqlCommand(cmdtxt2, Con);                    //创建SqlCommand对象<br>    SqlDataAdapter da = new SqlDataAdapter();                        //创建SqlDataAdapter对象<br>    da.SelectCommand = Com1;<br>    DataSet ds = new DataSet();                                    //创建DataSet对象<br>    da.Fill(ds);                                            //Fill方法填充DataSet对象<br>    int j = 0;<br>    for (j = 0; j &lt; 12; j++)<br>    {<br>        //与Y轴数生成有关(y * 12)/16因为起始为565<br>        Count[j] = Convert.ToInt32(ds.Tables[0].Rows[0][j + 2].ToString()) * (y * 12) / 16 / 565;<br>    }<br>    //设置绘制曲线的坐标数组<br>    points[0].X = x; points[0].Y = k - Count[0];<br>    x = x + (this.Width - 34) / 14;<br>    points[1].X = x; points[1].Y = k - Count[1];<br>    x = x + (this.Width - 34) / 14;<br>    points[2].X = x; points[2].Y = k - Count[2];<br>    x = x + (this.Width - 34) / 14;<br>    points[3].X = x; points[3].Y = k - Count[3];<br>    x = x + (this.Width - 34) / 14;<br>    points[4].X = x; points[4].Y = k - Count[4];<br>    x = x + (this.Width - 34) / 14;<br>    points[5].X = x; points[5].Y = k - Count[5];<br>    x = x + (this.Width - 34) / 14;<br>    points[6].X = x; points[6].Y = k - Count[6];<br>    x = x + (this.Width - 34) / 14;<br>    points[7].X = x; points[7].Y = k - Count[7];<br>    x = x + (this.Width - 34) / 14;<br>    points[8].X = x; points[8].Y = k - Count[8];<br>    x = x + (this.Width - 34) / 14;<br>    points[9].X = x; points[9].Y = k - Count[9];<br>    x = x + (this.Width - 34) / 14;<br>    points[10].X = x; points[10].Y = k - Count[10];<br>    x = x + (this.Width - 34) / 14;<br>    points[11].X = x; points[11].Y = k - Count[11];<br>    g.DrawLines(mypen, points);                                    //绘制折线<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟011：使用DataSet对象作为数据集。 DataSet对象是ADO.NET的核心成员，它是支持ADO.NET断开式、分布式数据方案的核心对象，也是实现基于非连接的数据查询的核心组件。DataSet对象是创建在内存中的集合对象，它可以包含任意数量的数据表以及所有表的约束、索引和关系等，它实质上相当于在内存中的一个小型关系数据库。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>DataTable 和 Json 互转</title>
    <url>/zh-CN/2017/03/02/datatable-e5-92-8c-json-e4-ba-92-e8-bd-ac.html</url>
    <content><![CDATA[<p>发现有博友贴出的转换代码</p>
<p>public string DataTableToJson(System.Data.DataTable dt)<br>     {<br>         StringBuilder Json = new StringBuilder();<br>         Json.Append(“[“);<br>         if (dt.Rows.Count &gt; 0)<br>         {<br>             for (int i = 0; i &lt; dt.Rows.Count; i++)<br>             {<br>                 Json.Append(“{“);<br>                 for (int j = 0; j &lt; dt.Columns.Count; j++)<br>                 {<br>                     Json.Append(“\“” + dt.Columns[j].ColumnName.ToString() + “\“:\“” + dt.Rows[i][j].ToString() + “\“”);<br>                     if (j &lt; dt.Columns.Count - 1)<br>                     {<br>                         Json.Append(“,”);<br>                     }<br>                 }<br>                 Json.Append(“}”);<br>                 if (i &lt; dt.Rows.Count - 1)<br>                 {<br>                     Json.Append(“,”);<br>                 }<br>             }<br>         }<br>         //  Json.Append(“]}”);<br>         Json.Append(“]“);<br>         return Json.ToString();<br>     }   </p>
<p>public DataTable JsonToDataTable(string strJson)<br>        {<br>            string strTableName = “Temp”;<br>            DataTable tb = null;  </p>
<pre><code>    var rg = new Regex(@&quot;(?&lt;={)\[^}\]+(?=})&quot;);  
    MatchCollection mc = rg.Matches(strJson);  

    if(mc.Count==0)  
    {  
        return null;  
    }  
    string strRow = mc\[0\].Value;  
    string\[\] strRows = strRow.Split(&apos;,&apos;);  
    if (tb == null)  
    {  
        tb = new DataTable();  
        tb.TableName = strTableName;  
        foreach (string str in strRows)  
        {  
            var dc = new DataColumn();  
            string\[\] strCell = str.Split(&apos;:&apos;);  
            dc.ColumnName = strCell\[0\].Replace(&quot;\\&quot;&quot;, &quot;&quot;);  
            tb.Columns.Add(dc);  
        }  
        tb.AcceptChanges();  
    }  

    JsonArray arr = JsonConvert.Import(strJson) as JsonArray;  

    foreach (JsonObject obj in arr)  
    {  
        DataRow dr = tb.NewRow();  
        for (int j = 0; j &lt; tb.Columns.Count; j++)  
        {  
            dr\[tb.Columns\[j\].ColumnName\] = obj\[tb.Columns\[j\].ColumnName\];  
        }  
        tb.Rows.Add(dr);  
    }  

    tb.AcceptChanges();  

    return tb;  
}  </code></pre><p>发现下面的更加方便实用</p>
<p>using Newtonsoft.Json;<br>using Newtonsoft.Json.Converters;<br>using System;<br>using System.Data;</p>
<p>namespace socketClient.Tool<br>{<br>    /// <summary><br>    /// Json 工具 引用了 Newtonsoft.Json.dll<br>    /// </summary><br>    public class JsonTool<br>    {<br>        /// <summary><br>        /// DataTable 转换为 Json 格式的字符串<br>        /// </summary><br>        /// <param name="dt"></param><br>        /// <returns></returns><br>        public static String DataTable2Json(DataTable dt)<br>        {<br>            String json = JsonConvert.SerializeObject(dt, new DataTableConverter());<br>            return json;<br>        }</p>
<pre><code>    /// &lt;summary&gt;
    /// Json 格式字符串转换为 DataTable
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;json&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static DataTable Json2DataTable(String json)
    {
        DataTable tb = (DataTable)JsonConvert.DeserializeObject(json, typeof(DataTable));

        return tb;
    }
}</code></pre><p>}</p>
<pre><code>&apos;&apos;&apos; &lt;summary&gt;
&apos;&apos;&apos; Json 格式字符串转换为 DataTable
&apos;&apos;&apos; &lt;/summary&gt;
&apos;&apos;&apos; &lt;param name=&quot;json&quot;&gt;&lt;/param&gt;
&apos;&apos;&apos; &lt;returns&gt;&lt;/returns&gt;
Public Shared Function Json2DataTable(ByVal json As String) As DataTable

    Return DirectCast(JsonConvert.DeserializeObject(analysis.json.JsonDecode(json, &quot;data&quot;), GetType(DataTable)), DataTable)
End Function</code></pre>]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>DataGridView和BindingSource复合控件</title>
    <url>/zh-CN/2019/09/10/datagridview-e5-92-8cbindingsource-e5-a4-8d-e5-90-88-e6-8e-a7-e4-bb-b6.html</url>
    <content><![CDATA[<h2 id="DataGridView和BindingSource复合控件"><a href="#DataGridView和BindingSource复合控件" class="headerlink" title="DataGridView和BindingSource复合控件"></a>DataGridView和BindingSource复合控件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>复合控件是封装在公共容器内的 Windows 窗体控件的集合，这种控件通常称为用户控件，其中包含的子控件称为构成控件。复合控件包含与每个构成控件相关联的所有固有功能，允许程序设计人员有选择地公开和绑定它们的属性。本实例将使用DataGridView控件和BindingSource控件制作复合控件来显示学生档案信息，实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1532_DataGridVie1.png" alt=""></p>
<p>图1 DataGridView和BindingSource复合控件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时主要用到了DataGridView控件和BindingSource组件，下面分别对它们进行详细讲解。 （1）DataGridView控件 DataGridView控件，又称为数据表格控件，它提供一种强大而灵活的以表格形式显示数据的方式，可以使用DataGridView控件来显示少量数据的只读视图，也可以对其进行缩放以显示特大数据集的可编辑视图。使用DataGridView控件，可以显示和编辑来自多种不同类型的数据源的表格数据。将数据绑定到DataGridView控件非常简单和直观，在大多数情况下，只需设置DataSource属性即可。另外，DataGridView控件具有极高的可配置性和可扩展性，它提供有大量的属性、方法和事件，可以用来对该控件的外观和行为进行自定义。当需要在Windows窗体应用程序中显示表格数据时，首先考虑使用DataGridView控件。若要以小型网格显示只读值或者使用户能够编辑具有数百万条记录的表，DataGridView控件将提供可以方便地进行编程以及有效地利用内存的解决方案。 DataGridView控件的常用属性及说明如表1所示。 表1 DataGridView控件的常用属性及说明</p>
<p>属性</p>
<p>说明</p>
<p>AllowUserToAddRows</p>
<p>获取或设置一个值，该值指示是否向用户显示添加行的选项</p>
<p>AllowUserToDeleteRows</p>
<p>获取或设置一个值，该值指示是否允许用户从DataGridView中删除行</p>
<p>AlternatingRowsDefaultCellStyle</p>
<p>获取或设置应用于DataGridView的奇数行的默认单元格样式</p>
<p>ColumnCount</p>
<p>获取或设置DataGridView中显示的列数</p>
<p>Columns</p>
<p>获取一个包含控件中所有列的集合</p>
<p>CurrentCell</p>
<p>获取或设置当前处于活动状态的单元格</p>
<p>CurrentRow</p>
<p>获取包含当前单元格的行</p>
<p>DataMember</p>
<p>获取或设置数据源中DataGridView显示其数据的列表或表的名称</p>
<p>DataSource</p>
<p>获取或设置DataGridView所显示数据的数据源</p>
<p>MultiSelect</p>
<p>获取或设置一个值，该值指示是否允许用户一次选择DataGridView的多个单元格、行或列</p>
<p>NewRowIndex</p>
<p>获取新记录所在行的索引</p>
<p>RowCount</p>
<p>获取或设置DataGridView中显示的行数</p>
<p>Rows</p>
<p>获取一个集合，该集合包含DataGridView控件中的所有行</p>
<p>SortOrder</p>
<p>获取一个值，该值指示是按升序或降序对DataGridView控件中的项进行排序，还是不排序</p>
<p>DataGridView控件的常用事件及说明如表2所示。  表2 DataGridView控件的常用事件及说明</p>
<p>事件</p>
<p>说明</p>
<p>CellClick</p>
<p>在单元格的任何部分被单击时发生</p>
<p>CellContentClick</p>
<p>在单元格中的内容被单击时发生</p>
<p>CellContentDoubleClick</p>
<p>在用户双击单元格的内容时发生</p>
<p>CellDoubleClick</p>
<p>在用户双击单元格中的任何位置时发生</p>
<p>CellMouseClick</p>
<p>在用户用鼠标单击单元格中的任何位置时发生</p>
<p>CellMouseDoubleClick</p>
<p>在双击DataGridView中的单元格时发生</p>
<p>Sorted</p>
<p>在DataGridView控件完成排序操作时发生</p>
<p>（2）BindingSource组件  BindingSource组件，又称为数据源绑定组件，它主要用于封装窗体的数据源。 BindingSource组件的常用属性及说明如表3所示。 表3 BindingSource组件的常用属性及说明</p>
<p>属性</p>
<p>说明</p>
<p>AllowNew</p>
<p>获取或设置一个值，该值指示是否可以使用AddNew方法向列表中添加项</p>
<p>AllowRemove</p>
<p>获取一个值，它指示是否可从基础列表中移除项</p>
<p>Count</p>
<p>获取基础列表中的总项数</p>
<p>Current</p>
<p>获取列表中的当前项</p>
<p>DataMember</p>
<p>获取或设置连接器当前绑定到的数据源中的特定列表</p>
<p>DataSource</p>
<p>获取或设置连接器绑定到的数据源</p>
<p>Item</p>
<p>获取或设置指定索引处的列表元素</p>
<p>List</p>
<p>获取连接器绑定到的列表</p>
<p>Position</p>
<p>获取或设置基础列表中当前项的索引</p>
<p>Sort</p>
<p>获取或设置用于排序的列名称以及用于查看数据源中的行的排序顺序</p>
<p>SortDirection</p>
<p>获取列表中项的排序方向</p>
<p>SupportsSearching</p>
<p>获取一个值，它指示数据源是否支持使用Find方法进行搜索</p>
<p>SupportsSorting</p>
<p>获取一个值，它指示数据源是否支持排序</p>
<p>BindingSource组件的常用方法及说明如表4所示。  表4 BindingSource组件的常用方法及说明</p>
<p>方法</p>
<p>说明</p>
<p>Add</p>
<p>将现有项添加到内部列表中</p>
<p>AddNew</p>
<p>向基础列表添加新项</p>
<p>ApplySort</p>
<p>使用指定的排序说明对数据源进行排序</p>
<p>Clear</p>
<p>从列表中移除所有元素</p>
<p>CopyTo</p>
<p>将List中的内容复制到指定数组，从指定索引值处开始</p>
<p>Find</p>
<p>在数据源中查找指定的项</p>
<p>GetEnumerator</p>
<p>检索List的一个枚举数</p>
<p>IndexOf</p>
<p>搜索指定的对象，并返回整个列表中第一个匹配项的索引</p>
<p>Insert</p>
<p>将一项插入列表中指定的索引处</p>
<p>MoveFirst</p>
<p>移至列表中的第一项</p>
<p>MoveLast</p>
<p>移至列表中的最后一项</p>
<p>MoveNext</p>
<p>移至列表中的下一项</p>
<p>MovePrevious</p>
<p>移至列表中的上一项</p>
<p>Remove</p>
<p>从列表中移除指定的项</p>
<p>RemoveAt</p>
<p>移除此列表中指定索引处的项</p>
<p>RemoveCurrent</p>
<p>从列表中移除当前项</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为ComplexControl。 （2）在当前项目中添加一个用户控件，将其命名为UserControl1。在用户控件中添加一个DataGridView 控件和一个BindingSource组件，并在DataGridView 控件的Columns属性中添加描述学生信息的字段。 （3）程序主要代码如下：</p>
<p>public void BindData()<br>{<br>    //创建数据库连接对象<br>    SqlConnection con = new SqlConnection(“server=mrwxk\\wangxiaoke;uid=sa;pwd=;database=db_TomeOne;”);<br>    con.Open();                                            //打开数据库连接<br>    SqlDataAdapter sda = new SqlDataAdapter(“Select * From tb_Student”, con);        //创建桥接器对象<br>    DataTable dt = new DataTable();                                //创建DataTable对象<br>    try<br>    {<br>        sda.Fill(dt);                                        //填充DataTable<br>    }<br>    catch (Exception ex)<br>    {<br>        throw ex;                                            //抛出异常<br>    }<br>    bindingSource1.DataSource = dt;                                //指定BindingSource数据源<br>    dataGridView1.DataSource = bindingSource1;                        //将BindingSource指定给DataGridView<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟010：使DataGridView单元格中的内容换行！ 通过设置DataGridView控件的DefaultCellStyle属性的WrapMode属性可以实现单元格文本换行功能，代码如下：</p>
<p>dataGridView1.DefaultCellStyle.WrapMode = DataGridViewTriState.True;</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>为一个Excel文件创建多个工作表</title>
    <url>/zh-CN/2019/08/25/e4-b8-ba-e4-b8-80-e4-b8-aaexcel-e6-96-87-e4-bb-b6-e5-88-9b-e5-bb-ba-e5-a4-9a-e4-b8-aa-e5-b7-a5-e4-bd-9c-e8-a1-a8.html</url>
    <content><![CDATA[<h2 id="为一个Excel文件创建多个工作表"><a href="#为一个Excel文件创建多个工作表" class="headerlink" title="为一个Excel文件创建多个工作表"></a>为一个Excel文件创建多个工作表</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例演示如何使用C#语言为一个Excel文件创建多个工作表。运行本实例，在窗体的菜单栏中选择“打开Excel文件”选项，即可打开一个Excel文件，并显示在窗体中，如图1所示；选择“创建工作表”选项，即可在指定的Excel文件中创建新的工作表，如图2所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-01163624.png" alt=""> 图1 创建工作表前的Excel文件 图2 创建完工作表后的Excel文件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在为一个Excel文件创建多个工作表时，主要用到了Excel自动化对象模型的Worksheets对象的Add方法，下面对其进行详细讲解。 Worksheets对象的Add方法主要用来为指定的工作簿添加工作表，其语法格式如下： object Add([In, Optional] object Before, [In, Optional] object After, [In, Optional] object Count, [In, Optional] object Type); 参数说明 Before：要在其前面添加的工作表。 After：要在其后面添加的工作表。 Count：要添加的工作表数量。 Type：工作表类型。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为CreateMultiSheet。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个MenuStrip控件，用来作为窗体的菜单栏，该菜单栏中添加两个子菜单项，分别用来执行打开Excel文件和为Excel文件创建工作表操作。 （3）程序主要代码如下：</p>
<p>private void 创建工作表ToolStripMenuItem_Click(object sender, EventArgs e)<br>{<br>CloseProcess();                                    //关闭Excel进程<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.Application();<br>    object missing = Missing.Value;                        //获取缺少的object类型值<br>    //打开指定的Excel文件<br>    Microsoft.Office.Interop.Excel.Workbook workbook = excel.Application.Workbooks.Open(M_str_Name, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>    Microsoft.Office.Interop.Excel.Worksheet newWorksheet = (Microsoft.Office.Interop.Excel.Worksheet)workbook.Worksheets.Add(missing, missing, 1, missing);<br>    MessageBox.Show(“添加工作表成功”, “提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>    excel.Application.DisplayAlerts = false;                    //不显示提示对话框<br>    workbook.Save();                                //保存工作表<br>    workbook.Close(false, missing, missing);                    //关闭工作表<br>    WBrowser_Excel.Navigate(M_str_Name);                    //在窗体中显示Excel文件内容<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟030：如何在程序中打开Excel文件？ 打开Excel文件时，可以使用Workbooks对象的Open方法来实现，该方法的第一个参数为要打开的Excel文件，其他的参数表示Excel的相关设置，实际使用时，直接用Missing.Value的值来表示即可。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>为Excel工作簿设置和清除密码</title>
    <url>/zh-CN/2019/08/25/e4-b8-baexcel-e5-b7-a5-e4-bd-9c-e7-b0-bf-e8-ae-be-e7-bd-ae-e5-92-8c-e6-b8-85-e9-99-a4-e5-af-86-e7-a0-81.html</url>
    <content><![CDATA[<h2 id="为Excel工作簿设置和清除密码"><a href="#为Excel工作簿设置和清除密码" class="headerlink" title="为Excel工作簿设置和清除密码"></a>为Excel工作簿设置和清除密码</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例通过使用C#语言实现为指定的Excel工作簿设置和清除密码的功能，运行本实例，如图1所示，单击“选择”按钮，在弹出的对话框中选择Excel文件的保存位置，然后单击“设置密码”按钮，弹出“输入——输入密码”对话框，如图2所示，在其中输入密码，单击“确定”按钮，弹出“输入——确认密码”对话框，如图3所示，在其中输入确认密码，单击“确定”按钮，即可为选择的Excel工作簿设置密码；单击“清除密码”按钮，如果Excel工作簿本身没有密码，则自动清除；否则，如果有密码，则弹出如图4所示的“密码”对话框，在其中输入正确的密码，单击“确定”按钮，即可清除该Excel工作簿的密码。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-01183274.png" alt=""> 图1 为Excel工作簿设置和清除密码 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-01183637.png" alt=""> 图2 “输入——输入密码”对话框 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-01183977.png" alt=""> 图3 “输入——确认密码”对话框 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-01184282.png" alt="无标题"> 图4 “密码”对话框</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在为Excel工作簿设置和清除密码时，主要用到了Excel自动化对象模型的Workbook对象的Password属性，下面对其进行详细讲解。 Workbook对象的Password属性主要用来获取或设置打开工作簿时必须提供的密码，其语法格式如下： [BrowsableAttribute(false)] public virtual string Password { get; set; } 参数说明 属性值：打开工作簿时必须提供的密码。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为SetAndClearPWD。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个TextBox控件，用来显示选择的Excel文件路径；添加3个Button控件，分别用来执行选择Excel文件、为Excel文件设置密码和清除密码操作。 （3）程序主要代码如下： 单击“设置密码”按钮，首先使用Excel对象的Open方法打开Excel工作簿，然后使用Excel对象的InptuBox方法为打开的Excel工作簿输入密码和确认密码，最后通过指定WorkBook对象的Password属性为Excel工作簿设置密码。“设置密码”按钮的Click事件代码如下：</p>
<p>private void btn_Set_Click(object sender, EventArgs e)<br>{<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.ApplicationClass();<br>    object missing = Missing.Value;                            //获取缺少的object类型值<br>    //打开指定的Excel文件<br>Microsoft.Office.Interop.Excel.Workbook workbook=excel.Application.Workbooks.Open(txt_Path.Text, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>//记录用户输入的密码<br>string P_str_password = excel.Application.InputBox(“输入密码：”,missing, missing, missing, missing, missing, missing, missing).ToString();<br>//记录用户输入的确认密码<br>    string P_str_confirmPassword = excel.Application.InputBox(“确认密码：”, missing, missing, missing, missing, missing, missing, missing).ToString();<br>    if (P_str_password != P_str_confirmPassword)                    //判断密码与确认密码是否一致<br>    {<br>        MessageBox.Show(“输入的密码不一致！”);<br>    }<br>    else<br>    {<br>        workbook.Password = P_str_password;                    //设置Excel密码<br>        MessageBox.Show(“密码设置成功！”);<br>    }<br>    excel.Application.DisplayAlerts = false;                        //不显示提示对话框<br>    workbook.Save();                                    //保存工作表<br>    workbook.Close(false, missing, missing);                        //关闭工作表<br>}</p>
<p>单击“清除密码”按钮，首先使用Excel对象的Open方法打开Excel工作簿，然后通过指定WorkBook对象的Password属性为空来清除Excel工作簿的密码。“清除密码”按钮的Click事件代码如下：</p>
<p>private void btn_Clear_Click(object sender, EventArgs e)<br>{<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.ApplicationClass();<br>    object missing = Missing.Value;                            //获取缺少的object类型值<br>    //打开指定的Excel文件<br>    Microsoft.Office.Interop.Excel.Workbook workbook = excel.Application.Workbooks.Open(txt_Path.Text, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>    workbook.Password = “”;                                //设置Excel密码为空<br>    MessageBox.Show(“密码清除成功！”);<br>    excel.Application.DisplayAlerts = false;                        //不显示提示对话框<br>    workbook.Save();                                    //保存工作表<br>    workbook.Close(false, missing, missing);                        //关闭工作表<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟029：为Excel工作簿设置密码时的注意事项！ 本实例使用了Excel对象的InputBox方法来为Excel工作簿设置密码，如果键入的密码相同，则认为键入的密码正确并更改原来的密码；如果键入的两个密码不同，则认为输入的密码不正确。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>产品滚动展示程序</title>
    <url>/zh-CN/2019/07/07/e4-ba-a7-e5-93-81-e6-bb-9a-e5-8a-a8-e5-b1-95-e7-a4-ba-e7-a8-8b-e5-ba-8f.html</url>
    <content><![CDATA[<h2 id="产品滚动展示程序"><a href="#产品滚动展示程序" class="headerlink" title="产品滚动展示程序"></a>产品滚动展示程序</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>很多商家为了宣传自己的产品，在网络上制作网页，通过互联网将自己的产品推向全国，甚至全世界。本实例将摸拟网页来制作一个窗体，将一系列产品的图片在窗体上滚动显示。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-07-1436373.png" alt=""> 图1 产品滚动展示程序</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例主要使用Timer计时器组件来控制产品图片的滚动显示。实现过程中，主要利用Timer计时器组件使Panel控件的Left属性在一定的时间内减10，从而达到产品图片滚动的效果。下面对本实例中用到的关键技术进行详细讲解。 Panel控件是一个容器控件，其Left属性用来获取或设置控件左边缘与其容器的工作区左边缘之间的距离（以像素为单位），该属性语法格式如下： [BrowsableAttribute(false)] public int Left { get; set; } 参数说明 属性值：表示控件左边缘与其容器的工作区左边缘之间的距离（以像素为单位）。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为ProductTumblingShown。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加3个PictureBox控件，用来显示产品图片；添加3个ImageList组件，用来存放产品图片；添加两个Timer组件，分别用来控制产品图片以指定的速度向左和向右移动。 （3）程序主要代码如下：</p>
<p>private void timer1_Tick(object sender, EventArgs e)<br>{<br>    left = 10;                                        //初始化变量left的值<br>    this.panel1.Left += left;                            //设置panel1控件距容器左边缘之间的距离<br>    int width = this.Width - this.panel1.Width;                    //初始化变量width<br>    if (this.panel1.Left &gt; width)                            //当panel1控件距容器左边缘之间的距离大于width时<br>    {<br>        this.timer1.Enabled = false;                        //禁用计时器timer1<br>        this.timer2.Enabled = true;                        //启用计时器timer2<br>        this.pictureBox1.Image = this.imageList1.Images[0];            //设置pictureBox1控件中显示的图片<br>        this.pictureBox2.Image = this.imageList2.Images[0];            //设置pictureBox2控件中显示的图片<br>        this.pictureBox3.Image = this.imageList3.Images[0];            //设置pictureBox3控件中显示的图片<br>    }<br>}<br>private void Frm_Main_Load(object sender, EventArgs e)<br>{<br>    this.pictureBox1.Image = this.imageList1.Images[0];            //设置pictureBox1控件中显示的图片<br>    this.pictureBox2.Image = this.imageList2.Images[0];            //设置pictureBox2控件中显示的图片<br>    this.pictureBox3.Image = this.imageList3.Images[0];            //设置pictureBox3控件中显示的图片<br>}<br>private void timer2_Tick(object sender, EventArgs e)<br>{<br>    left = -10;                                    //初始化left的值<br>    this.panel1.Left += left;                            //设置panel1距容器左边缘之间的距离<br>    if (this.panel1.Left &lt; 0)                            //当panel1距容器左边缘之间的距离小于0时<br>    {<br>        this.timer1.Enabled = true;                        //启用计时器timer1<br>        this.timer2.Enabled = false;                         //禁用计时器timer2<br>        this.pictureBox1.Image = this.imageList1.Images[1];         //设置pictureBox1控件中显示的图片<br>        this.pictureBox2.Image = this.imageList2.Images[1];            //设置pictureBox2控件中显示的图片<br>        this.pictureBox3.Image = this.imageList3.Images[1];            //设置pictureBox3控件中显示的图片<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟013：启动和关闭Timer计时器的两种方法。 启动Timer计时器时，可以将其Enabled属性设置为true，或者调用其Start方法；而关闭Timer计时器时，则需要将其Enabled属性设置为false，或者调用其Stop方法。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>从桌面右下角显示的Popup窗口提醒</title>
    <url>/zh-CN/2019/10/03/e4-bb-8e-e6-a1-8c-e9-9d-a2-e5-8f-b3-e4-b8-8b-e8-a7-92-e6-98-be-e7-a4-ba-e7-9a-84popup-e7-aa-97-e5-8f-a3-e6-8f-90-e9-86-92.html</url>
    <content><![CDATA[<h2 id="从桌面右下角显示的Popup窗口提醒"><a href="#从桌面右下角显示的Popup窗口提醒" class="headerlink" title="从桌面右下角显示的Popup窗口提醒"></a>从桌面右下角显示的Popup窗口提醒</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>Popup窗口提醒实际上就是在屏幕右下角弹出的提示窗口，它的应用十分广范，如程序的升级、提示当天工作内容等，本实例将制作一个动态显示和隐藏的Popup窗口提醒。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0820_Popup1.png" alt=""></p>
<p>图1 从桌面右下角显示的Popup窗口提醒</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例主要是使用API函数AnimateWindow来动态显示指定的窗体，并用Control类的SetBounds方法设置窗体的边界。下面对本实例中用到的关键技术进行详细讲解。</p>
<p>（1）AnimateWindow函数</p>
<p>该函数主要用来实现窗体的动画效果，其声明语法如下：</p>
<p>[DllImportAttribute(“user32.dll”)]</p>
<p>private static extern bool AnimateWindow(IntPtr hwnd, int dwTime, int dwFlags);</p>
<p>参数说明</p>
<p>R hwnd：IntPtr，标窗口句柄。</p>
<p> dwTime：动画的持续时间，数值越大动画效果的时间就越长。</p>
<p>} dwFlags：动画效果类型选项，其常量如表1所示。</p>
<p>表1 dwFlags参数的常量值及说明</p>
<p>常量</p>
<p>值</p>
<p>说明</p>
<p>AW_SLIDE</p>
<p>0x00040000</p>
<p>使用滑动类型。缺省则为滚动动画类型。当使用AW_CENTER标志时，这个标志就被忽略</p>
<p>AW_ACTIVE</p>
<p>0x00020000</p>
<p>激活窗口。在使用AW_HIDE标志后不要使用这个标志</p>
<p>AW_BLEND</p>
<p>0x00080000</p>
<p>使用淡入效果。只有当hWnd为顶层窗口的时候才可以使用此标志</p>
<p>AW_HIDE</p>
<p>0x00010000</p>
<p>隐藏窗口，缺省则显示窗口</p>
<p>AW_CENTER</p>
<p>0x00000010</p>
<p>若使用AW_HIDE标志，则使窗口向内重叠；若未使用AW_HIDE标志，则使窗口向外扩展</p>
<p>AW_HOR_POSITIVE</p>
<p>0x00000001</p>
<p>自左向右显示窗口。该标志可以在滚动动画和滑动动画中使用。当使用AW_CENTER标志时，该标志将被忽略</p>
<p>AW_HOR_NEGATIVE</p>
<p>0x00000002</p>
<p>自右向左显示窗口。当使用AW_CENTER 标志时该标志被忽略</p>
<p>AW_VER_POSITIVE</p>
<p>0x00000004</p>
<p>自顶向下显示窗口。该标志可以在滚动动画和滑动动画中使用。当使用AW_CENTER标志时，该标志将被忽略</p>
<p>AW_VER_NEGATIVE</p>
<p>0x00000008</p>
<p>自下向上显示窗口。该标志可以在滚动动画和滑动动画中使用。当使用AW_CENTER标志时，该标志将被忽略</p>
<p>（2）SetBounds方法</p>
<p>该方法将控件的边界设置为指定位置和大小，其语法格式如下：</p>
<p>public void SetBounds (int x,int y, int width,int height)</p>
<p>SetBounds方法语法中的参数及说明如表2所示。</p>
<p>表2 SetBounds方法语法中的参数及说明</p>
<p>参数</p>
<p>描述</p>
<p>x</p>
<p>控件的新Left属性值</p>
<p>y</p>
<p>控件的新Top属性值</p>
<p>width</p>
<p>控件的新Width属性值</p>
<p>height</p>
<p>控件的新Height属性值</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为PopupForm。</p>
<p>（2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个Button控件，分别用来显示和关闭Popup提醒窗口。</p>
<p>（3）在项目中添加一个Windows窗体，默认名称为Frm_Info.cs，用来作为提醒窗口，该窗口中添加一个PictureBox控件，用来执行关闭窗体操作；添加一个ImageList组件，用来存储程序中用到的图片资源。</p>
<p>（4）程序主要代码如下：</p>
<p>Frm_Info窗体中，自定一个ShowForm方法，主要用来实现从桌面右下角显示Popup提醒窗口的功能，代码如下：</p>
<p>public void ShowForm()</p>
<p>{</p>
<p>switch (this.FormNowState)</p>
<p>{</p>
<p>case FormState.Hide:</p>
<p>if (this.Height &lt;= this.Rect.Height - 192)                            //当窗体没有完全显示时</p>
<p>this.SetBounds(Rect.X, this.Top - 192, Rect.Width, this.Height + 192);        //使窗体不断上移</p>
<p>else</p>
<p>{</p>
<p>this.SetBounds(Rect.X,Rect.Y,Rect.Width,Rect.Height);                //设置当前窗体的边界</p>
<p>}</p>
<p>AnimateWindow(this.Handle, 800, AW_SLIDE + AW_VER_NEGATIVE);    //动态显示窗体</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>Frm_Info窗体中，自定一个CloseForm方法，该方法中首先调用API函数AnimateWindow动画隐藏窗体，然后将窗体的状态设置为隐藏，代码如下：</p>
<p>public void CloseForm()</p>
<p>{</p>
<p>AnimateWindow(this.Handle,800,AW_SLIDE + AW_VER_POSITIVE + AW_HIDE);    //动画隐藏窗体</p>
<p>this.FormNowState = FormState.Hide;                                //设定当前窗体状态为隐藏</p>
<p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟011：使用Screen类获取桌面的大小。</p>
<p>Screen类表示单个系统上的一个或多个显示设备，其PrimaryScreen属性用来获取主显示，该属性返回一个Screen对象，而调用Screen对象的WorkingArea属性可以获取显示器的工作区，也就是桌面的大小。</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>从DataGridView中拖放数据到TreeView</title>
    <url>/zh-CN/2019/10/03/e4-bb-8edatagridview-e4-b8-ad-e6-8b-96-e6-94-be-e6-95-b0-e6-8d-ae-e5-88-b0treeview.html</url>
    <content><![CDATA[<h2 id="从DataGridView中拖放数据到TreeView"><a href="#从DataGridView中拖放数据到TreeView" class="headerlink" title="从DataGridView中拖放数据到TreeView"></a>从DataGridView中拖放数据到TreeView</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>日常操作中，通过DataGridView控件可以显示数据库中记录，由于受记录数目和界面美观限制，对于多条记录的显示，DataGridView控件存在很多不足。例如，一条记录中有很多不同分类信息，直接看到它的全部内容几乎不可能，此时必须拖动滚动条才能看到，这样做虽然看到内容，但有些麻烦，本实例通过C#程序实现选定记录拖至TreeView控件直接显示。首先运行本实例，然后选定目标记录，接着按下鼠标左键，移动鼠标至TreeView控件，最后显示数据记录，实例运行结果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0848_DataGridVie1.png" alt=""></p>
<p>图1 从DataGridView中拖放数据到TreeView</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例主要用到DataGridView控件的MouseDown事件和TreeView控件的MouseEnter事件。下面对本实例中用到的关键技术进行详细讲解。 （1）DataGridView控件的MouseDown事件的处理方法 MouseDown事件是指当鼠标指针在DataGridView控件上方并按下鼠标按钮时发生，该事件在本实例中的处理方法如下：</p>
<p>private void dataGridView1_MouseDown(object sender, MouseEventArgs e)</p>
<p>参说说明 R sender：表示支持.NET Framework类层次结构中所有类的基类对象。  e：表示为MouseDown事件提供数据。 （2）TreeView控件的MouseEnter事件的处理方法 MouseEnter事件是指当鼠标进入TreeView控件可见部分时发生，该事件在本实例中的处理方法如下：</p>
<p>private void treeView1_MouseEnter(object sender, EventArgs e)</p>
<p>参说说明 R sender：表示支持.NET Framework类层次结构中所有类的基类对象。  e：表示为MouseEnter事件提供数据。</p>
<p>技巧：在进行拖放操作时，既可以选定单行，又可以选定多行。方法一：先选定一条记录，在DataGridView控件中默认状态下是行标题选定；然后按下键盘上的<Ctrl>键，选定需要的记录，拖放到TreeView控件上。方法二：选定多条连续记录中任意一个端点记录，按下键盘上<Shift>键，选中另一端点记录，拖放到TreeView控件上。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为DateToTreeView。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中首先添加一个DataGridView控件，设置其AllowUserToAddRows属性为False，主要用来显示数据库中数据记录；添加一个TreeView控件，设置其AllowDrop属性为True，主要用来接收从DataGridView控件中拖放的数据记录。 （3）程序主要代码如下： Frm_Main窗体加载时，首先从数据库中读取记录显示在DataGridView控件中。代码如下：</p>
<p>private void Form1_Load(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>string P_Connection = string.Format(                        //创建数据库连接字符串


&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data Source=test.mdb;User Id=Admin&quot;);


OleDbDataAdapter P_OLeDbDataAdapter = new OleDbDataAdapter(


&quot;select au\_id as 用户编号,au\_lname as 用户名,phone as 联系电话 from authors&quot;,


P_Connection);                                    //创建OleDbDataAdapter类的对象


DataSet ds = new DataSet();                                //创建数据集对象


P_OLeDbDataAdapter.Fill(ds, &quot;UserInfo&quot;);                        //把数据填充到数据集中


dataGridView1.DataSource = ds.Tables\[&quot;UserInfo&quot;\].DefaultView;        //DataGridView控件绑定数据源


TreeNode treeNode = new TreeNode(&quot;用户信息&quot;, 0, 0);                //创建根节点


treeView1.Nodes.Add(treeNode);                            //TreeView控件添加根节点



追加节点ToolStripMenuItem.Checked = true;                    //默认情况下设置为追加节点状态</code></pre><p>}</p>
<p>  在DataGridView控件上按下鼠标按键，通过二维数组recordInfo保存选定记录。代码如下：</p>
<p>//DataGridView的按下鼠标事件</p>
<p>private void dataGridView1_MouseDown(object sender, MouseEventArgs e)</p>
<p>{</p>
<pre><code>if (dataGridView1.SelectedCells.Count != 0)                    //判断DataGridView控件中是否有选定记录


{


    //定义一个二维数组，数组中的每一行代表DataGridView中的一条记录


    recordInfo = new string\[dataGridView1.Rows.Count, dataGridView1.Columns.Count\];


    //当按下鼠标左键时，首先获取选定行，记录每一行对应的信息


    for (int i = 0; i &lt; dataGridView1.Rows.Count; i++)


    {


        if (dataGridView1.Rows\[i\].Selected)                    //判断DataGridView中是否有选中行


        {


            for (int j = 0; j &lt; dataGridView1.Columns.Count; j++)        //循环遍历DataGridView中选定行中的每一列内容


            {


                //用数组recordInfo记录选定信息


                recordInfo\[i, j\] = dataGridView1.Rows\[i\].Cells\[j\].Value.ToString();


            }


        }


    }


}</code></pre><p>}</p>
<p>  把鼠标移动到TreeView控件上，遍历数组recordInfo中每一条记录，添加在TreeView控件下。代码如下：</p>
<p>private void treeView1_MouseEnter(object sender, EventArgs e)            //当鼠标进入TreeView控件时，触发的操作</p>
<p>{</p>
<pre><code>if (追加节点ToolStripMenuItem.Checked == true)                //判断拖放操作的类型是否为追加节点


{


    if (recordInfo != null &amp;&amp; recordInfo.Length != 0)                //判断数组recordnfo是否存在以及是否存在内容


    {


        for (int i = 0; i &lt; recordInfo.GetLength(0); i++)                //用双重for循环遍历数组recordInfo中的内容


        {


            for (int j = 0; j &lt; recordInfo.GetLength(1); j++)


            {


                if (recordInfo\[i, j\] != null)             //判断数组中的值是否为空


                {


                    if (j == 0)                            //当循环遍历至第0列时


                    {


                        //指定的标签文本初始化TreeNode对象


                        TreeNode Node1 = new TreeNode(recordInfo\[i, j\].ToString());


                        treeView1.SelectedNode.Nodes.Add(Node1);    //将先前创建的树节点添加到树节点集合的末尾


                        treeView1.SelectedNode = Node1;            //设置当前树视图控件中选定节点为刚创建完的节点


                    }


                    else


                    {


                        //指定的标签文本初始化TreeNode对象


                        TreeNode Node2 = new TreeNode(recordInfo\[i, j\].ToString());


                        treeView1.SelectedNode.Nodes.Add(Node2);    //将先前创建的树节点添加到树节点集合的末尾


                    }


                }


            }


            treeView1.SelectedNode = treeView1.Nodes\[0\];            //设置当前树视图控件中选定节点为根节点


            treeView1.ExpandAll();                        //在TreeView控件中展开所有节点


        }


        for (int m = 0; m &lt; recordInfo.GetLength(0); m++)            //用循环遍历数组recordInfo，清空recordInfo中的记录


        {


            for (int n = 0; n &lt; recordInfo.GetLength(1); n++)


            {


                recordInfo\[m, n\] = null;                        //设定数组recordInfo中内容为不存在


            }


        }


    }


}


if (清空内容ToolStripMenuItem.Checked == true)                //判断拖放操作的类型是否为追加节点


{


    if (treeView1.SelectedNode.Nodes.Count != 0)                //判断数组recordnfo是否存在内容


    {


        treeView1.SelectedNode.Remove();                    //清空treeView控件中的内容


        TreeNode treeNode = new TreeNode(&quot;用户信息&quot;, 0, 0);        //指定的标签文本初始化TreeNode对象


        treeView1.Nodes.Add(treeNode);                        //将先前创建的树节点添加到树节点集合的末尾


        treeView1.SelectedNode = treeNode;                    //设置当前树控件中选定节点为刚创建完的节点


        if (recordInfo != null &amp;&amp; recordInfo.Length != 0)            //判断数组recordnfo是否存在以及是否存在内容


        {


            for (int i = 0; i &lt; recordInfo.GetLength(0); i++)         //用双重for循环遍历数组recordInfo中的内容


            {


                for (int j = 0; j &lt; recordInfo.GetLength(1); j++)


                {


                    if (recordInfo\[i, j\] != null)         //判断数组中的值是否为空


                    {


                        if (j == 0)                         //当循环遍历至第0列时


                        {


                            //指定的标签文本初始化TreeNode对象


                            TreeNode Node1 = new TreeNode(recordInfo\[i, j\].ToString());


                            treeView1.SelectedNode.Nodes.Add(Node1);//将先前创建的树节点添加到树节点集合的末尾


                            treeView1.SelectedNode = Node1;        //设置当前树视图控件中选定节点为刚创建完的节点


                        }


                        else


                        {


                            //指定的标签文本初始化TreeNode对象


                            TreeNode Node2 = new TreeNode(recordInfo\[i, j\].ToString());


                            treeView1.SelectedNode.Nodes.Add(Node2);//将先前创建的树节点添加到树节点集合的末尾


                        }


                    }


                }


                treeView1.SelectedNode = treeView1.Nodes\[0\];        //设置当前树视图控件中选定节点为根节点


                treeView1.ExpandAll();                        //在TreeView控件中展开所有节点


            }


            for (int m = 0; m &lt; recordInfo.GetLength(0); m++)         //清空recordInfo中的记录


            {


                for (int n = 0; n &lt; recordInfo.GetLength(1); n++)


                {


                    recordInfo\[m, n\] = null;                 //设定数组recordInfo中内容为不存在


                }


            }


        }



        追加节点ToolStripMenuItem.Checked = true;



        清空内容ToolStripMenuItem.Checked = false;


    }


}</code></pre><p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟020：判断DataGridView中的某行是否被选定。 通过DataGridView控件的行对象（即DataGridViewRow类的实例）的Selected属性可以判断该行是否被选定。如果该行被选定，则Selected属性值为true，否则为 false。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>产品电子报价</title>
    <url>/zh-CN/2019/07/07/e4-ba-a7-e5-93-81-e7-94-b5-e5-ad-90-e6-8a-a5-e4-bb-b7.html</url>
    <content><![CDATA[<h2 id="产品电子报价"><a href="#产品电子报价" class="headerlink" title="产品电子报价"></a>产品电子报价</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例是通过电子产品的名称，来查看该电子产品的图片。运行程序，在“选择电子产品”下拉列表中选择电子产品的名称，单击“查询”按钮，即可在产品电子报价栏中显示该产品的图片信息。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-07-14385589.png" alt=""> 图1 产品电子报价</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>通过对本实例的分析，由于要将所有海报名列添加到下拉列表框中，海报的名称是惟一的，但是海报的格式（JPG、BMP等）不一定一样，所以要通过名称以最快的方式定位到图片上，笔者在这里使用了Hashtable类。Hashtable类用于表示键/值对的集合，这些键/值对可以根据键的哈希代码进行组织。Hashtable类的常用方法及说明如表1所示。 表1 Hashtable类的常用方法及说明</p>
<p>方法</p>
<p>说明</p>
<p>Add</p>
<p>将带有指定键和值的元素添加到Hashtable中</p>
<p>Clear</p>
<p>从Hashtable中移除所有元素</p>
<p>Contains</p>
<p>确定Hashtable是否包含特定键</p>
<p>ContainsKey</p>
<p>确定Hashtable是否包含特定键</p>
<p>ContainsValue</p>
<p>确定Hashtable是否包含特定值</p>
<p>CopyTo</p>
<p>将Hashtable元素复制到一维Array实例中的指定索引位置</p>
<p>GetEnumerator</p>
<p>返回循环访问Hashtable的IDictionaryEnumerator</p>
<p>Remove</p>
<p>从Hashtable中移除带有指定键的元素</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为ProductElectronQuote。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个ComboBox控件，用来选择产品名称列表；添加一个Button控件，用来执行查找功能；添加一个PictureBox控件，用来显示产品海报。 （3）程序主要代码如下：</p>
<p>Hashtable ht = new Hashtable();                                 //初始化一个哈希表对象<br>string str;                                             //初始化一个字符串str<br>public Frm_Main()<br>{<br>    InitializeComponent();<br>    str = Application.StartupPath + “\\Image”;                        //保存商品图片所在的路径<br>}<br>private void Form1_Load(object sender, EventArgs e)<br>{<br>    DirectoryInfo dir = new DirectoryInfo(str);                        //创建一个DirectoryInfo类的对象<br>    GetAllFiles(dir);                                     //获取指定路径下的所有文件<br>    foreach (DictionaryEntry de in ht)                             //循环哈希表中的所有数据<br>        this.comboBox1.Items.Add(de.Key);                         //向comboBox1中添加内容<br>}<br>public void GetAllFiles(DirectoryInfo dir)<br>{<br>    FileSystemInfo[] fileinfo = dir.GetFileSystemInfos();                //创建一个FileSystemInfo类型的对象<br>    foreach (FileSystemInfo i in fileinfo)                         //循环遍历fileinfo下的所有内容<br>    {<br>        if (i is DirectoryInfo)                                 //当在DirectoryInfo中存在i时<br>        {<br>            GetAllFiles((DirectoryInfo)i);                         //获取i下的所有文件<br>        }<br>        else                                            //当在DirectoryInfo中不存在i时<br>        {<br>            string str = i.FullName;                             //记录i的绝对路径<br>            int b = str.LastIndexOf(“\&quot;);                        //获取字符串与指定项匹配的最后一个索引<br>            string strType = str.Substring(b + 1);                    //获取文件的后缀名<br>            //当图片类型为“jpg”或者“bmp”时<br>            if (strType.Substring(strType.Length - 3).ToLower() == “jpg” || strType.Substring(strType.Length - 3).ToLower() == “bmp”)<br>            {<br>                ht.Add(strType.Substring(0, strType.Length - 4), strType);     //向哈希表中添加内容<br>            }<br>        }<br>    }<br>}<br>private void showPic(string name)<br>{<br>    this.pictureBox1.ImageLocation = str + “\&quot; + name;                //设置在pictureBox1中显示图片的路径<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟012：如何获取一个文件夹中的所有子文件夹及文件？ 获取一个文件夹中的所有子文件夹及文件时，可以使用DirectoryInfo类的GetFileSystemInfos方法来实现，该方法用来返回表示某个目录中所有文件和子目录的强类型FileSystemInfo项的数组，例如，本实例中使用该方法的代码如下：</p>
<p>str = Application.StartupPath + “\\Image”;                            //保存商品图片所在的路径<br>DirectoryInfo dir = new DirectoryInfo(str);                        //创建一个DirectoryInfo类的对象<br>FileSystemInfo[] fileinfo = dir.GetFileSystemInfos();                    //创建一个FileSystemInfo类型的对象</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>以全屏方式显示程序窗体</title>
    <url>/zh-CN/2019/10/03/e4-bb-a5-e5-85-a8-e5-b1-8f-e6-96-b9-e5-bc-8f-e6-98-be-e7-a4-ba-e7-a8-8b-e5-ba-8f-e7-aa-97-e4-bd-93.html</url>
    <content><![CDATA[<h2 id="以全屏方式显示程序窗体"><a href="#以全屏方式显示程序窗体" class="headerlink" title="以全屏方式显示程序窗体"></a>以全屏方式显示程序窗体</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>全屏显示窗体在实际开发中经常用到，比如人们常用的播放器或者网页视频等，全屏使得窗体能够显示的足够大，从而使人们更清楚的看到窗体中显示的内容。本实例实现了以全屏方式显示程序窗体的功能，运行本实例，单击”全屏”按钮，窗体即可全屏显示；单击”退出全屏”按钮，窗体即可恢复到原来状态。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0828_1-1.png" alt=""></p>
<p>图1 以全屏方式显示程序窗体</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现时，主要用到了窗体的FormBorderStyle属性和WindowState属性，下面对本实例用到的关键技术进行详细讲解。 （1）FormBorderStyle属性 该属性用来获取或设置窗体的边框样式，其语法格式如下：</p>
<p>public FormBorderStyle FormBorderStyle { get; set; }</p>
<p>参数说明 R 属性值：FormBorderStyle枚举值之一，表示窗体的起始位置，默认为FormBorderStyle.Sizable。FormBorderStyle枚举值及说明如表1所示。 表1 FormBorderStyle枚举值及说明</p>
<p>枚举值</p>
<p>说明</p>
<p>None</p>
<p>无边框</p>
<p>FixedSingle</p>
<p>固定的单行边框</p>
<p>Fixed3D</p>
<p>固定的三维边框</p>
<p>FixedDialog</p>
<p>固定的对话框样式的粗边框</p>
<p>Sizable</p>
<p>可调整大小的边框</p>
<p>FixedToolWindow</p>
<p>不可调整大小的工具窗口边框。工具窗口不会显示在任务栏中也不会显示在当用户按Alt+Tab时出现的窗口中</p>
<p>SizableToolWindow</p>
<p>可调整大小的工具窗口边框。工具窗口不会显示在任务栏中也不会显示在当用户按Alt+Tab时出现的窗口中</p>
<p>说明：尽管指定FormBorderStyle属性为FixedToolWindow枚举值的窗体通常不显示在任务栏中，还是必须确保ShowInTaskbar属性设置为false，因为其默认值为true。</p>
<p>（2）WindowState属性 该属性用来获取或设置窗体的窗口状态，其语法格式如下：</p>
<p>public FormWindowState WindowState { get; set; }</p>
<p>参数说明 R 属性值：FormWindowState枚举值之一，表示窗体的窗口状态。FormWindowState枚举值及说明如表2所示。 表2 FormWindowState枚举值及说明</p>
<p>枚举值</p>
<p>描述</p>
<p>Maximized</p>
<p>最大化的窗口</p>
<p>Minimized</p>
<p>最小化的窗口</p>
<p>Normal</p>
<p>默认大小的窗口</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为FullScreenForm。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个Button控件，分别用来使窗体进入全屏模式和退出全屏模式。 （3）程序主要代码如下：</p>
<p>private void button1_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>this.FormBorderStyle = FormBorderStyle.None;                    //设置窗体为无边框样式


this.WindowState = FormWindowState.Maximized;                //最大化显示窗体</code></pre><p>}</p>
<p>private void button2_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>this.FormBorderStyle = FormBorderStyle.Sizable;                    //设置窗体为有边框样式


this.WindowState = FormWindowState.Normal;                    //正常显示窗体</code></pre><p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟001：如何隐藏窗体的标题栏？ 开发人员可以通过设置窗体的FormBorderStyle属性为None，实现隐藏窗体标题栏功能。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>以编程方式创建继承窗体</title>
    <url>/zh-CN/2019/10/03/e4-bb-a5-e7-bc-96-e7-a8-8b-e6-96-b9-e5-bc-8f-e5-88-9b-e5-bb-ba-e7-bb-a7-e6-89-bf-e7-aa-97-e4-bd-93.html</url>
    <content><![CDATA[<h2 id="以编程方式创建继承窗体"><a href="#以编程方式创建继承窗体" class="headerlink" title="以编程方式创建继承窗体"></a>以编程方式创建继承窗体</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例通过使用代码编程的方式来创建一个继承窗体，本实例中的基窗体和继承窗体运行效果分别如图1和图2所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0829_1-1.png" alt=""></p>
<p>图1 基窗体</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0829_2-1.png" alt=""></p>
<p>图2 继承窗体</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现以编程方式创建继承窗体时，主要是在窗体类中进行定义，并将引用添加到要从其继承的窗体，引用应该包括该窗体的命名空间，后面跟一个句点，然后是基窗体本身的名称，这个过程中主要用到了类的继承机制，下面对其进行详细讲解。</p>
<p>说明：如果继承窗体和基窗体同属于一个命名空间，那么在修改继承窗体的基类引用时，只需要修改为基窗体的类名称即可。</p>
<p>继承是面向对象编程最重要的特性之一，任何类都可以从另外一个类继承，这就是说，这个类拥有它继承的类的所有成员。在面向对象编程中，被继承的类称为父类或基类。C#中提供了类的继承机制，但只支持单继承，而不支持多重继承，即在C#中一次只允许继承一个类，不能同时继承多个类。 C#中实现继承的语法格式如下：</p>
<p>class DerivedClass: BaseClass { }</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为InheritFormByCode。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个Label控件、一个TextBox控件和一个Button控件，用来修饰Frm_Main窗体。 （3）在项目中添加一个Windows窗体，命名为Frm_Inherit.cs，用来作为继承窗体。 （4）修改Frm_Inherit窗体代码文件中Frm_Inherit类所继承的基类。 Frm_Inherit窗体的原始代码如下：</p>
<p>public partial class Frm_Inherit : Form                    //表示当前窗体继承于Form类</p>
<p>{</p>
<pre><code>public Frm_Inherit()


{


    InitializeComponent();


}</code></pre><p>}</p>
<p>  Frm_Inherit窗体修改后的代码如下：</p>
<p>public partial class Frm_Inherit : Frm_Main                //继承自基窗体</p>
<p>{</p>
<pre><code>public Frm_Inherit()


{


    InitializeComponent();


}</code></pre><p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟007：继承窗体的本质！ 继承窗体实质上就是派生自基窗体的一个过程，它其实体现的是面向对象思想中的继承性。继承窗体中的基窗体相当于面向对象编程中提到的基类，而继承窗体则相当于子类或者派生类。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>使子窗体最大化显示</title>
    <url>/zh-CN/2019/10/03/e4-bd-bf-e5-ad-90-e7-aa-97-e4-bd-93-e6-9c-80-e5-a4-a7-e5-8c-96-e6-98-be-e7-a4-ba.html</url>
    <content><![CDATA[<h2 id="使子窗体最大化显示"><a href="#使子窗体最大化显示" class="headerlink" title="使子窗体最大化显示"></a>使子窗体最大化显示</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在MDI窗体应用程序中打开子窗体时，一般都是以默认大小打开的，但在实际应用中，经常需要使子窗体在第一次打开时就以最大化方式打开，那么如何来实现这样的功能呢？本实例使用C#实现了这样的功能，实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0838_1.png" alt=""></p>
<p>图1 使子窗体最大化显示</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时主要用到了窗体的IsMdiContainer属性、MdiParent属性和WindowState属性，下面对本实例用到的关键技术进行详细讲解。</p>
<p>WindowState属性用来获取或设置窗体的窗口状态，其语法格式如下：</p>
<p>public FormWindowState WindowState { get; set; }</p>
<p>参数说明</p>
<p>R 属性值：FormWindowState枚举值之一，表示窗体的窗口状态。FormWindowState枚举值及说明如表1所示。</p>
<p>表1 FormWindowState枚举值及说明</p>
<p>枚举值</p>
<p>描述</p>
<p>Maximized</p>
<p>最大化的窗口</p>
<p>Minimized</p>
<p>最小化的窗口</p>
<p>Normal</p>
<p>默认大小的窗口</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0838_2.png" alt=""></p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为MaxChildForm。</p>
<p>（2）更改默认窗体Form1的Name属性为Frm_Main，并将其IsMdiContainer属性设置为True，以便作为父窗体。在Frm_Main窗体中添加一个Button控件，用来以最大化方式打开子窗体。</p>
<p>（3）在项目中添加一个Windows窗体，命名为Frm_Child.cs，用来作为要调用的子窗体。</p>
<p>（4）程序主要代码如下：</p>
<p>private void button1_Click(object sender, EventArgs e)</p>
<p>{</p>
<p>Frm_Child frm = new Frm_Child();                        //创建子窗体对象</p>
<p>frm.MdiParent = this;                                //设置子窗体的父窗体为当前窗体</p>
<p>frm.WindowState = FormWindowState.Maximized;            //设置子窗体最大化显示</p>
<p>frm.Show();                                    //显示子窗体</p>
<p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟002：什么是MDI窗体？</p>
<p>MDI（Multiple-Document Interface）窗体即多文档窗体，它主要用于同时显示多个文档，每个文档显示在各自的窗口中。MDI窗体中通常有包含子菜单的窗口菜单，以便在窗口或文档之间进行切换。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>使应用程序在进程中消失</title>
    <url>/zh-CN/2019/10/03/e4-bd-bf-e5-ba-94-e7-94-a8-e7-a8-8b-e5-ba-8f-e5-9c-a8-e8-bf-9b-e7-a8-8b-e4-b8-ad-e6-b6-88-e5-a4-b1.html</url>
    <content><![CDATA[<h2 id="使应用程序在进程中消失"><a href="#使应用程序在进程中消失" class="headerlink" title="使应用程序在进程中消失"></a>使应用程序在进程中消失</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>开发应用程序时，有的窗体可能需要隐藏，比如从登录窗体进入主窗体时，通常都对登录窗体进行隐藏，这样一来，当关闭主窗体时，如果调用Close方法，可能就会只关闭主窗体，而应用程序其实并没有退出，本实例将在关闭窗体时彻底的关闭应用程序。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0823_1.png" alt=""></p>
<p>图1 使应用程序在进程中消失</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时主要用到了Application类的Exit方法，下面进行详细讲解。</p>
<p>Application类提供static方法和属性以管理应用程序，例如启动和停止应用程序、处理Windows消息的方法和获取应用程序信息的属性等，其Exit方法用来通知所有消息泵必须终止，并且在处理了消息以后关闭所有应用程序窗口，它有两种重载形式，分别如下：</p>
<p>public static void Exit()</p>
<p>public static void Exit(CancelEventArgs e)</p>
<p>参数说明</p>
<p>R e：返回应用程序中的任何Form窗体是否已经取消退出。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为DisposeForm。</p>
<p>（2）更改默认窗体Form1的Name属性为Frm_Main，并为该窗体设置指定的背景图片。在Frm_Main窗体中添加一个Button控件，用来执行退出应用程序操作。</p>
<p>（3）程序主要代码如下：</p>
<p>private void button1_Click(object sender, EventArgs e)</p>
<p>{</p>
<p>Application.Exit();                            //退出应用程序</p>
<p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟006：什么是进程？</p>
<p>每个正在操作系统上运行的应用程序都是一个进程，一个进程可以包括一个或多个线程，而线程是操作系统分配处理器时间的基本单元，在进程中可以有多个线程同时执行代码。</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>使用主从表查看生产单详细信息</title>
    <url>/zh-CN/2020/03/02/e4-bd-bf-e7-94-a8-e4-b8-bb-e4-bb-8e-e8-a1-a8-e6-9f-a5-e7-9c-8b-e7-94-9f-e4-ba-a7-e5-8d-95-e8-af-a6-e7-bb-86-e4-bf-a1-e6-81-af.html</url>
    <content><![CDATA[<h2 id="使用主从表查看生产单详细信息"><a href="#使用主从表查看生产单详细信息" class="headerlink" title="使用主从表查看生产单详细信息"></a>使用主从表查看生产单详细信息</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在数据库应用程序开发中，经常需要将主从表关联起来查询数据。本实例把生产厂家和商品通过厂家编号关联起来，然后输出各种商品的名称、开始生产日期及生产厂家等相关信息。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2020/03/030220_0402_1.png" alt=""></p>
<p>图1 使用主从表查看生产单详细信息</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在使实现时主要用到了OleDbDataAdapter类的构造方法和DbDataAdapter类的Fill方法，下面对本实例中用到的关键技术进行详细讲解。 （1）OleDbDataAdapter类的构造方法 该方法实现创建一个适配器对象，该对象用于填充数据集和更新数据源。该方法的重载形式有多种，本实例用到的方法如下：</p>
<p>public OleDbDataAdapter(string selectCommandText, string selectConnectionString)</p>
<p>参数说明 selectCommandText：一个字符串，它是 SQL SELECT 语句或将由OleDbDataAdapter的SelectCommand属性使用的存储过程。 selectConnectionString：数据库连接字符串。 （2）DbDataAdapter类的Fill方法 该方法实现在DataSet 的指定范围中添加或刷新行以匹配使用DataSet、DataTable和IDataReader 名称的数据源中的行。该方法的重载形式有多种，本实例用到的方法如下：</p>
<p>public int Fill(DataTable dataTable)</p>
<p>参数说明 dataTable：用于表映射的DataTable 的名称。 返回值：已在DataSet 中成功添加或刷新的行数，这不包括受不返回行的语句影响的行。</p>
<p>说明：OleDbDataAdapter类继承自DbDataAdapter抽象基类，所以OleDbDataAdapter类的对象可以调用抽象基类的Fill方法。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为FromTable。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个DataGridView控件，用来显示数据；添加一个Button控件，用来实现查询数据。 （3）程序主要代码如下： 自定义类DataTier，在该类中定义一个GetDate方法，该方法实现从主从数据表中获取DataTable类型的数据源，具体代码如下：</p>
<p>public DataTable GetDate()<br>{<br>    string P_Connection = string.Format(                                //创建数据库连接字符串<br>    “Provider=Microsoft.Jet.OLEDB.4.0;Data Source=test.mdb;User Id=Admin”);<br>    OleDbDataAdapter P_DataAdapter = new OleDbDataAdapter(                    //创建数据适配器对象<br>    @”select id as 编号,Name as 名称,Begin as 开始时间,<br>Factory as 配件厂家名称,Phone as 电话,Address as 联系地址 from [tb_Ware]<br>inner join [tb_Number] on [tb_Ware].Number=[tb_Number].Number”, P_Connection);<br>    DataTable dt = new DataTable();                                    //创建数据表<br>    P_DataAdapter.Fill(dt);                                        //填充数据表<br>    return dt;                                                    //返回数据表<br>}<br>单击窗体的”查询详细信息”按钮，实现把数据源绑定到DataGridView控件，具体代码如下：<br>private void btn_Get_Click(object sender, EventArgs e)<br>{<br>    dgv_Message.DataSource = new DataTier().GetDate();                        //绑定到数据表<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟016：关联主从表。 编写关联主从表的Transact-SQL语句，可使用Inner Join 逻辑运算符。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>使用口令加密可执行文件</title>
    <url>/zh-CN/2019/08/06/e4-bd-bf-e7-94-a8-e5-8f-a3-e4-bb-a4-e5-8a-a0-e5-af-86-e5-8f-af-e6-89-a7-e8-a1-8c-e6-96-87-e4-bb-b6.html</url>
    <content><![CDATA[<h2 id="使用口令加密可执行文件"><a href="#使用口令加密可执行文件" class="headerlink" title="使用口令加密可执行文件"></a>使用口令加密可执行文件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>exe可执行文件的加密是软件加密技术的一个重要部分，本实例讲解如何在C#中使用口令加密exe可执行文件。运行本实例，如果用户选择的是exe文件，则输入加密口令，单击“加密”按钮，加密选择的exe文件；如果用户选择的是mrexe文件，则输入加密时用的口令，单击“打开”按钮，打开加密过的exe文件。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-06-04272713.png" alt=""> 图1 使用口令加密可执行文件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>使用口令加密可执行文件，顾名思义就是在打开加密过的可执行文件时，需要先输入口令，然后才能打开，这时就需要将使用口令加密过的可执行文件的菜单项写入到注册表中，以便打开使用口令加密过的可执行文件时直接弹出“输入口令”对话框。在使用口令加密过的可执行文件的菜单项写入到注册表中时，需要用到RegistryKey类的CreateSubKey方法和SetValue方法，下面分别对它们进行详细讲解。 （1）CreateSubKey方法 RegistryKey类表示Windows注册表中的项级节点，它位于Microsoft.Win32命名空间下，其CreateSubKey方法主要用来创建一个新子项或打开一个现有子项以进行写访问，语法格式如下： public RegistryKey CreateSubKey(string subkey) 参数说明 subkey：要创建或打开的子项的名称或路径。 返回值：RegistryKey对象，表示新建的子项或null（如果操作失败）。如果为subkey指定了零长度字符串，则返回当前的RegistryKey对象。 技巧：要获取RegistryKey的实例，请使用Registry类的静态成员之一。 （2）SetValue方法 SetValue方法用来设置注册表项中的名称/值对的值，其语法格式如下： public void SetValue(string name,Object value) name：要存储的值的名称。 value：要存储的数据。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为EncryptExe。 （2）在默认窗体Form1中主要添加如表1所示的控件。 表1 Form1窗体主要用到的控件及说明</p>
<p>控件类型</p>
<p>控件名称</p>
<p>属性设置</p>
<p>说 明</p>
<p>textBox1</p>
<p>无</p>
<p>显示选择的加密或解密EXE文件</p>
<p>textBox2</p>
<p>PasswordChar属性设置为*</p>
<p>输入加密或解密密码</p>
<p>button1</p>
<p>Text属性设置为“…”</p>
<p>选择要加密或解密的EXE文件</p>
<p>button2</p>
<p>Text属性设置为“加密”</p>
<p>加密EXE文件</p>
<p>button3</p>
<p>Text属性设置为“打开”</p>
<p>打开加密后的EXE文件</p>
<p>openFileDialog1</p>
<p>无</p>
<p>显示扫描进度</p>
<p>（3）程序主要代码如下： Form1窗体加载时，首先将exe加密文件菜单写入到注册表中，然后判断系统中是否有打开的exe加密文件，如果有，则将其显示到“请选择Exe文件”文本框中，实现代码如下：</p>
<p>private void Form1_Load(object sender, EventArgs e)<br>{<br>    FileMenu(Application.ExecutablePath + “,0”, Application.ExecutablePath);            //在注册表中创建exe加密文件菜单项<br>    string[] str = Environment.GetCommandLineArgs();                        //记录系统中的打开项<br>    try<br>    {<br>        string strFile = “”;                                            //用来记录文件名<br>        for (int i = 2; i &lt; str.Length; i++)<br>            strFile += str[i];                                         //为文件名赋值<br>        FileInfo FInfo = new FileInfo(strFile);                             //创建FileInfo对象<br>        if (FInfo.Extension.ToLower() == “.mrexe”)<br>            textBox1.Text = strFile;                                     //显示文件名<br>    }<br>    catch { }<br>}</p>
<p>向注册表中写入exe加密文件菜单时用到FileMenu方法，该方法为自定义的无返回值类型方法，主要用来向注册表中写入exe加密文件菜单，它有两个string类型的参数，分别用来表示exe加密程序环境变量及exe加密程序路径。FileMenu方法实现代码如下：</p>
<p>//创建快捷菜单<br>public static void FileMenu(string strPath, string strName)<br>{<br>    try<br>{<br>    //在注册表中创建exe加密文件子键<br>        Registry.ClassesRoot.CreateSubKey(“.mrexe”);<br>        RegistryKey RKey1 = Registry.ClassesRoot.OpenSubKey(“.mrexe”, true);         //打开新创建的子键<br>        RKey1.SetValue(“”, “mrexefile”);                                //为新创建的子键赋值<br>        RKey1.Close();                                            //关闭子键<br>        Registry.ClassesRoot.CreateSubKey(“mrexefile”);                        //创建mrexefile子键<br>        RegistryKey RKey2 = Registry.ClassesRoot.OpenSubKey(“mrexefile”, true);         //打开mrexefile子键<br>        RKey2.CreateSubKey(“DefaultIcon”);                                //创建DefaultIcon子键<br>        RKey2.CreateSubKey(“shell”);                                    //创建shell子键<br>        RKey2.Close();                                            //关闭子键<br>        //打开子键<br>        RegistryKey RKey3 = Registry.ClassesRoot.OpenSubKey(“mrexefile\\DefaultIcon”, true);<br>        RKey3.SetValue(“”, strPath);                                     //为子键设置值<br>        RKey3.Close();                                            //关闭子键<br>        //打开子键<br>        RegistryKey RKey4 = Registry.ClassesRoot.OpenSubKey(“mrexefile\\shell”, true);<br>        RKey4.CreateSubKey(“使用口令打开”);                            //创建子键<br>        RKey4.Close();                                            //关闭子键<br>        //打开子键<br>        RegistryKey RKey5 = Registry.ClassesRoot.OpenSubKey(“mrexefile\\shell\\使用口令打开”, true);<br>        RKey5.CreateSubKey(“command”);                                //创建子键<br>        RKey5.Close();                                            //关闭子键<br>        //打开子键<br>        RegistryKey RKey6 = Registry.ClassesRoot.OpenSubKey(“mrexefile\\shell\\使用口令打开\\command”, true);<br>        RKey6.SetValue(“”, strName + “ \\F %1”);                            //为子键设置值<br>        RKey6.Close();                                            //关闭子键<br>    }<br>    catch{}<br>}</p>
<p>注意：对注册表进行操作时，需要添加Microsoft.Win32命名空间。 单击“加密”按钮，首先判断是否选择要加密的exe文件，如果已经选择，则使用用户输入的加密密码对选择的exe文件进行加密，执行成功后弹出信息提示。“加密”按钮的Click事件代码如下：</p>
<p>//加密EXE文件<br>private void button2_Click(object sender, EventArgs e)<br>{<br>    string strPwd = textBox2.Text;                                    //记录加密密码<br>    byte[] btRKey = new byte[0];                                     //定义一个字节数组，用来记录加密密码<br>    if (strPwd.Length == 6)                                         //判断密码位数<br>    {<br>        btRKey = new byte[] { (byte)strPwd[0], (byte)strPwd[1], (byte)strPwd[2], (byte)strPwd[3], (byte)strPwd[4], (byte)strPwd[5], (byte)strPwd[0], (byte)strPwd[1] };                                                //记录加密密码<br>    }<br>    if (strPwd.Length == 7)<br>    {<br>        btRKey = new byte[] { (byte)strPwd[0], (byte)strPwd[1], (byte)strPwd[2], (byte)strPwd[3], (byte)strPwd[4], (byte)strPwd[5], (byte)strPwd[6], (byte)strPwd[0] };<br>    }<br>    if (strPwd.Length &gt;= 8)<br>    {<br>        btRKey = new byte[] { (byte)strPwd[0], (byte)strPwd[1], (byte)strPwd[2], (byte)strPwd[3], (byte)strPwd[4], (byte)strPwd[5], (byte)strPwd[6], (byte)strPwd[7] };<br>}<br>    //创建FileStream对象<br>    FileStream FStream = new FileStream(textBox1.Text, FileMode.Open, FileAccess.Read);<br>    //创建一个FileStream对象，用来创建加密文件<br>    FileStream NewFStream = new FileStream(textBox1.Text + “.mrexe”, FileMode.OpenOrCreate, FileAccess.Write);<br>    NewFStream.SetLength((long)0);                                     //设置加密文件初始长度为0<br>    byte[] buffer = new byte[0x400];                                     //定义一个字节数组<br>    int MinNum = 0;                                             //设置加密位置从0开始<br>    long length = FStream.Length;                                     //记录文件长度<br>    int MaxNum = (int)(length / ((long)0x400));                             //计算文件最大值<br>DES myDES = new DESCryptoServiceProvider();                            //创建DES加密流对象<br>//创建CryptoStream加密流对象<br>    CryptoStream CStream = new CryptoStream(NewFStream, myDES.CreateEncryptor(btRKey, btRKey), CryptoStreamMode.Write);<br>    while (MinNum &lt; length)<br>    {<br>        int count = FStream.Read(buffer, 0, 0x400);                             //对要加密的文件进行流读取<br>        CStream.Write(buffer, 0, count);                                 //向加密流中写入数据<br>        MinNum += count;                                         //记录已经读取的数据位置<br>    }<br>    CStream.Close();<br>    NewFStream.Close();<br>    FStream.Close();<br>    File.Delete(textBox1.Text);                                         //删除旧文件<br>    MessageBox.Show(“使用口令加密可执行文件成功！”, “信息提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>}</p>
<p>单击“打开”按钮，首先使用用户输入的解密密码对加密过的exe文件进行解密，然后使用Process类的Start方法打开解密过的exe文件。“打开”按钮的Click事件代码如下：</p>
<p>//解密EXE文件<br>private void button3_Click(object sender, EventArgs e)<br>{<br>    string strPwd = textBox2.Text;                                    //记录解密密码<br>    FileStream FStream = null;                                         //声明FileStream对象，用来记录旧文件<br>    FileStream NewFStream = null;                                     //声明FileStream对象，用来记录新文件<br>    CryptoStream CStream = null;                                     //声明CryptoStream对象，用来解密文件<br>    try<br>    {<br>        try<br>        {<br>            byte[] btRKey = new byte[0];                                 //定义一个字节数组，用来记录解密密码<br>            if (strPwd.Length == 6)                                     //判断密码位数<br>            {<br>                btRKey = new byte[] { (byte)strPwd[0], (byte)strPwd[1], (byte)strPwd[2], (byte)strPwd[3], (byte)strPwd[4], (byte)strPwd[5], (byte)strPwd[0], (byte)strPwd[1] };                                    //记录解密密码<br>            }<br>            if (strPwd.Length == 7)<br>            {<br>                btRKey = new byte[] { (byte)strPwd[0], (byte)strPwd[1], (byte)strPwd[2], (byte)strPwd[3], (byte)strPwd[4], (byte)strPwd[5], (byte)strPwd[6], (byte)strPwd[0] };<br>            }<br>            if (strPwd.Length &gt;= 8)<br>            {<br>                btRKey = new byte[] { (byte)strPwd[0], (byte)strPwd[1], (byte)strPwd[2], (byte)strPwd[3], (byte)strPwd[4], (byte)strPwd[5], (byte)strPwd[6], (byte)strPwd[7] };<br>            }<br>            //创建FileStream对象<br>            FStream = new FileStream(textBox1.Text, FileMode.Open, FileAccess.Read);<br>            //获取新文件名<br>            string strNewFile = textBox1.Text.Substring(0, textBox1.Text.Length - 6);<br>            //创建解密文件<br>            NewFStream = new FileStream(strNewFile, FileMode.OpenOrCreate, FileAccess.Write);<br>            NewFStream.SetLength((long)0);                             //设置解密文件初始长度为0<br>            byte[] buffer = new byte[0x400];                                 //定义一个字节数组<br>            int MinNum = 0;                                        //设置解密位置从0开始<br>            long length = FStream.Length;                                 //记录文件长度<br>            int MaxNum = (int)(length / ((long)0x400));                        //计算文件最大值<br>            DES myDES = new DESCryptoServiceProvider();                    //创建DES加解密对象<br>            //创建CryptoStream加解密流对象<br>            CStream = new CryptoStream(NewFStream, myDES.CreateDecryptor(btRKey, btRKey), CryptoStreamMode.Write);<br>            while (MinNum &lt; length)<br>            {<br>                int count = FStream.Read(buffer, 0, 0x400);                     //对要解密的文件进行流读取<br>                CStream.Write(buffer, 0, count);                             //向解密流中写入数据<br>                MinNum += count;                                     //记录已经读取的数据位置<br>            }<br>            CStream.Close();<br>            FStream.Close();<br>            NewFStream.Close();<br>            File.Delete(textBox1.Text);                                //删除加密文件<br>            System.Diagnostics.Process.Start(strNewFile);                        //打开解密后的exe文件<br>        }<br>        catch<br>        {<br>            MessageBox.Show(“口令错误！”, “信息提示”, MessageBoxButtons.OK, MessageBoxIcon.Error);<br>            textBox2.Focus();<br>        }<br>    }<br>    finally<br>    {<br>        CStream.Close();<br>        FStream.Close();<br>        NewFStream.Close();<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟005：获取文件的扩展名。 在处理文件操作的应用程序中，获取文件的扩展名信息很重要，可以使用FileInfo类的Extension属性获取文件的扩展名，本实例中使用该属性来判断指定文件是否为加密后的mrexe文件。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>使用对称算法加密解密文件</title>
    <url>/zh-CN/2019/08/06/e4-bd-bf-e7-94-a8-e5-af-b9-e7-a7-b0-e7-ae-97-e6-b3-95-e5-8a-a0-e5-af-86-e8-a7-a3-e5-af-86-e6-96-87-e4-bb-b6.html</url>
    <content><![CDATA[<h2 id="使用对称算法加密解密文件"><a href="#使用对称算法加密解密文件" class="headerlink" title="使用对称算法加密解密文件"></a>使用对称算法加密解密文件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用对称算法实现加密和解密文件，在本实例的对称算法加密窗体中，首先选择原文件路径，然后输入加密密码和加密后文件路径，最后单击“加密”按钮实现对原文件加密，如图1所示。在本实例的对称算法解密窗体中，首先选择要解密的原文件路径，然后输入解密密码和解密后文件路径，最后单击“解密”按钮实现对原文件解密，如图2所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-06-04322917.png" alt=""> 图1 对称算法加密窗体 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-06-04323346.png" alt=""> 图2 对称算法解密窗体</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例主要用到了DESCryptoServiceProvider类的CreateDecryptor方法和CryptoStream类的相关方法，关于CryptoStream类的相关方法请参考“对文本文件进行加密与解密”，下面主要对DESCryptoServiceProvider类的CreateDecryptor方法进行详细讲解。 DESCryptoServiceProvider类的CreateDecryptor方法使用指定的SymmetricAlgorithm.Key 属性和初始化向量SymmetricAlgorithm.IV来创建对称解密器对象。其语法格式如下： public abstract ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV) 参数说明 rgbKey：用于对称算法的密钥。 rgbIV：用于对称算法的初始化向量。 返回值：返回对称解密器对象。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，解决方案命名为SymmetricalEncrypt，项目名称命名为EncryptFile，作为实现加密的项目。然后添加一个新项目，命名为UnEncryptFile，作为实现解密的项目。 （2）在EncryptFile项目的默认窗体Form1中，添加3个文本框，分别用来显示原文件路径、输入加密密码和输入加密后的文件路径；添加两个Button控件，分别用来选择原文件和实现对文件的加密。对于UnEncryptFile项目的默认窗体Form1，该窗体上控件的设置情况可参考EncryptFile项目中Form1窗体的设置。 （3）程序主要代码如下： 在EncryptFile项目的默认窗体Form1中，单击“加密”按钮实现对原文件的加密，具体代码如下：</p>
<p>private void button2_Click(object sender, EventArgs e)<br>{<br>    string myFile = textBox1.Text;                                    //获取原文件路径<br>    string myPassword = textBox2.Text;                                    //获取加密密码<br>    string myEnFile = textBox3.Text;                                    //获取加密后的文件路径<br>    try<br>    {<br>        byte[] myIV = { 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF };            //设置向量<br>        byte[] myKey = System.Text.Encoding.UTF8.GetBytes(myPassword);            //设置密钥<br>        //原文件的文件流<br>        FileStream myInStream = new FileStream(myFile, FileMode.Open, FileAccess.Read);<br>        //加密后文件的文件流<br>        FileStream myOutStream = new FileStream(myEnFile, FileMode.OpenOrCreate, FileAccess.Write);<br>        myOutStream.SetLength(0);                                    //初始文件流的长度<br>        byte[] myBytes = new byte[100];                                //定义缓冲区<br>        long myInLength = 0;                                        //定义不断变化的流的长度<br>        long myLength = myInStream.Length;                                //获取原文件的文件流的长度<br>        DES myProvider = new DESCryptoServiceProvider();                    //定义标准的加密算法实例<br>//实现将数据流链接到加密转换的流<br>        CryptoStream myCryptoStream = new CryptoStream(myOutStream, myProvider.CreateEncryptor(myKey, myIV), CryptoStreamMode.Write);<br>        //从原文件流中每次读取100个字节，然后写入加密转换的流<br>        while (myInLength &lt; myLength)<br>        {<br>            int mylen = myInStream.Read(myBytes, 0, 100);                    //读取原文件流<br>            myCryptoStream.Write(myBytes, 0, mylen);                        //写入加密转换的流<br>            myInLength += mylen;                                    //计算写入的流长度<br>        }<br>        myCryptoStream.Close();                                    //关闭资源<br>        myInStream.Close();<br>        myOutStream.Close();<br>        MessageBox.Show(“加密文件成功！”, “提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>    }<br>    catch (Exception ex)<br>    {<br>        MessageBox.Show(ex.Message, “提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>    }<br>}</p>
<p>在UnEncryptFile项目的默认窗体Form1中，单击“解密”按钮实现对原文件的解密，具体代码如下：</p>
<p>private void button2_Click(object sender, EventArgs e)<br>{<br>    string str1 = textBox1.Text;                                        //获取原文件路径<br>    string strPwd = textBox2.Text;                                    //获取解密密码<br>    string str2 = textBox3.Text;                                        //获取解密后的文件路径<br>    try<br>    {<br>        byte[] myIV = { 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF };            //设置向量<br>        byte[] myKey = System.Text.Encoding.UTF8.GetBytes(strPwd);                //设置密钥<br>        //原文件的文件流<br>        FileStream myFileIn = new FileStream(str1, FileMode.Open, FileAccess.Read);<br>        //解密后文件的文件流<br>        FileStream myFileOut = new FileStream(str2, FileMode.OpenOrCreate, FileAccess.Write);<br>        myFileOut.SetLength(0);                                    //初始化文件流的长度<br>        byte[] myBytes = new byte[100];                                //定义缓冲区<br>        long myLength = myFileIn.Length;                                //获取原文件流的长度<br>        long myInLength = 0;                                        //定义不断变化的流的长度<br>        DES myProvider = new DESCryptoServiceProvider();                    //定义标准的加密算法实例<br>//实现将数据流链接到解密转换的流<br>        CryptoStream myDeStream = new CryptoStream(myFileOut, myProvider.CreateDecryptor(myKey, myIV), CryptoStreamMode.Write);<br>        //从原文件流中每次读取100个字节，然后写入解密转换的流<br>        while (myInLength &lt; myLength)<br>        {<br>            int mylen = myFileIn.Read(myBytes, 0, 100);                        /读取原文件流<br>            myDeStream.Write(myBytes, 0, mylen);                            //写入解密转换的流<br>            myInLength += mylen;                                    //计算写入的流长度<br>        }<br>        myDeStream.Close();                                        //关闭资源<br>        myFileOut.Close();<br>        myFileIn.Close();<br>        MessageBox.Show(“解密文件成功！”, “提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>    }<br>    catch (Exception ex)<br>    {<br>        MessageBox.Show(ex.Message, “提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟004：关于加密与解密过程的总结。 从上面的两段加密和解密代码中可以看出，加密与解密的过程基本相同。首先都是获取原文件的文件流和加密（或解密）后的文件流，然后将原数据流链接到加密（或解密）转换的流，最后把原文件流写入加密（或解密）转换的流。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>使用继承选择器创建继承窗体</title>
    <url>/zh-CN/2019/10/03/e4-bd-bf-e7-94-a8-e7-bb-a7-e6-89-bf-e9-80-89-e6-8b-a9-e5-99-a8-e5-88-9b-e5-bb-ba-e7-bb-a7-e6-89-bf-e7-aa-97-e4-bd-93.html</url>
    <content><![CDATA[<h2 id="使用继承选择器创建继承窗体"><a href="#使用继承选择器创建继承窗体" class="headerlink" title="使用继承选择器创建继承窗体"></a>使用继承选择器创建继承窗体</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>开发Windows窗体应用程序时，项目可能需要一个与在以前的项目中创建的窗体类似的窗体，或者，希望创建一个基窗体，其中含有随后将在项目中再次使用的控件布局之类的设置，每次重复使用时，都会对该基窗体模板进行修改，这时，就可以使用C#中的继承窗体来实现。本实例将使用继承选择器来创建一个继承窗体，本实例中的基窗体和继承窗体运行效果分别如图1和图2所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0830_1.png" alt=""></p>
<p>图1 基窗体</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0830_2.png" alt=""></p>
<p>图2 继承窗体</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例的重点是掌握什么是基窗体和继承窗体，下面分别对它们进行详细讲解。</p>
<p>基窗体，实质上相当于面向对象编程中提到的基类，而下面将要讲解到的继承窗体则是子类或者派生类。继承窗体实质上就是派生自基窗体的一个过程。</p>
<p>继承窗体实际上就是根据现有窗体的结构创建一个与其一样的新窗体，而我们将这种从现有窗体继承的过程称为可视化继承。在某种情况下，通过从基窗体继承来创建新Windows窗体是重复工作成果的最有效方法。</p>
<p>说明：</p>
<p>（1）为了使用”继承选择器”对话框从某个窗体继承，包含该窗体的项目必须已经生成可执行文件或DLL；</p>
<p>（2）如果要生成项目，可以通过”生成”菜单实现。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为InheritFormByDesign。</p>
<p>（2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个Label控件，用来显示文字信息。</p>
<p>（3）在”解决方案资源管理器”面板中，选中项目名称，单击鼠标右键。在弹出的右键菜单中选择”添加”/“新建项”选项，打开”添加新项”对话框，如图3所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0830_3.png" alt=""></p>
<p>图3 “添加新项”对话框</p>
<p>（4）在”添加新项”对话框中选择”继承的窗体”，并输入窗体名称，单击”添加”按钮，打开”继承选择器”对话框，如图4所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0830_4.png" alt=""></p>
<p>图4 “继承选择器”对话框</p>
<p>（5）在”继承选择器”对话框中单击”浏览”按钮，选择要继承的基窗体，单击”确定”按钮，完成继承窗体的创建。</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟006：使用继承窗体快速提高程序开发效率！</p>
<p>程序中添加继承窗体时，在”继承选择器”对话框中单击”浏览”按钮之后，可以在打开的对话框中选择其他项目中的窗体作为基窗体，从而快速的提高程序的开发效率。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>使用缓冲流复制文件</title>
    <url>/zh-CN/2019/07/29/e4-bd-bf-e7-94-a8-e7-bc-93-e5-86-b2-e6-b5-81-e5-a4-8d-e5-88-b6-e6-96-87-e4-bb-b6.html</url>
    <content><![CDATA[<h2 id="使用缓冲流复制文件"><a href="#使用缓冲流复制文件" class="headerlink" title="使用缓冲流复制文件"></a>使用缓冲流复制文件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在使用缓冲流时，需要用到System.IO命名空间下的BufferedStream类。在本实例中，首先选择要复制的源文件，然后设置该文件被赋值的目标路径，最后单击“复制文件”按钮实现复制文件到指定的路径。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-28-17100277.png" alt=""> 图1 使用缓冲流复制文件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>BufferedStream流，也称作缓冲流，它实现给另一个流上的读写操作添加一个缓冲层。缓冲流在内存中创建一个缓冲区，它会以最有效率的增量从磁盘中读取字节到缓冲区。缓冲区是内存中的字节块，用于缓存数据，从而减少对操作系统的调用次数，缓冲区可提高读取和写入性能。本实例主要用到了BufferedStream类的Read方法、Write方法和Flush方法，下面对本实例用到的关键技术进行详细讲解。 （1）BufferedStream类的Read方法 该方法实现将字节从当前缓冲流复制到数组。其语法格式如下： public override int Read(byte[] array, int offset, int count) Read方法语法中的参数说明如表1所示。 表1 Read方法语法中的参数说明</p>
<p>参数</p>
<p>说明</p>
<p>array</p>
<p>将字节复制到的缓冲区</p>
<p>offset</p>
<p>位置索引，从此处开始读取字节</p>
<p>count</p>
<p>要读取的字节数</p>
<p>返回值</p>
<p>读入 array 字节数组中的总字节数。如果可用的字节没有所请求的那么多，总字节数可能小于请求的字节数；或者如果在可读取任何数据前就已到达流的末尾，则为零</p>
<p>（2）BufferedStream类的Write方法 该方法实现将字节复制到缓冲流，并将缓冲流内的当前位置前进写入的字节数，其语法格式如下： public override void Write(byte[] array, int offset, int count) Write方法语法中的参数说明如表2所示。 表2 Write方法语法中的参数说明</p>
<p>参数</p>
<p>说明</p>
<p>array</p>
<p>字节数组，从该字节数组将 count 个字节复制到当前缓冲流中</p>
<p>offset</p>
<p>缓冲区中的偏移量，从此处开始将字节复制到当前缓冲流中</p>
<p>count</p>
<p>要写入当前缓冲流中的字节数</p>
<p>返回值</p>
<p>无返回值</p>
<p>（3）BufferedStream类的Flush方法 该方法实现清除该流的所有缓冲区，使得所有缓冲的数据都被写入到基础设备。其语法格式如下： public override void Flush() <img data-src="https://cdn.fesugar.com/2019/07/2019-07-28-17100387.png" alt="说明"> 技巧：由于缓冲流在内存的缓冲区中直接读写数据，而不是从磁盘中直接读写数据，所以它处理大容量的文件尤为适合。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为OperateBufferedStream。 （2）在默认窗体Form1中添加TextBox控件，分别用来显示源文件和目标文件路径，添加两个Button控件，分别用来选择源文件和设置目标路径。 （3）程序主要代码如下：</p>
<p>private void button3_Click(object sender, EventArgs e)<br>{<br>    try<br>    {<br>        string str1 = textBox1.Text;                            //获取包含路径的源文件<br>        string str2 = textBox2.Text + “\&quot; + textBox1.Text.Substring(textBox1.Text.LastIndexOf(“\&quot;) + 1, textBox1.Text.Length - textBox1.Text.LastIndexOf(“\&quot;) - 1);                            //获取包含路径的目标文件<br>        Stream myStream1, myStream2;                        //声明两个Stream类型的引用<br>        BufferedStream myBStream1, myBStream2;                    //声明两个缓冲流的引用<br>        byte[] myByte = new byte[1024];                        //创建容量为1024字节的缓冲区<br>        int i;<br>        myStream1 = File.OpenRead(str1);                        //以读取的方式打开源文件<br>        myStream2 = File.OpenWrite(str2);                        //以写入的方式打开目标文件<br>        myBStream1 = new BufferedStream(myStream1);                //创建源文件缓冲流<br>        myBStream2 = new BufferedStream(myStream2);                //创建目标文件缓冲流<br>        i = myBStream1.Read(myByte, 0, 1024);                    //把字节从当前缓冲流复制到数组<br>        while (i &gt; 0)                                    //若复制到数组中的字节数大于零<br>        {<br>            myBStream2.Write(myByte, 0, i);                        //把字节数组中的数据复制到缓冲流<br>            i = myBStream1.Read(myByte, 0, 1024);                //把字节从当前缓冲流复制到数组<br>        }<br>        myBStream2.Flush();                                //清除流的缓冲区<br>        myStream1.Close();                                //关闭流，释放资源<br>        myBStream2.Close();<br>        MessageBox.Show(“文件复制完成”);<br>    }<br>    catch(Exception ex)<br>    {<br>        MessageBox.Show(ex.Message);<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟013：使用缓冲流的Flush方法。 在缓冲流中写入数据完毕之后，需要调用该缓冲流的Flush方法清除该流的所有缓冲区，并使所有缓冲的数据都被写入到基础设备。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>使用cmd删除系统所有的账户</title>
    <url>/zh-CN/2018/09/05/e4-bd-bf-e7-94-a8cmd-e5-88-a0-e9-99-a4-e7-b3-bb-e7-bb-9f-e6-89-80-e6-9c-89-e7-9a-84-e8-b4-a6-e6-88-b7.html</url>
    <content><![CDATA[<p>WMIC扩展WMI（Windows Management Instrumentation，Windows管理工具） ，提供了从命令行接口和批命令脚本执行系统管理的支持 使用 WMIC 命令获取用户名如下 wmic useraccount get name 删除用户名使用如下命令 net user  …  /del 可以使用for循环来查找并删除</p>
<p>@echo off<br>for /f “delims=” %%i in (‘wmic useraccount get name^’) do (net user %%i /del &amp; echo %%i)</p>
<p>pause</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>CMD</tag>
        <tag>Windows</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ROT13算法加密解密文件</title>
    <url>/zh-CN/2019/08/06/e4-bd-bf-e7-94-a8rot13-e7-ae-97-e6-b3-95-e5-8a-a0-e5-af-86-e8-a7-a3-e5-af-86-e6-96-87-e4-bb-b6.html</url>
    <content><![CDATA[<h2 id="使用ROT13算法加密解密文件"><a href="#使用ROT13算法加密解密文件" class="headerlink" title="使用ROT13算法加密解密文件"></a>使用ROT13算法加密解密文件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>文件加密可以避免造成重要信息的泄漏，复杂的加密算法可以将信息加密得非常繁杂，但是对于一般的应用，没有必要作类似于PGP、RSA或DES等复杂的加密算法，本实例介绍使用ROT13这种简单的加密和解密算法。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-06-0434508.png" alt=""> 图1 使用ROT13算法加密解密文件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例主要是用Convert类的ToChar方法来获取单个字符的Unicode编码，然后将字母的前13个和后13个对调，实现加密的功能。 ToChar方法返回指定的Unicode字符值；不执行任何实际的转换。其语法格式如下： public static char ToChar (char value) 参数说明 value：一个Unicode字符。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为ROT13Encrypt。 （2）在默认窗体Form1中添加两个文本框，分别用来显示原始数据和解密后的数据；添加两个Button控件，分别用来实现加密和解密数据。 （3）程序主要代码如下：</p>
<p>private void button1_Click(object sender, EventArgs e)                        //使用ROT13算法加密数据<br>{<br>    textBox2.Text= ROT13Encode(textBox1.Text);<br>}<br>public string ROT13Encode(string InputText)                            //ROT13算法<br>{<br>    char tem_Character;                                        //定义字符变量<br>    int UnicodeChar;                                        //表示一个Unicode字符<br>    string EncodedText = “”;                                    //表示加密或解密后的字符串<br>    //遍历字符串中的所有字符，只能加密字符串，无法加密汉字<br>    for (int i = 0; i &lt; InputText.Length; i++)<br>    {<br>        tem_Character = System.Convert.ToChar(InputText.Substring(i, 1));        //获取字符串中指定的字符<br>        UnicodeChar = (int)tem_Character;                            //获取当前字符的Unicode编码<br>        if (UnicodeChar &gt;= 97 &amp;&amp; UnicodeChar &lt;= 109)                    //对字符进行加密<br>        {<br>            UnicodeChar = UnicodeChar + 13;<br>        }<br>        else if (UnicodeChar &gt;= 110 &amp;&amp; UnicodeChar &lt;= 122)                //对字符进行解密<br>        {<br>            UnicodeChar = UnicodeChar - 13;<br>        }<br>        else if (UnicodeChar &gt;= 65 &amp;&amp; UnicodeChar &lt;= 77)                    //对字符进行加密<br>        {<br>            UnicodeChar = UnicodeChar + 13;<br>        }<br>        else if (UnicodeChar &gt;= 78 &amp;&amp; UnicodeChar &lt;= 90)                    //对字符进行解密<br>        {<br>            UnicodeChar = UnicodeChar - 13;<br>        }<br>        EncodedText = EncodedText + (char)UnicodeChar;                    //返回设置后的字符<br>    }<br>    return EncodedText;<br>}<br>private void button2_Click(object sender, EventArgs e)                        //使用ROT13算法解密数据<br>{<br>    textBox2.Text = ROT13Encode(textBox2.Text);<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟003：关于ROT13加密算法的总结。 ROT13是一种简单的加密方式，主要是把26个英文字母的前13个和后13个对调，起到一定的英文文字加密保护作用。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>修改继承窗体中的控件属性</title>
    <url>/zh-CN/2019/10/03/e4-bf-ae-e6-94-b9-e7-bb-a7-e6-89-bf-e7-aa-97-e4-bd-93-e4-b8-ad-e7-9a-84-e6-8e-a7-e4-bb-b6-e5-b1-9e-e6-80-a7.html</url>
    <content><![CDATA[<h2 id="修改继承窗体中的控件属性"><a href="#修改继承窗体中的控件属性" class="headerlink" title="修改继承窗体中的控件属性"></a>修改继承窗体中的控件属性</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>创建继承窗体之后，如果不做任何修改，那么继承窗体的运行结果将与基窗体的运行结果一模一样，但这显然不是开发人员要用到继承窗体的初衷。程序开发人员在用到继承窗体时，不可能全部使用基窗体中原来的功能，而没有新扩展的功能，这时就遇到一个问题：如何扩展基窗体的功能，以便在继承窗体中使用呢？本实例以扩展基窗体中的控件功能为例讲解如何扩展基窗体的功能。在本程序中分别运行基窗体和继承窗体，它们的运行效果分别如图1和图2所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0829_1.png" alt=""></p>
<p>图1 基窗体中的控件文本</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0829_2.png" alt=""></p>
<p>图2 继承窗体中的控件文本</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在修改继承窗体中控件的属性时，主要用到了控件的Modifiers属性，下面对该属性进行详细讲解。 Modifiers属性用来指定控件对象的可见性级别，它是Visual Studio 2008开发环境提供的一个属性，该属性的属性值及说明如表1所示。 表1 Modifiers属性的属性值及说明</p>
<p>属性值</p>
<p>描述</p>
<p>Private</p>
<p>可访问域限定在类的内部</p>
<p>Protected</p>
<p>只能从其所在类和所在类的子类进行访问</p>
<p>Protected Internal</p>
<p>同一个程序集中的所有类，以及所有程序集中的子类都可以访问</p>
<p>Internal</p>
<p>可访问域限定在类所在的程序内部</p>
<p>Public</p>
<p>访问不受限制，可以在类内和任何类以外的代码中进行访问</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为EditInheritForm。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个Button控件，设置其Text属性为”C#编程词典”，并将其Modifiers属性设置为Public，如图3所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0829_3.png" alt=""></p>
<p>图3 设置Modifiers属性</p>
<p>说明：这里也可以将button1控件的Modifiers属性设置为Protected或者Protected Internal。</p>
<p>（3）按使用继承选择器创建继承窗体中所讲解的步骤添加一个继承窗体，命名为Frm_Inherit.cs，该窗体继承自Frm_Main，在继承窗体Frm_Inherit中即可修改继承的button1控件的属性。比如，这里将button1控件的Text属性重新设置为”C#范例大全”。</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟008：继承窗体的使用场合！ 尽管继承窗体的出现非常讨人喜欢，但它并非没有局限性。例如，开发人员不可能在继承窗体中增加或者减少基窗体中的菜单项，也不可能替换掉基窗体中的菜单事件处理程序。然而，作为一种避免复制控件和代码的模板机制，继承窗体在很多时候都值得程序开发人员去考虑使用。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>像Excel一样复制DataGridView中数据</title>
    <url>/zh-CN/2019/10/03/e5-83-8fexcel-e4-b8-80-e6-a0-b7-e5-a4-8d-e5-88-b6datagridview-e4-b8-ad-e6-95-b0-e6-8d-ae.html</url>
    <content><![CDATA[<h2 id="像Excel一样复制DataGridView中数据"><a href="#像Excel一样复制DataGridView中数据" class="headerlink" title="像Excel一样复制DataGridView中数据"></a>像Excel一样复制DataGridView中数据</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在使用DataGridView控件显示数据时，有时需要对无规律性的数据进行显示，在这种情况下是无法用代码进行筛选的，本实例完成在DataGridView控件中像Excel一样对单元格复制的操作，以实现显示任意选择区域的单元格。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0848_ExcelDataG1.png" alt=""></p>
<p>图1 像Excel一样复制DataGridView中数据</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现时主要用到了Clipboard类，该类提供将数据置于系统剪贴板中以及从中检索数据的方法。在本实例的实现过程中，首先把在DataGridView控件中选中的内容添加到剪贴版中，然后再用Clipboard类读取剪贴版中的信息。Clipboard类的常用方法及说明如表1所示。 表1 Clipboard类的常用方法及说明</p>
<p>枚举值</p>
<p>说明</p>
<p>Clear</p>
<p>从剪贴板中移除所有数据</p>
<p>ContainsAudio</p>
<p>指示在剪贴板中是否存在WaveAudio格式的数据</p>
<p>ContainsData</p>
<p>指示剪贴板中是否存在指定格式的数据，或可转换成此格式的数据</p>
<p>ContainsFileDropList</p>
<p>指示剪贴板中是否存在FileDrop格式或可转换成此格式的数据</p>
<p>ContainsImage</p>
<p>指示剪贴板中是否存在Bitmap格式或可转换成此格式的数据</p>
<p>ContainsText</p>
<p>已重载。指示剪贴板中是否存在文本数据</p>
<p>GetAudioStream</p>
<p>检索剪贴板上的音频流</p>
<p>GetData</p>
<p>从剪贴板中检索指定格式的数据</p>
<p>GetDataObject</p>
<p>检索当前位于系统剪贴板中的数据</p>
<p>GetFileDropList</p>
<p>从剪贴板中检索文件名的集合</p>
<p>GetImage</p>
<p>检索剪贴板上的图像</p>
<p>GetText</p>
<p>已重载。从剪贴板中检索文本数据</p>
<p>SetAudio</p>
<p>已重载。将WaveAudio格式的数据添加到剪贴板中</p>
<p>SetData</p>
<p>将指定格式的数据添加到剪贴板中</p>
<p>SetDataObject</p>
<p>已重载。将数据置于系统剪贴板中</p>
<p>SetFileDropList</p>
<p>将FileDrop格式的文件名集合添加到剪贴板中</p>
<p>SetImage</p>
<p>将Bitmap格式的Image添加到剪贴板中</p>
<p>SetText</p>
<p>已重载。将文本数据添加到剪贴板中</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为GetGridData。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个DataGridView控件，分别用来显示源数据和粘贴的数据；添加一个Button控件，用来实现复制数据。 （3）程序主要代码如下： 在dataGridView1控件中选择要复制的单元格，用button1控件的Click事件将dataGridView1控件中所选择的单元格内容添加到dataGridView2控件中。实现代码如下：</p>
<p>private void button1_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>str = CopyDataGridView(dataGridView1);                        //拷贝选中的数据


AddDataGridView(dataGridView2, str, Bool\_Blank, Bool\_All);            //粘贴数据</code></pre><p>}</p>
<p>  自定义方法CopyDataGridView用于将选中的单元格内容添加到剪贴板中，然后将剪贴版中的文本信息存入到字符串变量中。实现代码如下：</p>
<p>/// <summary></p>
<p>/// 通过剪贴板复制DataGridView控件中所选中的内容.</p>
<p>/// </summary></p>
<p>/// <param DGView="DataGridView">DataGridView类</param></p>
<p>/// <return>字符串</return></p>
<p>public string CopyDataGridView(DataGridView DGView)</p>
<p>{</p>
<pre><code>string tem_str = &quot;&quot;;


if (DGView.GetCellCount(DataGridViewElementStates.Selected) &gt; 0)


{


    try


    {


        Clipboard.SetDataObject(DGView.GetClipboardContent());        //将数据添加到剪贴板中


        tem_str = Clipboard.GetText();                        //从剪贴板中获取信息


    }


    catch (System.Runtime.InteropServices.ExternalException)


    {


        return &quot;&quot;;


    }


}


return tem_str;</code></pre><p>}</p>
<p>  自定义方法AddDataGridView是通过在剪贴版中获得的文本信息，按照文本中字符串的相应格式，以及单元格的相应位置，将其添加到dataGridView2控件中。实现代码如下：</p>
<p>/// <summary></p>
<p>/// 将字符串按指定的格式添加到DataGridView控件中（如果有被选中的单元格，则修改单元格中的内容）.</p>
<p>/// </summary></p>
<p>/// <param DGView="DataGridView">DataGridView类</param></p>
<p>/// <param s="string">要替换的单元格字符串</param></p>
<p>/// <param Blank="bool">标识，如果是空格是否替换成空格</param></p>
<p>/// <param All="bool">标识，是否全部替换</param></p>
<p>public void AddDataGridView(DataGridView DGView, string s, bool Blank, bool All)</p>
<p>{</p>
<pre><code>string tem_str = s;


int tem_n = 0;


int RowCount = 0;                                    //行数


int CellCount = 0;                                    //列数


bool tem_bool = true;


string tem_s = &quot;&quot;;


if (s.IndexOf(&quot;\\r\\n&quot;) != -1)                                //如果替换的为多行


    while (tem_bool)                                    //获取单元格的行数和列数


    {


        tem_s = &quot;&quot;;


        if (tem_str.IndexOf(&quot;\\r\\n&quot;) != -1)                        //如果获取的不是最后一行


        {


            tem\_s = tem\_str.Substring(0, tem_str.IndexOf(&quot;\\r\\n&quot;) + 2);    //获取当前行中的数据


            //获取当前行中能被识别的数据


            tem\_str = tem\_str.Substring(tem\_str.IndexOf(&quot;\\r\\n&quot;) + 2, tem\_str.Length - tem_str.IndexOf(&quot;\\r\\n&quot;) – 2);


            tem_n = 1;


            while (tem_s.IndexOf(&quot;\\t&quot;) &gt; -1)                    //遍历当前行中的空格


            {


                //去除已读取的空格


                tem\_s = tem\_s.Substring(tem\_s.IndexOf(&quot;\\t&quot;) + 1, tem\_s.Length - tem_s.IndexOf(&quot;\\t&quot;) - 1);


                tem_n += 1;                            //获取列数


            }


            if (tem_n &gt; CellCount)                        //判断当前列数是否为最大列数


                CellCount = tem_n;                        //获取最大的列数


        }


        else                                        //如果读取的是最后一行


        {


            tem_n = 1;


            while (tem_s.IndexOf(&quot;\\t&quot;) &gt; -1)


            {


                tem\_s = tem\_s.Substring(tem\_s.IndexOf(&quot;\\t&quot;) + 1, tem\_s.Length - tem_s.IndexOf(&quot;\\t&quot;) - 1);


                tem_n += 1;


            }


            if (tem_n &gt; CellCount)


                CellCount = tem_n;


            tem_bool = false;                            //遍历结束


        }


        ++RowCount;                                //读取行数


    }


else                                            //如果读取的为单行数据


{


    tem_n = 1;


    tem_s = s;


    while (tem_s.IndexOf(&quot;\\t&quot;) &gt; -1)


    {


        tem\_s = tem\_s.Substring(tem\_s.IndexOf(&quot;\\t&quot;) + 1, tem\_s.Length - tem_s.IndexOf(&quot;\\t&quot;) - 1);


        tem_n += 1;


    }


    if (tem_n &gt; CellCount)


        CellCount = tem_n;


    ++RowCount;                                    //读取行数


}


string\[,\] Strarr = new string\[RowCount, CellCount\];                //定义一个数组，用于记录复制的单元格信息


tem_str = s;


tem_n = 0;


//将单元格信息添加到数组中


for (int i = 0; i &lt; RowCount; i++)                            //遍历单元格的行


{


    for (int j = 0; j &lt; CellCount; j++)                        //遍历单元格的列


    {


        tem_s = &quot;&quot;;


        if (tem_str.IndexOf(&quot;\\r\\n&quot;) != -1)                        //如果不是最后一行


        {


            if (tem_str.IndexOf(&quot;\\t&quot;) &lt;= -1)                    //设置读取数据的位置


                tem\_n = tem\_str.IndexOf(&quot;\\r&quot;);                    //最后一个数据的位置


            else


                tem\_n = tem\_str.IndexOf(&quot;\\t&quot;);                    //不是最后一个数据的位置


            //读取单元格数据


            tem\_s = tem\_str.Substring(0, tem_str.IndexOf(&quot;\\r\\n&quot;) + 2);


        }


        else                                        //如果是最后一行


        {


            if (tem_str.IndexOf(&quot;\\t&quot;) &lt;= -1)                    //设置读取数据的位置


                tem\_n = tem\_str.Length;                    //最后一个数据的位置


            else


                tem\_n = tem\_str.IndexOf(&quot;\\t&quot;);                    //不是最后一个数据的位置


            tem\_s = tem\_str;                            //读取单元格数据


        }


        if (tem_s.Length &gt; 0)                            //如果当前行有数据


        {


            if (tem_s.Substring(0, 1) == &quot;\\t&quot;)                    //如果第一个字符为空


                Strarr\[i, j\] = &quot;&quot;;                            //向数组中添加一个空记录


            else


            {


                Strarr\[i, j\] = tem\_s.Substring(0, tem\_n);            //向数组中添加数据


            }


        }


        else


            Strarr\[i, j\] = &quot;&quot;;                            //向数组中添加空记录


        if (tem\_s.Length &gt; tem\_n)                            //如果记录没有读取完


            //获取没有读取的记录


            tem\_str = tem\_s.Substring(tem\_n + 1, tem\_s.Length - tem_n - 1);


    }


    if (s.IndexOf(&quot;\\r\\n&quot;) &gt; -1)                            //如果不是最后一行数据


    {


        //读取下一行数据


        s = s.Substring(s.IndexOf(&quot;\\r\\n&quot;) + 2, s.Length - s.IndexOf(&quot;\\r\\n&quot;) - 2);


        tem_str = s;


    }


}


if (All)                                             //如果要全部替换


    DGView.Rows.Clear();                                //清空DataGridView控件


//如果DataGridView中没有数据


if (DGView.SelectedRows.Count == 0 &amp;&amp; DGView.SelectedCells.Count == 0)


{


    DGView.ColumnCount = CellCount;                        //设置列数


    string\[\] stra = new string\[CellCount\];                        //定义一个一维数组


    //向DataGridView中添加行数据


    for (int i = 0; i &lt; RowCount; i++)                        //读取行


    {


        for (int j = 0; j &lt; CellCount; j++)                        //读取列


        {


            if (Strarr\[i, j\] == &quot;&quot;)                            //如果当前单元格为空


            {


                if (Blank)                                //如果用*号替换


                    stra\[j\] = &quot;*&quot;;                        //在空单元格中添加*号


                else


                    stra\[j\] = &quot;&quot;;                            //以空格显示空单元格


            }


            else


            {


                stra\[j\] = Strarr\[i, j\];                        //记录当前行中的信息


            }


        }


        DGView.Rows.Add(stra);                            //将行中的信息添加到DataGridView控件


    }


    DGView.AutoResizeColumns();                        //向DataGridView添加所有的单元格信息


    //将所选择的单元格复制到剪贴板中


    DGView.ClipboardCopyMode = DataGridViewClipboardCopyMode.EnableWithoutHeaderText;


}


else                                            //如果DataGridView中有数据


{


    int maxrow = 0;                                    //记录DataGridView中最小单元格的行数


    int maxcell = 0;                                    //记录DataGridView中最小单元格的列数


    //获取选中单元格中最大单元格的行数和列数


    for (int i = 0; i &lt; DGView.SelectedCells.Count; i++)


    {


        if (DGView.SelectedCells\[i\].RowIndex &gt; maxrow)            //如果单元格的行数大于当前指定的行数


            maxrow = DGView.SelectedCells\[i\].RowIndex;            //记录当前单元格的行数


        if (DGView.SelectedCells\[i\].ColumnIndex &gt; maxcell)            //如果单元格的列数大于当前指定的列数


            maxcell = DGView.SelectedCells\[i\].ColumnIndex;        //记录当前单元格的列数


    }


    int minrow = maxrow;                                //记录DataGridView中最大单元格的行数


    int mincell = maxcell;                                //记录DataGridView中最大单元格的列数


    //获取选中单元格中最小单元格的行数和列数


    for (int i = 0; i &lt; DGView.SelectedCells.Count; i++)


    {


        if (DGView.SelectedCells\[i\].RowIndex &lt; minrow)             //如果单元格的行数小于当前指定的行数


            minrow = DGView.SelectedCells\[i\].RowIndex;            //记录当前单元格的行数


        if (DGView.SelectedCells\[i\].ColumnIndex &lt; mincell)            //如果单元格的列数小于当前指定的列数


            mincell = DGView.SelectedCells\[i\].ColumnIndex;        //记录当前单元格的列数


    }


    //向DataGridView控件中添加选中单元格中最小单元格与最大单元格中的所有单元格


    for (int i = 0; i &lt; maxrow - (minrow - 1); i++)                    //遍历行数


    {


        if (i &gt;= RowCount)                                //如果超出要添加的行数


            break;                                    //退出循环


        for (int j = 0; j &lt; maxcell - (mincell - 1); j++)                //遍历列数


        {


            if (j &gt;= CellCount)                            //如果超出要添加的列数


                break;                                //退出循环


            if (Strarr\[i, j\] == &quot;&quot;)                            //如果添加的单元格为空


            {


                if (Blank)                                //如果用*号替换空格


                    //用*号替换空单元格


                    DGView.Rows\[i + minrow\].Cells\[j + mincell\].Value = &quot;*&quot;;


            }


            else


                //设置当前单元格的值


                DGView.Rows\[i + minrow\].Cells\[j + mincell\].Value = Strarr\[i, j\];


        }


    }


}</code></pre><p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟019：DataGridView控件的AutoResizeColumns方法。 DataGridView控件的AutoResizeColumns方法能够实现调整所有列的宽度以适应其所有单元格（包括标题单元格）的内容。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>关于C# JSON 数据传递方式</title>
    <url>/zh-CN/2016/10/14/e5-85-b3-e4-ba-8ec-json-e6-95-b0-e6-8d-ae-e4-bc-a0-e9-80-92-e6-96-b9-e5-bc-8f.html</url>
    <content><![CDATA[<p>我们都知道在互联网发展的初期时代,那时候采用的还是C/S架构的程序。 那么软件和软件传递的数据格式也从普通的文本转换到了XML这种格式化的存储格式文本。 那么在互联网移动互联网时代,这种C/S传递XML这种格式文件显然是不行的。 那么今天就来搞搞JSON。 我们来看看百度百科的解释： <a href="http://baike.baidu.com/view/136475.htm" target="_blank" rel="noopener">JSON</a>(<a href="http://baike.baidu.com/view/16168.htm" target="_blank" rel="noopener">JavaScript</a> Object Notation) 是一种轻量级的数据交换格式。它基于<a href="http://baike.baidu.com/view/810176.htm" target="_blank" rel="noopener">ECMAScript</a>的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括<a href="http://baike.baidu.com/subview/10075/6770152.htm" target="_blank" rel="noopener">C</a>、C++、<a href="http://baike.baidu.com/view/6590.htm" target="_blank" rel="noopener">C#</a>、<a href="http://baike.baidu.com/subview/29/12654100.htm" target="_blank" rel="noopener">Java</a>、JavaScript、<a href="http://baike.baidu.com/view/46614.htm" target="_blank" rel="noopener">Perl</a>、<a href="http://baike.baidu.com/view/21087.htm" target="_blank" rel="noopener">Python</a>等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。 百度百科链接:<a href="http://baike.baidu.com/link?url=iu5RKjFjmnM5DtVOSTzMl8MsTxdhPCCkKWOyMnsI4zP9DPSC_Bxf-J8ZvgTymL0lfaao21iY9z_40TalfJHhLK" target="_blank" rel="noopener">http://baike.baidu.com/link?url=iu5RKjFjmnM5DtVOSTzMl8MsTxdhPCCkKWOyMnsI4zP9DPSC_Bxf-J8ZvgTymL0lfaao21iY9z_40TalfJHhLK</a> 那么显然这种语言格式非常适合传递和解析，并且支持多种语言。 一个简单的JSON数据格式: 他包含了 一个KEY 和值 。写法是: {“KEY”:”VALUE”} <img data-src="https://cdn.fesugar.com/2016/11/2016-11-05-03591839.jpg" alt="0df431adcbef760976059b952edda3cc7cd99ea9"> 那么JSON 如果不支持负责的数据格式,那样显然是无法替代XML来作为传递的。 数组: [value,value] <img data-src="https://cdn.fesugar.com/2016/11/2016-11-05-03593478.jpg" alt="86d6277f9e2f0708c909280ae924b899a901f2a8"> 复杂的集合:list ,map 等 <img data-src="https://cdn.fesugar.com/2016/11/2016-11-05-0359473.jpg" alt="91ef76c6a7efce1bcb20cac0af51f3deb48f65b4"> 更加复杂的结合体: <img data-src="https://cdn.fesugar.com/2016/11/2016-11-05-04005035.jpg" alt="cefc1e178a82b90186abc139738da9773912efb2"> 再复杂一点: <img data-src="https://cdn.fesugar.com/2016/11/2016-11-05-04001530.jpg" alt="b8014a90f603738d66370e28b31bb051f819ecbf"> 显然，看到这里 ,JSON的传递显然会符合你的要求: 我们再来看下标准的写法:一个标准的Map&lt;List<Object>&gt; 写法。 非常清晰</p>
<p>{<br>    “people”:[<br>        {“firstName”:”Brett”,”lastName”:”McLaughlin”,”email”:”aaaa”},<br>        {“firstName”:”Jason”,”lastName”:”Hunter”,”email”:”bbbb”},<br>        {“firstName”:”Elliotte”,”lastName”:”Harold”,”email”:”cccc”}<br>    ]</p>
<p>一个复杂的Object 类:</p>
<p>{<br>    “programmers”: [{<br>        “firstName”: “Brett”,<br>        “lastName”: “McLaughlin”,<br>        “email”: “aaaa”<br>    }, {<br>        “firstName”: “Jason”,<br>        “lastName”: “Hunter”,<br>        “email”: “bbbb”<br>    }, {<br>        “firstName”: “Elliotte”,<br>        “lastName”: “Harold”,<br>        “email”: “cccc”<br>    }],<br>    “authors”: [{<br>        “firstName”: “Isaac”,<br>        “lastName”: “Asimov”,<br>        “genre”: “sciencefiction”<br>    }, {<br>        “firstName”: “Tad”,<br>        “lastName”: “Williams”,<br>        “genre”: “fantasy”<br>    }, {<br>        “firstName”: “Frank”,<br>        “lastName”: “Peretti”,<br>        “genre”: “christianfiction”<br>    }],<br>    “musicians”: [{<br>        “firstName”: “Eric”,<br>        “lastName”: “Clapton”,<br>        “instrument”: “guitar”<br>    }, {<br>        “firstName”: “Sergei”,<br>        “lastName”: “Rachmaninoff”,<br>        “instrument”: “piano”<br>    }]<br>}</p>
<p>说了这么多，开始正题,用C# 去操作JSON 然后进行传递数据，那么今天的教程只会写到如何生成和解析JSON 数据 在C#中操作JSON 数据的类库有很多,这里我们用到Newtonsoft.Json.dll 这个动态库。 那么引入进去之后我们就要开始干活了，在Java 中常常喜欢讲操作以Utils 定义,而C#喜欢用Helper 来定义。那还是遵循C#的归还,我们来定义一个 JsonHelper.cs</p>
<p>using Newtonsoft.Json;<br>using Newtonsoft.Json.Converters;<br>using System.IO;</p>
<p>namespace Helper<br>{<br>    public class JsonHelper<br>    {<br>        /// <summary><br>        /// 将对象序列化为JSON格式<br>        /// </summary><br>        /// <param name="o">对象</param><br>        /// <returns>json字符串</returns><br>        public static string SerializeObject(object o)<br>        {<br>            string json = JsonConvert.SerializeObject(o);<br>            return json;<br>        }</p>
<pre><code>    /// &lt;summary&gt;
    /// 解析JSON字符串生成对象实体
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;T&quot;&gt;对象类型&lt;/typeparam&gt;
    /// &lt;param name=&quot;json&quot;&gt;json字符串(eg.{&quot;ID&quot;:&quot;112&quot;,&quot;Name&quot;:&quot;石子儿&quot;})&lt;/param&gt;
    /// &lt;returns&gt;对象实体&lt;/returns&gt;
    public static T DeserializeJsonToObject&lt;T&gt;(string json) where T : class
    {
        JsonSerializer serializer = new JsonSerializer();
        StringReader sr = new StringReader(json);
        object o = serializer.Deserialize(new JsonTextReader(sr), typeof(T));
        T t = o as T;
        return t;
    }

    /// &lt;summary&gt;
    /// 解析JSON数组生成对象实体集合
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;T&quot;&gt;对象类型&lt;/typeparam&gt;
    /// &lt;param name=&quot;json&quot;&gt;json数组字符串(eg.\[{&quot;ID&quot;:&quot;112&quot;,&quot;Name&quot;:&quot;石子儿&quot;}\])&lt;/param&gt;
    /// &lt;returns&gt;对象实体集合&lt;/returns&gt;
    public static List&lt;T&gt; DeserializeJsonToList&lt;T&gt;(string json) where T : class
    {
        JsonSerializer serializer = new JsonSerializer();
        StringReader sr = new StringReader(json);
        object o = serializer.Deserialize(new JsonTextReader(sr), typeof(List&lt;T&gt;));
        List&lt;T&gt; list = o as List&lt;T&gt;;
        return list;
    }

    /// &lt;summary&gt;
    /// 反序列化JSON到给定的匿名对象.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;T&quot;&gt;匿名对象类型&lt;/typeparam&gt;
    /// &lt;param name=&quot;json&quot;&gt;json字符串&lt;/param&gt;
    /// &lt;param name=&quot;anonymousTypeObject&quot;&gt;匿名对象&lt;/param&gt;
    /// &lt;returns&gt;匿名对象&lt;/returns&gt;
    public static T DeserializeAnonymousType&lt;T&gt;(string json, T anonymousTypeObject)
    {
        T t = JsonConvert.DeserializeAnonymousType(json, anonymousTypeObject);
        return t;
    }
}</code></pre><p>}</p>
<p>文中大多数是用实体转换过来的。那么我们在操作JSON 的时候最归还的做法是定义一个类,然后将该类实例化,最后进行转换。 如一个学生类:</p>
<p>namespace bean<br>{<br>    public class bean<br>    {<br>        /// <summary><br>        /// 该操作ID 方便操作<br>        /// </summary><br>        private String id;</p>
<pre><code>public String Id
{
    get { return id; }
    set { id = value; }
}
/// &lt;summary&gt;
/// name
/// &lt;/summary&gt;
private String name;

public String Name
{
    get { return name; }
    set { name= value; }
}

/// &lt;summary&gt;
/// age
/// &lt;/summary&gt;
private int age;

public int age
{
    get { return age; }
    set { age= value; }
}</code></pre><p>} }</p>
<p>然后我们将类实例化:</p>
<p>Bean bean = new Bean();<br>bean.Id = “1234”;<br>bean.name = “test”;<br>bean.age = 12;</p>
<p>这步搞定之后,我们就需要生成JSON 数据了:</p>
<p>String json = JsonHelper.SerializeObject(bean);</p>
<p>OK,那么这样就生成成功了，我们来看看</p>
<p>{“id”:”1234”,”name”:”test”,”age”:12}</p>
<p>显然这样是非常直观的，那么我们再将反转成对象。</p>
<p>Bean bean = (Bean)JsonHelper.DeserializeJsonToObject({“id”:”1234”,”name”:”test”,”age”:12});</p>
<p>非常简单对不对。ok 这里我们就完成了JSON 的简单操作。更加复杂的LIST 和Map 这些可以参照API 自行解决。</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>创建一个文件用于写入UTF-8编码的文本</title>
    <url>/zh-CN/2019/08/03/e5-88-9b-e5-bb-ba-e4-b8-80-e4-b8-aa-e6-96-87-e4-bb-b6-e7-94-a8-e4-ba-8e-e5-86-99-e5-85-a5utf-8-e7-bc-96-e7-a0-81-e7-9a-84-e6-96-87-e6-9c-ac.html</url>
    <content><![CDATA[<h2 id="创建一个文件用于写入UTF-8编码的文本"><a href="#创建一个文件用于写入UTF-8编码的文本" class="headerlink" title="创建一个文件用于写入UTF-8编码的文本"></a>创建一个文件用于写入UTF-8编码的文本</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例实现创建一个UTF-8编码格式的文件（以创建文本文件为例），首先在窗体中设置文件路径，然后输入要写入文本文件的内容，最后单击“创建”按钮实现将文本内容以UTF-8编码格式写入文本文件。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-03-03300052.png" alt=""> 图1 创建一个文件用于写入UTF-8编码的文本</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时主要用到了File类的CreateText方法和StreamWriter类的WriteLine方法，下面分别对它们进行详细讲解。 （1）File类的CreateText方法 该方法实现创建或打开一个文件用于写入 UTF-8 编码的文本。其语法格式如下： public static StreamWriter CreateText(string path) 参数说明 path：要打开以进行写入的文件。 返回值：一个 System.IO.StreamWriter，它使用 UTF-8 编码写入指定的文件。 （2）StreamWriter类的WriteLine方法 该方法实现将后跟行结束符的字符串写入文本流。该方法的重载形式有多种，本实例用到方法如下： public virtual void WriteLine(string value) 参数说明 value：要写入的字符串。如果 value 为 null，则仅写入行结束字符。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-03-03300453.png" alt="说明"> 说明：本实例创建的文件为UTF-8编码格式的文本文件（*.txt）。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为WriteUTF8File。 （2）在默认窗体Form1中添加两个文本框，分别用来设置文件路径和输入要写入文件的内容；添加两个Button控件，分别用来设置文件路径和创建并写入文件内容。 （3）程序主要代码如下：</p>
<p>private void button2_Click(object sender, EventArgs e)<br>{<br>    if (String.IsNullOrEmpty(textBox1.Text.Trim()))                //若文件路径为空<br>    {<br>        MessageBox.Show(“请设置文件路径！”);<br>        return;<br>    }<br>    if (String.IsNullOrEmpty(textBox2.Text.Trim()))                //若文本内容为空<br>    {<br>        MessageBox.Show(“请输入文件内容！”);<br>        return;<br>    }<br>    if (!File.Exists(textBox1.Text))<br>    {<br>        using (StreamWriter sw = File.CreateText(textBox1.Text))        //创建用于写入 UTF-8 编码的文本<br>        {<br>            sw.WriteLine(textBox2.Text);                    //把字符串写入文本流<br>            MessageBox.Show(“文件创建成功”, “提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>        }<br>    }<br>    else<br>    {<br>        MessageBox.Show(“该文件已经存在”, “提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟001：using语句的使用。 使用using语句创建实现了IDisposable接口的类，当using语句块结束后，程序会自动调用IDisposable接口的Dispose方法来销毁创建的实例。本实例代码中的StreamWriter类实现了IDisposable接口，所以使用using语句将其进行创建。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>创建并写入二进制文件数据</title>
    <url>/zh-CN/2019/08/02/e5-88-9b-e5-bb-ba-e5-b9-b6-e5-86-99-e5-85-a5-e4-ba-8c-e8-bf-9b-e5-88-b6-e6-96-87-e4-bb-b6-e6-95-b0-e6-8d-ae.html</url>
    <content><![CDATA[<h2 id="创建并写入二进制文件数据"><a href="#创建并写入二进制文件数据" class="headerlink" title="创建并写入二进制文件数据"></a>创建并写入二进制文件数据</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例实现创建并写入二进制文件数据，首先选择要创建的文件的目录，然后设置文件的名称，最后单击“创建”按钮。实例运行结果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-02-1156032.png" alt=""> 图1 创建并写入二进制文件数据</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时主要用到了BinaryWriter类的构造方法和Write方法，下面对本实例中用到的关键技术进行详细讲解。 （1）BinaryWriter类的构造法方法 该方法实现基于所提供的流，用 UTF-8 作为字符串编码来初始化BinaryWriter 类的新实例。其语法格式如下： public BinaryWriter(Stream output) 参数说明 output：表示输出流。 （2）BinaryWriter类的Write方法 该方法实现将 4 字节有符号整数写入当前流，并将流的位置提升 4 个字节。该方法语法格式如下： public virtual void Write(int value) 参数说明 value：要写入的 4 字节有符号整数。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-02-11560620.png" alt="注意"> 注意：为了与其它文件类型进行区分，本实例中创建的文件均以bin为扩展名。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为WriteBinaryFile。 （2）在默认窗体Form1中添加两个TextBox控件，分别用来设置文件路径和文件名称；添加两个Button控件，分别用来选择文件路径和创建二进制文件。 （3）程序主要代码如下：</p>
<p>private void button2_Click(object sender, EventArgs e)<br>{<br>    if (String.IsNullOrEmpty(textBox1.Text.Trim()))                    //若文件路径为空<br>    {<br>        MessageBox.Show(“请选择文件路径”);<br>        return;<br>    }<br>    if (String.IsNullOrEmpty(textBox2.Text.Trim()))                    //若文件名称为空<br>    {<br>        MessageBox.Show(“请设置文件名称”);<br>        return;<br>    }<br>    try<br>{<br>    //创建文件流对象<br>        FileStream myStream = new FileStream(textBox1.Text + “\&quot; + textBox2.Text+”.bin”, FileMode.Create);<br>        BinaryWriter myWriter = new BinaryWriter(myStream);            //创建BinaryWriter对象以写入二进制文件<br>        for (int i = 0; i &lt; 10; i++)//<br>        {<br>            myWriter.Write(i);                                //将整数写入当前流<br>        }<br>        myWriter.Close();                                //关闭当前资源和基础流<br>        myStream.Close();                                //关闭文件流<br>        MessageBox.Show(“创建并写入成功！”);<br>    }<br>    catch(Exception ex)<br>    {<br>        MessageBox.Show(ex.Message);<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟011：以创建模式创建FileStream对象。 通常使用FileStream类的构造方法来创建一个已知文件的文件流，若把构造方法的枚举参数值改为FileMode.Create，则会以创建模式创建FileStream对象，这样程序将创建一个新文件。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>创建Excel文件并保存</title>
    <url>/zh-CN/2019/08/25/e5-88-9b-e5-bb-baexcel-e6-96-87-e4-bb-b6-e5-b9-b6-e4-bf-9d-e5-ad-98.html</url>
    <content><![CDATA[<h2 id="创建Excel文件并保存"><a href="#创建Excel文件并保存" class="headerlink" title="创建Excel文件并保存"></a>创建Excel文件并保存</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例通过使用C#语言来实现Excel文件的创建与保存功能，运行本实例，如图1所示，单击“选择”按钮，在弹出的对话框中选择Excel文件的保存位置，然后单击“创建”按钮，即可在计算机的指定位置创建一个Excel文件，如图2所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-01205056.png" alt=""> 图1 创建Excel文件并保存 图2 创建完的Excel文件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在创建和保存Excel文件时，分别用到了Excel自动化对象模型的Workbooks对象的Add方法及Workbook对象的SaveCopyAs方法，下面对本实例用到的关键技术进行详细讲解。 （1）Workbooks对象的Add方法 该方法主要用来创建一个新的工作簿，其语法格式如下： Workbook Add([In, Optional] object Template); 参数说明 Template：指定是否添加工作簿，如果为true，表示添加；否则，表示不添加。 返回值：返回Workbook类型，表示一个Excel工作簿。 （2）Workbook对象的SaveCopyAs方法 该方法主要用来将工作簿的副本保存到文件中，但不修改内存中打开的工作簿，其语法格式如下： public virtual void SaveCopyAs(Object Filename) 参数说明 Filename：指定要保存的Excel副本的文件名。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为CreateExcel。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个TextBox控件，用来显示选择的Excel文件保存路径；添加两个Button控件，分别用来执行选择Excel文件保存路径操作和创建Excel文件操作。 （3）程序主要代码如下：</p>
<p>private void btn_Create_Click(object sender, EventArgs e)<br>{<br>string P_str_path = txt_Path.Text;                                    //记录路径<br>//创建Excel对象<br>Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.Application();<br>//添加新工作簿<br>    Microsoft.Office.Interop.Excel.Workbook newWorkBook = excel.Application.Workbooks.Add(true);<br>    object missing = System.Reflection.Missing.Value;                        //获取缺少的object类型值<br>    newWorkBook.Worksheets.Add(missing, missing, missing, missing);                //向Excel文件中增加工作表<br>if (P_str_path.EndsWith(“\&quot;))                                        //判断路径是否\结尾<br>//保存Excel文件<br>        newWorkBook.SaveCopyAs(P_str_path + DateTime.Now.ToString(“yyyyMMddhhmmss”) + “.xls”);<br>else<br>//保存Excel文件<br>        newWorkBook.SaveCopyAs(P_str_path + “\&quot; + DateTime.Now.ToString(“yyyyMMddhhmmss”) + “.xls”);<br>//弹出提示信息<br>MessageBox.Show(“Excel文件创建成功”, “提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>//创建进程对象<br>    System.Diagnostics.Process[] excelProcess = System.Diagnostics.Process.GetProcessesByName(“EXCEL”);<br>    foreach (System.Diagnostics.Process p in excelProcess)<br>        p.Kill();                                                //关闭进程<br>}</p>
<p>说明：（1）本实例在使用Excel对象时，首先需要添加该对象的引用，具体步骤为：选中当前项目，单击鼠标右键，在弹出的快捷菜单中选择“添加引用”选项，弹出“添加引用”对话框，如图3所示，该对话框中选中要引用的Excel动态链接库，这里选择“Microsoft.Office.Interop.Excel 11.0.0.0”，单击“确定”按钮，即可将Excel对象引用添加到程序中。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-0120546.png" alt=""> 图3 “添加引用”对话框 （2在后面的实例中，如果需要对Excel进行操作，则都需要按（1）所讲的步骤添加Excel对象引用，由于添加的步骤是一样的，所以在后面涉及到时将不再赘述。</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟028：使用Process类杀死进程。 Process类用来提供对本地和远程进程的访问并使用户能够启动和停止本地系统进程，其Kill方法用来立即停止关联的进程。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>创建Word文档</title>
    <url>/zh-CN/2019/09/10/e5-88-9b-e5-bb-baword-e6-96-87-e6-a1-a3.html</url>
    <content><![CDATA[<h2 id="创建Word文档"><a href="#创建Word文档" class="headerlink" title="创建Word文档"></a>创建Word文档</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>操作Word文档之前首先要创建Word文档，如果系统中已经安装Office办公软件，可以在文件夹中单击”右键”/“新建”/“Microsoft Word文档”来创建Word文档，那么，怎样使用C#来创建Word文档呢？这正是实例中将要介绍的内容，实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1530_Word1.png" alt=""></p>
<p>图1 使用C#创建Word文档</p>
<p>实例运行中单击”创建Word文档”按钮，会根据用户选择的路径位置创建Word文档，而文档的名称就是当前系统日期与时间。创建的Word文档如图2所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1530_Word2.png" alt=""></p>
<p>图2 创建的Word文档</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍怎样使用Documents集合的Add方法方便的创建Word文档，下面对本实例用到的关键技术进行详细讲解。 使用C#操作Word文档前首先要创建Word应用程序对象（Application对象），Application对象的Documents属性会返回Documents对象，Documents对象是Word应用程序打开的Word文档的集合，使用Documents对象的Add方法可以方便的创建Word文档。Add方法的语法格式如下：</p>
<p>Document Documents.Add(ref object Template, ref object NewTemplate, ref object DocumentType, ref object Visible);</p>
<p>Add方法中的参数说明如表1所示。 表1 Add方法中的参数说明</p>
<p>参数</p>
<p>描述</p>
<p>Template</p>
<p>创建Word文档所使用的模板，如果省略此参数Word会使用Normal模板</p>
<p>NewTemplate</p>
<p>是否将文档以模板形式打开，默认值为False</p>
<p>DocumentType</p>
<p>设定创建文档的类型，参数接收枚举成员，默认值为wdNewBlankDocument</p>
<p>Visible</p>
<p>打开的文档是否可见，默认值为True</p>
<p>注意：创建Word文档时可以根据Add方法的第一个参数(Template)来设置创建Word文档所使用的模板。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为NewWord。 （2）使用C#操作Word文档，首先要确定本地计算机中已经安装Office办公软件，实例中使用的Office版本为2003。只有安装Office2003后C#才可以引用与Word相关的COM组件。C#引用COM组件的具体步骤为：选中当前项目，单击鼠标右键，在弹出的快捷菜单中选择”添加引用”选项，弹出”添加引用”对话框，如图3所示。在”添加引用”对话框中单击”COM”选项卡，在选项卡中选中”Microsoft Word 11.0 Ojbect Library”项，单击”确定”按钮完成添加。成功添加”COM”组件的引用后，可以在程序代码中引用命名空间”using Word = Microsoft.Office.Interop.Word;”。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1530_Word3.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/09/091019_1530_Word4.png" alt=""></p>
<p>图3 添加COM组件</p>
<p>（3）更改默认窗体Form1的Name属性为Frm_Main，更改Text属性为”创建Word文档”，并向窗体中添加一个TextBox控件，此控件用于显示Word文档保存路径；向窗体中添加3个Button按钮，这3个按钮分别用于选择文档保存路径、创建Word文档和显示Word文档。 （4）程序主要代码如下：</p>
<p>private void btn_New_Click(object sender, EventArgs e)<br>{<br>    btn_New.Enabled = false;                                        //将新建按钮设置为不可用<br>    ThreadPool.QueueUserWorkItem(                                    //开始线程池<br>    (pp) =&gt;                                                //使用lambda表达式<br>{<br>        G_wa = new Microsoft.Office.Interop.Word.Application();                //创建应用程序对象<br>    object P_obj = “Normal.dot”;                                //定义文档模板<br>    Word.Document P_wd = G_wa.Documents.Add(                    //向Word应用程序中添加文档<br>    ref P_obj, ref G_missing, ref G_missing, ref G_missing);<br>        G_str_path = string.Format(                                //计算文件保存路径<br>    @”{0}\{1}”, G_FolderBrowserDialog.SelectedPath,<br>    DateTime.Now.ToString(“yyyy年M月d日h时s分m秒fff毫秒”) + “.doc”);<br>        P_wd.SaveAs(                                        //保存Word文件<br>    ref G_str_path,<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>    ref G_missing, ref G_missing, ref G_missing);<br>        ((Word._Application)G_wa.Application).Quit(                        //退出应用程序<br>    ref G_missing, ref G_missing, ref G_missing);<br>        this.Invoke(                                            //调用窗体线程<br>    (MethodInvoker)(() =&gt;                                //使用lambda表达式<br>{<br>        MessageBox.Show(“Word文档已经创建”, “提示！”);            //提示已经创建Word<br>    btn_display.Enabled = true;                            //启用显示按钮<br>}));<br>    });<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟002：通过Visible属性设置Word文档是否可见！ 在Form窗体编程中可以设置窗体的Visible属性从而控制窗体是否可见，使用C#操作Word文档时，则可以通过设置Application对象的Visible属性控制Word文档是否可见。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>利用折线图分析产品销售走势</title>
    <url>/zh-CN/2019/07/07/e5-88-a9-e7-94-a8-e6-8a-98-e7-ba-bf-e5-9b-be-e5-88-86-e6-9e-90-e4-ba-a7-e5-93-81-e9-94-80-e5-94-ae-e8-b5-b0-e5-8a-bf.html</url>
    <content><![CDATA[<h2 id="利用折线图分析产品销售走势"><a href="#利用折线图分析产品销售走势" class="headerlink" title="利用折线图分析产品销售走势"></a>利用折线图分析产品销售走势</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在商品销售企业中商品的销售额是决策者最关心的，及时、清晰、准确的分析产品销售走势是每个商业企业所必需的。本实例通过对某地区白金市场进行统计分析近半年白金价格的走势，实例运行结果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-07-09292184.png" alt=""> 图1 利用折线图分析产品销售走势</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时主要用到了Graphics类中的DrawLines方法、DrawLine方法和DrawString方法，下面对本实例中用到的关键技术进行详细介绍。 DrawLines方法用于绘制一系列连接一组Point结构的线段，其语法格式如下： public void DrawLines (Pen pen,Point[] points) 参数说明 pen：Pen，确定线段的颜色、宽度和样式。 points：Point结构数组，这些结构表示要连接的点。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为GoodsSallTrend。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个ComboBox控件，用来显示白金型号；添加一个Button控件，用来执行绘制折线图操作；添加一个Panel控件，用来显示描绘图；添加两个GroupBox控件，分别用来显示分析图和详细信息列表图。 （3）程序主要代码如下： 自定义DrowPic方法，用来绘制折线图来显示分析产品销售走势。代码如下：</p>
<p>private void DrowPic(string str)<br>{<br>    int MaxValue, MinValue;                                                //声明变量记录最大值和最小值<br>    using (cmd = new SqlCommand(“select Max(t_price) from tb_merchandise where t_name=’” + str + “‘“, con))<br>    {<br>        con.Open();                                                    //打开数据库连接<br>        MaxValue = Convert.ToInt16(cmd.ExecuteScalar());                                //获取最大值<br>        con.Close();                                                    //关闭数据库连接<br>    }<br>    using (cmd = new SqlCommand(“select Min(t_price) from tb_merchandise where t_name=’” + str + “‘“, con))<br>    {<br>        con.Open();                                                    //打开数据库连接<br>        MinValue = Convert.ToInt16(cmd.ExecuteScalar());                                //获取最小值<br>        con.Close();                                                    //关闭数据库连接<br>    }<br>    Graphics g = this.groupBox1.CreateGraphics();                                    //创建Graphics对象<br>    g.Clear(Color.SeaShell);                                                //设置背景<br>    Brush b = new SolidBrush(Color.Blue);                                        //创建Brush对象<br>    Font f = new Font(“Arial”, 9, FontStyle.Regular);                                    //创建Font对象<br>    Pen p=new Pen(b);                                                    //创建Pen对象<br>    using (sqlAda = new SqlDataAdapter(“select * from tb_merchandise where t_name=’” + str + “‘ order by t_date”, con))<br>    {<br>        ds = new DataSet();                                                //创建DataSet对象<br>        sqlAda.Fill(ds,”t_date”);                                                //Fill方法填充对象<br>        int M = MaxValue / 50+1;                                            //最大值<br>        int N = MinValue / 50;                                                //最小值<br>        int T = N;<br>       for(int i=0;i&lt;=M-N;i++)<br>       {<br>           g.DrawString(Convert.ToString(T * 50), f, b,0, 190 - 30 * i);<br>           g.DrawLine(p, 30, 200 - 30 * i, 260, 200 -30 * i);<br>           T++;<br>       }<br>       int Num = ds.Tables[0].Rows.Count;<br>       int[] Values = new int[Num];<br>       for (int C = 0; C &lt;Num; C++)<br>       {<br>           Values[C] =Convert.ToInt32(ds.Tables[0].Rows[C][3].ToString());<br>           g.DrawString(Convert.ToDateTime(ds.Tables[0].Rows[C][2].ToString()).Month + “月”, f, b, 30 * (C + 1)-10, 15);<br>           g.DrawLine(p, 30<em>(C+1), 200, 30</em>(C+1), 30);<br>       }<br>       Point[] P = new Point[Num];<br>       for (int i = 0; i &lt; Num; i++)<br>       {<br>           P[i].X=30<em>(i+1);<br>           P[i].Y = 290 - Convert.ToInt32(Values[i] / 50f</em> 30);<br>       }<br>       g.DrawLines(p, P);<br>    }<br>}<br>自定义DrowInfo方法，用来绘制提示信息来显示各种商品的出售情况。代码如下：<br>private void DrowInfo(string str)<br>{<br>    Graphics g = this.groupBox2.CreateGraphics();                                    //创建Graphics对象<br>    g.Clear(Color.SeaShell);                                                //设置背景颜色<br>    Brush b=new SolidBrush(Color.Blue);                                        //创建Brush对象<br>    Font f=new Font(“Arial”, 9, FontStyle.Regular);                                    //设置Font对象<br>    using (sqlAda = new SqlDataAdapter(“select * from tb_merchandise where t_name=’” + str + “‘ order by t_date”, con))<br>    {<br>        DataSet ds = new DataSet();                                            //创建DataSet对象<br>        sqlAda.Fill(ds, “tb_09”);                                                //Fill方法填充对象<br>        g.DrawString( “月份：       “ + “价格”, f, b, 10.0f,  25.0f);                        //绘制标题<br>        for (int i = 0; i &lt; ds.Tables[0].Rows.Count; i++)                                //绘制月份及相应的产品价格<br>        {<br>            int month=Convert.ToDateTime(ds.Tables[0].Rows[i][2].ToString()).Month;            //获取月份<br>            if (month &gt;= 10)<br>{<br>//绘制月份及价格<br>                g.DrawString(month + “月： “ + “『” + ds.Tables[0].Rows[i][3].ToString() + “ 』”, f, b, 10.0f, (i + 2) * 25.0f);<br>            }<br>            else<br>            {<br>                g.DrawString(“0”+month + “月： “ + “『” + ds.Tables[0].Rows[i][3].ToString() + “ 』”, f, b, 10.0f, (i + 2) * 25.0f);<br>            }<br>        }<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟008：如何清空控件的背景色？ 清空控件背景色时，可以使用Graphics类的Clear方法来实现，例如，本实例中清空GroupBox控件的背景色的实现代码如下：</p>
<p>Graphics g = this.groupBox2.CreateGraphics();                                        //创建Graphics对象<br>g.Clear(Color.SeaShell);                                                    //设置背景颜色</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>删除Excel文件中指定的工作表</title>
    <url>/zh-CN/2019/08/25/e5-88-a0-e9-99-a4excel-e6-96-87-e4-bb-b6-e4-b8-ad-e6-8c-87-e5-ae-9a-e7-9a-84-e5-b7-a5-e4-bd-9c-e8-a1-a8.html</url>
    <content><![CDATA[<h2 id="删除Excel文件中指定的工作表"><a href="#删除Excel文件中指定的工作表" class="headerlink" title="删除Excel文件中指定的工作表"></a>删除Excel文件中指定的工作表</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例演示如何使用C#语言实现删除Excel文件中指定工作表的功能。运行本实例，如图1所示，首先单击“选择”按钮，选择指定的Excel文件，这时程序自动将选中Excel文件所包含的所有工作表名称添加到一个下拉列表中，选择一个工作表名称，单击“删除”按钮，即可删除Excel文件中指定的工作表。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-01123879.png" alt="{1228CA3D-FE68-4BB8-911B-8D6A8AE9C6FB}"> 图1 删除Excel文件中指定的工作表 例如，删除“Book1.xls”工作簿中的Sheet2工作表，其删除前后的效果分别如图2和图3所示。。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-01124465-1.png" alt=""> 图2 删除前的Excel文件 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-01124779.png" alt=""> 图3 删除后的Excel文件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在删除Excel文件中指定的工作表时，主要用到了Excel自动化对象模型的Workbook对象的Sheets属性的Delete方法，下面对其进行详细讲解。 Workbook对象的Sheets属性用来获取一个Microsoft.Office.Interop.Excel.Sheets集合，该集合表示工作簿中的所有工作表，该属性的Delete方法用来删除指定的工作表其语法格式如下： void Delete();</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为DeleteSheet。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个TextBox控件，用来显示选择的Excel文件路径；添加一个ComboBox控件，用来显示指定Excel文件中的所有工作表名称；添加两个Button控件，分别用来执行打开Excel文件和删除Excel文件中指定工作表的操作。 （3）程序主要代码如下： private void btn_Delete_Click(object sender, EventArgs e) { //创建Excel对象 Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.ApplicationClass(); object missing = Missing.Value; //获取缺少的object类型值 //打开指定的Excel文件 Microsoft.Office.Interop.Excel.Workbook workbook = excel.Application.Workbooks.Open(txt_Path.Text, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing); //删除选择的工作表 ((Microsoft.Office.Interop.Excel.Worksheet)workbook.Sheets[cbox_SheetName.Text]).Delete(); MessageBox.Show(“工作表删除成功！”); excel.Application.DisplayAlerts = false; //不显示提示对话框 workbook.Save(); //保存工作表 CBoxBind(); //对下拉列表进行数据绑定 //创建进程对象 System.Diagnostics.Process[] excelProcess = System.Diagnostics.Process.GetProcessesByName(“EXCEL”); foreach (System.Diagnostics.Process p in excelProcess) p.Kill(); //关闭进程 }</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟031：如何在保存Excel时不显示提示对话框？ 如果要在保存Excel时不显示提示对话框，可以通过设置Excel对象的DisplayAlerts属性为false来实现。</p>
<h2 id="删除Excel文件中指定的工作表-1"><a href="#删除Excel文件中指定的工作表-1" class="headerlink" title="删除Excel文件中指定的工作表"></a>删除Excel文件中指定的工作表</h2><h3 id="实例说明-1"><a href="#实例说明-1" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例演示如何使用C#语言实现删除Excel文件中指定工作表的功能。运行本实例，如图1所示，首先单击“选择”按钮，选择指定的Excel文件，这时程序自动将选中Excel文件所包含的所有工作表名称添加到一个下拉列表中，选择一个工作表名称，单击“删除”按钮，即可删除Excel文件中指定的工作表。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-01123884.png" alt="{1228CA3D-FE68-4BB8-911B-8D6A8AE9C6FB}"> 图1 删除Excel文件中指定的工作表 例如，删除“Book1.xls”工作簿中的Sheet2工作表，其删除前后的效果分别如图2和图3所示。。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-01124465.png" alt=""> 图2 删除前的Excel文件 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-01124884.png" alt=""> 图3 删除后的Excel文件</p>
<h3 id="关键技术-1"><a href="#关键技术-1" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在删除Excel文件中指定的工作表时，主要用到了Excel自动化对象模型的Workbook对象的Sheets属性的Delete方法，下面对其进行详细讲解。 Workbook对象的Sheets属性用来获取一个Microsoft.Office.Interop.Excel.Sheets集合，该集合表示工作簿中的所有工作表，该属性的Delete方法用来删除指定的工作表其语法格式如下： void Delete();</p>
<h3 id="设计过程-1"><a href="#设计过程-1" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为DeleteSheet。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个TextBox控件，用来显示选择的Excel文件路径；添加一个ComboBox控件，用来显示指定Excel文件中的所有工作表名称；添加两个Button控件，分别用来执行打开Excel文件和删除Excel文件中指定工作表的操作。 （3）程序主要代码如下：</p>
<p>private void btn_Delete_Click(object sender, EventArgs e)<br>{<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.ApplicationClass();<br>    object missing = Missing.Value;                        //获取缺少的object类型值<br>    //打开指定的Excel文件<br>Microsoft.Office.Interop.Excel.Workbook workbook = excel.Application.Workbooks.Open(txt_Path.Text, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>//删除选择的工作表<br>    ((Microsoft.Office.Interop.Excel.Worksheet)workbook.Sheets[cbox_SheetName.Text]).Delete();<br>    MessageBox.Show(“工作表删除成功！”);<br>    excel.Application.DisplayAlerts = false;                    //不显示提示对话框<br>    workbook.Save();                                //保存工作表<br>CBoxBind();                                    //对下拉列表进行数据绑定<br>//创建进程对象<br>    System.Diagnostics.Process[] excelProcess = System.Diagnostics.Process.GetProcessesByName(“EXCEL”);<br>    foreach (System.Diagnostics.Process p in excelProcess)<br>        p.Kill();                                    //关闭进程<br>}</p>
<h3 id="秘笈心法-1"><a href="#秘笈心法-1" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟031：如何在保存Excel时不显示提示对话框？ 如果要在保存Excel时不显示提示对话框，可以通过设置Excel对象的DisplayAlerts属性为false来实现。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>利用折线图分析彩票中奖情况</title>
    <url>/zh-CN/2019/07/07/e5-88-a9-e7-94-a8-e6-8a-98-e7-ba-bf-e5-9b-be-e5-88-86-e6-9e-90-e5-bd-a9-e7-a5-a8-e4-b8-ad-e5-a5-96-e6-83-85-e5-86-b5.html</url>
    <content><![CDATA[<h2 id="利用折线图分析彩票中奖情况"><a href="#利用折线图分析彩票中奖情况" class="headerlink" title="利用折线图分析彩票中奖情况"></a>利用折线图分析彩票中奖情况</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>经常看到彩票销售点会挂着折线图，将近期本销售点中奖金额信息清晰的表示出来。本实例将实现利用折线图分析彩票中奖情况的功能，运行本程序，选择要分析的起始日期和终止日期，单击“分析”按钮，即可将本时间段的彩票中奖情况使用折线图描绘出来。实例运行结果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-07-09263521.png" alt=""> 图1 利用折线图分析彩票中奖情况</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例首先通过SQL语句从数据库中检索出相关数据，在绘制折线图时，将对应的数据进行计算，并以适当的比例将计算结果绘制，实现过程中主要使用Graphics类的DrawLines方法来绘制折线。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为AnalyseLottery。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个DateTimePicker控件，分别用来选择起始日期和终止日期；添加一个Button控件，用来查询指定时间段的彩票中奖情况，并绘制折线图；添加两个Panel控件，分别用来显示绘制的折线图和彩票中奖详细列表。 （3）程序主要代码如下：</p>
<p>private void DrowInfo(string SQL)<br>{<br>    try<br>    {<br>        System.Drawing.Bitmap bmp = new Bitmap(this.panel1.Width, this.panel1.Height);    //定义画布<br>        Graphics g = Graphics.FromImage(bmp);                            //创建Graphics对象<br>        g.Clear(Color.White);                                        //设置画布背景颜色<br>        Brush bru = new SolidBrush(Color.Blue);                            //创建Brush对象<br>        Pen p = new Pen(bru);                                        //定义画笔<br>        Font font = new Font(“Arial”, 9, FontStyle.Bold);                        //定义字体<br>        Conn();                                                //连接数据库<br>        cmd = new SqlCommand(SQL, con);                                //创建SqlCommand对象<br>        SqlDataReader dr = cmd.ExecuteReader();                            //创建SqlDataReader对象<br>        int i = 0;<br>        Pen pLine = new Pen(Color.Orange, 4.0f);                            //定义画笔<br>        string str = null;<br>        float f = 0.0f;<br>        while (dr.Read())                                            //开始读取数据库中的数据<br>        {<br>            i++;<br>            g.DrawString(dr[0].ToString().Substring(0, 7) + “月—“, font, bru, 10, 15.0f * i);    //绘制月份<br>            g.DrawString(dr[1].ToString(), font, bru, this.panel1.Width - 50, 15.0f * i);        //绘制每个月份的中奖情况<br>            str += dr[1].ToString() + “#”;<br>            f += Convert.ToSingle(dr[1].ToString());<br>        }<br>        dr.Close();                                                //关闭SqlDataReader对象<br>        this.panel1.BackgroundImage = bmp;                                //显示绘制的图像<br>        Bitmap bmpP = new Bitmap(this.panel3.Width, this.panel3.Height);            //定义画布<br>        Graphics gP = Graphics.FromImage(bmpP);                            //创建Graphics对象<br>        gP.Clear(Color.White);                                        //设置背景颜色<br>        Brush bruImg = new SolidBrush(Color.Orange);                        //定义笔刷<br>        Pen Pg = new Pen(bruImg, 1.0f);                                //定义画笔<br>        string[] strCount = str.Split(‘#’);<br>        int[] ICount = new int[strCount.Length];<br>        for (int l = 0; l &lt; strCount.Length - 1; l++)<br>        {<br>            ICount[l] = Convert.ToInt32(strCount[l]);<br>        }<br>        Point[] P = new Point[ICount.Length - 1];                            //用于存储直线的坐标<br>        for (int j = 0; j &lt; ICount.Length - 1; j++)<br>        {<br>            P[j].X = 35 + 28 * j;                                    //设置X坐标<br>            P[j].Y = this.panel3.Height - 20 - Convert.ToInt32(ICount[j] / f * (this.panel3.Height + 20));    //设置Y坐标<br>        }<br>        f = 0.0f;<br>        str = null;<br>        gP.DrawLines(new Pen(new SolidBrush(Color.Red)), P);                            //绘制走势图<br>        gP.DrawString(“分析结果走势图”, new Font(“宋体”, 16), bru, this.panel3.Width / 2 - 80, 10);        //绘制标题<br>        this.panel3.BackgroundImage = bmpP;                                        //显示绘制的图像<br>    }<br>    catch<br>    {<br>        MessageBox.Show(“此范围内没有任何信息！！！”);<br>        return;<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟009：return语句的使用。 return语句用于退出类的方法，把控制返回方法的调用者，如果方法有返回类型，return语句必须返回这个类型的值，如果方法没有返回类型，应使用没有表达式的return语句。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>利用控件实现柱形图分析</title>
    <url>/zh-CN/2019/07/07/e5-88-a9-e7-94-a8-e6-8e-a7-e4-bb-b6-e5-ae-9e-e7-8e-b0-e6-9f-b1-e5-bd-a2-e5-9b-be-e5-88-86-e6-9e-90.html</url>
    <content><![CDATA[<h2 id="利用控件实现柱形图分析"><a href="#利用控件实现柱形图分析" class="headerlink" title="利用控件实现柱形图分析"></a>利用控件实现柱形图分析</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>读者已了解通过GDI+来绘制图表方法，那么不用GDI+能不能实现图形显示的效果呢？答案是肯定的。本实例通过控件来完成柱形图统计功能，实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-07-09351441.png" alt=""> 图1 利用控件实现柱形图分析</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>实现动态分析数据信息时需要通过SQL语句查询要分析的数据信息，并且将查询出的字段赋给相应的变量，然后通过变量来控制控件的显示。由于分析结果为动态值，所以定义一个动态控件数组来存放信息。最后通过Controls类的Add方法将控件添加到窗体上。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为ColumnByControl。 （2）更改默认窗体Form1的Name属性为Frm_Main。 （3）程序主要代码如下：</p>
<p>private void Frm_Main_Load(object sender, EventArgs e)<br>{<br>//创建一个SqlConnection对象<br>    using (SqlConnection con = new SqlConnection(“server=mrwxk\\wangxiaoke;uid=sa;pwd=;database=db_TomeOne”))<br>    {<br>        int XValse = 20;<br>        DataSet ds = new DataSet();                                //创建DataSet对象<br>        //创建SqlCommand对象<br>        SqlCommand cmd = new SqlCommand(“select * from tb_Rectangle select Sum(t_Num) from tb_Rectangle”, con);<br>        SqlDataAdapter da = new SqlDataAdapter();                        //创建SqlDataAdapter对象<br>        da.SelectCommand = cmd;<br>        da.Fill(ds);                                            //Fill方法填充DataSet<br>        Panel[] p = new Panel[ds.Tables[0].Rows.Count];                    //创建一个Panel数组<br>        int Values = Convert.ToInt32(ds.Tables[1].Rows[0][0].ToString());        //商品总数<br>        for (int i = 0; i &lt; ds.Tables[0].Rows.Count; i++)<br>        {<br>            ds.Tables[0].Rows[i][0].ToString();<br>            float f = Convert.ToInt32(ds.Tables[0].Rows[i][1].ToString());        //获取每个商品的数量<br>            Size s = new Size();                                    //创建Size对象<br>            s.Width = 30;                                    //设置柱形图宽度<br>            s.Height = Convert.ToInt32(f / Values * 200);                    //计算柱形图高度<br>            Point pint = new Point();                                //创建Point对象<br>            pint.X = XValse;                                    //x坐标<br>            pint.Y = this.Height - 50 - s.Height;                        //y坐标<br>            p[i] = new Panel();                                    //创建一个Panel对象<br>            p[i].Location = pint;                                //设置位置<br>            p[i].BackColor = Color.Red;                            //设置背景颜色<br>            p[i].Size = s;                                        //设置大小<br>            XValse += 40;                                    //设置Xvalse变量的值<br>            Label lbl = new Label();                                //创建Label对象<br>            lbl.Text = ds.Tables[0].Rows[i][0].ToString();                    //设置Label显示的文本<br>            lbl.Font = new Font(“宋体”, 9, FontStyle.Regular);                //设置Label的Font属性<br>            lbl.ForeColor = Color.White;                            //设置Label的ForeColor属性<br>            p[i].Controls.Add(lbl);                                //添加控件<br>            this.Controls.Add(p[i]);                                //将控件数组添加到当前容器中<br>        }<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟006：有效回收对象资源！ 程序设计过程中，可以手动回收文件资源，但是使用using关键字则更为简洁友好。当using关键字下面的代码执行完毕后，将会自动将using小括号中创建的对象隐式转换为IDisposable接口类型，并调用接口方法Dispose释放对象资源。</p>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Excel对数据进行多列排序</title>
    <url>/zh-CN/2019/08/08/e5-88-a9-e7-94-a8excel-e5-af-b9-e6-95-b0-e6-8d-ae-e8-bf-9b-e8-a1-8c-e5-a4-9a-e5-88-97-e6-8e-92-e5-ba-8f.html</url>
    <content><![CDATA[<h2 id="利用Excel对数据进行多列排序"><a href="#利用Excel对数据进行多列排序" class="headerlink" title="利用Excel对数据进行多列排序"></a>利用Excel对数据进行多列排序</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用C#代码实现了在Excel中对数据进行多列排序的功能。运行本实例，首先单击上面工具栏中的“打开Excel文件”按钮，打开指定的Excel文件，并且选择要操作的工作表；然后在下面的工具栏中输入要排序的范围，单击“升序排序”按钮，对输入的多列范围进行升序排序，如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-08-13512611.png" alt=""> 图1 多列升序排序 单击“降序排序”按钮，对输入的多列范围进行降序排序，如图2所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-08-13512932.png" alt=""> 图2 多列降序排序</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现在Excel中对数据进行多列排序时，主要用到了Microsoft Excel自动化对象模型的Range对象的Sort方法，下面对其进行详细讲解。 Sort方法用来对Excel文件中的列进行排序，该方法语法格式如下：</p>
<p>object Sort([In, Optional] object Key1,[In, Optional] XlSortOrder Order1,[In, Optional] object Key2,[In, Optional] object Type,[In, Optional] XlSortOrder Order2,[In, Optional] object Key3,[In, Optional] XlSortOrder Order3,[In, Optional] XlYesNoGuess Header,[In, Optional] object OrderCustom,[In, Optional] object MatchCase,[In, Optional] XlSortOrientation Orientation,[In, Optional] XlSortMethod SortMethod,[In, Optional] XlSortDataOption DataOption1, [In, Optional] XlSortDataOption DataOption2, [In, Optional] XlSortDataOption DataOption3);</p>
<p>Sort方法语法中的参数说明如表1所示。 表1 Sort方法语法中的参数说明</p>
<p>参数</p>
<p>描述</p>
<p>Key1</p>
<p>指定要排序的第一列</p>
<p>Order1</p>
<p>指定第一列的排序方式</p>
<p>Key2</p>
<p>指定要排序的第二列</p>
<p>Type</p>
<p>指定对数据透视表进行排序时对哪些元素进行排序</p>
<p>Order2</p>
<p>指定第二列的排序方式</p>
<p>Key3</p>
<p>指定要排序的第3列</p>
<p>Order3</p>
<p>指定第3列的排序方式</p>
<p>Header</p>
<p>指定第一行是否包含页眉信息</p>
<p>OrderCustom</p>
<p>指定一个在自定义排序顺序列表中的从1开始的偏移量</p>
<p>MatchCase</p>
<p>指定排序时是否区分大小写</p>
<p>Orientation</p>
<p>指定排序方向</p>
<p>SortMethod</p>
<p>指定用于中文语言的排序方法</p>
<p>DataOption1</p>
<p>指定如何对Key1中指定的范围内的文本进行排序</p>
<p>DataOption2</p>
<p>指定如何对Key2中指定的范围内的文本进行排序</p>
<p>DataOption3</p>
<p>指定如何对Key3中指定的范围内的文本进行排序</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为SortMultiColumns。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个ToolStrip控件，分别用来作为程序的两个工具栏，其中第一个工具栏用来选择Excel文件及其工作表，第二个工具栏用来输入排序范围及执行升序排序、降序排序操作；添加一个WebBrowser控件，用来显示Excel文件。 （3）程序主要代码如下： 单击“升序排序”按钮，使用Excel.Range对象的Sort方法对指定的列进行升序排序，代码如下：</p>
<p>private void tsbtn_ASCSort_Click(object sender, EventArgs e)<br>{<br>    CloseProcess(“EXCEL”);                                    //关闭所有Excel进程<br>    string P_str_Excel = tstxt_Excel.Text;                            //记录Excel文件路径<br>    string P_str_SheetName = tscbox_Sheet.Text;                        //记录选择的工作表名称<br>    object P_obj_Start = tstxt_Start.Text;                            //记录开始单元格<br>    object P_obj_End = tstxt_End.Text;                                //记录结束单元格<br>object missing = System.Reflection.Missing.Value;                    //定义object缺省值<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.Application();<br>    //打开Excel文件<br>    Microsoft.Office.Interop.Excel.Workbook workbook = excel.Workbooks.Open(P_str_Excel, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>Microsoft.Office.Interop.Excel.Worksheet worksheet;                        //声明工作表<br>//获取选择的工作表<br>worksheet = ((Microsoft.Office.Interop.Excel.Worksheet)workbook.Worksheets[P_str_SheetName]);<br>//定义查找范围<br>    Microsoft.Office.Interop.Excel.Range searchRange = worksheet.get_Range(P_obj_Start, P_obj_End);<br>    switch (searchRange.Columns.Count)<br>    {<br>        case 1:<br>            //按1列升序排序<br>            searchRange.Sort(<br>     searchRange.Columns[1, missing], Microsoft.Office.Interop.Excel.XlSortOrder.xlAscending,<br>     missing, missing, Microsoft.Office.Interop.Excel.XlSortOrder.xlAscending,<br>     missing, Microsoft.Office.Interop.Excel.XlSortOrder.xlAscending,<br>     Microsoft.Office.Interop.Excel.XlYesNoGuess.xlNo, missing, missing,<br>     Microsoft.Office.Interop.Excel.XlSortOrientation.xlSortColumns,<br>     Microsoft.Office.Interop.Excel.XlSortMethod.xlPinYin,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal);<br>            break;<br>        case 2:<br>            //按2列升序排序<br>            searchRange.Sort(<br>     searchRange.Columns[1, missing], Microsoft.Office.Interop.Excel.XlSortOrder.xlAscending,<br>     searchRange.Columns[2, missing], missing, Microsoft.Office.Interop.Excel.XlSortOrder.xlAscending,<br>     missing, Microsoft.Office.Interop.Excel.XlSortOrder.xlAscending,<br>     Microsoft.Office.Interop.Excel.XlYesNoGuess.xlNo, missing, missing,<br>     Microsoft.Office.Interop.Excel.XlSortOrientation.xlSortColumns,<br>     Microsoft.Office.Interop.Excel.XlSortMethod.xlPinYin,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal);<br>            break;<br>        case 3:<br>        default:<br>            //按3列升序排序<br>            searchRange.Sort(<br>     searchRange.Columns[1, missing], Microsoft.Office.Interop.Excel.XlSortOrder.xlAscending,<br>     searchRange.Columns[2, missing], missing, Microsoft.Office.Interop.Excel.XlSortOrder.xlAscending,<br>     searchRange.Columns[3, missing], Microsoft.Office.Interop.Excel.XlSortOrder.xlAscending,<br>     Microsoft.Office.Interop.Excel.XlYesNoGuess.xlNo, missing, missing,<br>     Microsoft.Office.Interop.Excel.XlSortOrientation.xlSortColumns,<br>     Microsoft.Office.Interop.Excel.XlSortMethod.xlPinYin,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal);<br>            break;<br>    }<br>    excel.DisplayAlerts = false;                                    //设置保存Excel时不显示对话框<br>    workbook.Save();                                        //保存工作表<br>    CloseProcess(“EXCEL”);                                    //关闭所有Excel进程<br>    WBrowser_Excel.Navigate(P_str_Excel);                            //在窗体中重新显示Excel文件内容<br>}</p>
<p>单击“降序排序”按钮，使用Excel.Range对象的Sort方法对指定的列进行降序排序，代码如下：</p>
<p>private void tsbtn_DESCSort_Click(object sender, EventArgs e)<br>{<br>    CloseProcess(“EXCEL”);                                    //关闭所有Excel进程<br>    string P_str_Excel = tstxt_Excel.Text;                            //记录Excel文件路径<br>    string P_str_SheetName = tscbox_Sheet.Text;                        //记录选择的工作表名称<br>    object P_obj_Start = tstxt_Start.Text;                            //记录开始单元格<br>    object P_obj_End = tstxt_End.Text;                                //记录结束单元格<br>object missing = System.Reflection.Missing.Value;                    //定义object缺省值<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.Application();<br>    //打开Excel文件<br>    Microsoft.Office.Interop.Excel.Workbook workbook = excel.Workbooks.Open(P_str_Excel, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>Microsoft.Office.Interop.Excel.Worksheet worksheet;                        //声明工作表<br>//获取选择的工作表<br>worksheet = ((Microsoft.Office.Interop.Excel.Worksheet)workbook.Worksheets[P_str_SheetName]);<br>//定义查找范围<br>    Microsoft.Office.Interop.Excel.Range searchRange = worksheet.get_Range(P_obj_Start, P_obj_End);<br>    switch (searchRange.Columns.Count)<br>    {<br>        case 1:<br>            //按1列降序排序<br>            searchRange.Sort(<br>     searchRange.Columns[1, missing], Microsoft.Office.Interop.Excel.XlSortOrder.xlDescending,<br>     missing, missing, Microsoft.Office.Interop.Excel.XlSortOrder.xlDescending,<br>     missing, Microsoft.Office.Interop.Excel.XlSortOrder.xlDescending,<br>     Microsoft.Office.Interop.Excel.XlYesNoGuess.xlNo, missing, missing,<br>     Microsoft.Office.Interop.Excel.XlSortOrientation.xlSortColumns,<br>     Microsoft.Office.Interop.Excel.XlSortMethod.xlPinYin,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal);<br>            break;<br>        case 2:<br>            //按2列降序排序<br>            searchRange.Sort(<br>     searchRange.Columns[1, missing], Microsoft.Office.Interop.Excel.XlSortOrder.xlDescending,<br>     searchRange.Columns[2, missing], missing, Microsoft.Office.Interop.Excel.XlSortOrder.xlDescending,<br>     missing, Microsoft.Office.Interop.Excel.XlSortOrder.xlDescending,<br>     Microsoft.Office.Interop.Excel.XlYesNoGuess.xlNo, missing, missing,<br>     Microsoft.Office.Interop.Excel.XlSortOrientation.xlSortColumns,<br>     Microsoft.Office.Interop.Excel.XlSortMethod.xlPinYin,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal);<br>            break;<br>        case 3:<br>        default:<br>            //按3列降序排序<br>            searchRange.Sort(<br>     searchRange.Columns[1, missing], Microsoft.Office.Interop.Excel.XlSortOrder.xlDescending,<br>     searchRange.Columns[2, missing], missing, Microsoft.Office.Interop.Excel.XlSortOrder.xlDescending,<br>     searchRange.Columns[3, missing], Microsoft.Office.Interop.Excel.XlSortOrder.xlDescending,<br>     Microsoft.Office.Interop.Excel.XlYesNoGuess.xlNo, missing, missing,<br>     Microsoft.Office.Interop.Excel.XlSortOrientation.xlSortColumns,<br>     Microsoft.Office.Interop.Excel.XlSortMethod.xlPinYin,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal,<br>     Microsoft.Office.Interop.Excel.XlSortDataOption.xlSortNormal);<br>            break;<br>    }<br>    excel.DisplayAlerts = false;                                    //设置保存Excel时不显示对话框<br>    workbook.Save();                                        //保存工作表<br>    CloseProcess(“EXCEL”);                                    //关闭所有Excel进程<br>    WBrowser_Excel.Navigate(P_str_Excel);                            //在窗体中重新显示Excel文件内容<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟048：巧用Excel对象的Sort方法对列进行排序！ Excel对象的Sort方法主要用来对Excel文件中的列进行排序，它可以分别对一列、两列或者3列数据进行排序。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Excel对数据进行多表计算</title>
    <url>/zh-CN/2019/08/08/e5-88-a9-e7-94-a8excel-e5-af-b9-e6-95-b0-e6-8d-ae-e8-bf-9b-e8-a1-8c-e5-a4-9a-e8-a1-a8-e8-ae-a1-e7-ae-97.html</url>
    <content><![CDATA[<h2 id="利用Excel对数据进行多表计算"><a href="#利用Excel对数据进行多表计算" class="headerlink" title="利用Excel对数据进行多表计算"></a>利用Excel对数据进行多表计算</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用C#代码实现了利用Excel对数据进行多表计算的功能。运行本实例，如图1所示，首先单击上面工具栏中的“打开Excel模板”按钮，打开指定的Excel模板文件，并且选择要操作的工作表；然后在下面的工具栏中输入要计算的列和行，单击“合并计算”按钮，程序自动对Debug文件夹中的3个Excel文件进行合并计算，并体现在Excel模板文件中。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-08-13461332.png" alt=""> 图1 利用Excel对数据进行多表计算</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现对多个Excel工作表中的内容进行计算时，首先需要有一个固定的模板，以便使用户知道要对哪行哪列数据进行计算，然后需要使用Microsoft Excel自动化对象模型中的Range对象（使用Worksheet对象的Cells属性获得）的Text属性获取Excel工作表中指定单元格的内容，最后将获取到的内容进行相加，并且写入汇总Excel文件的相应单元格中即可，下面对本实例中用到的关键技术进行详细讲解。 （1）Worksheet对象的Cells属性 Worksheet对象是公开事件并用作控件的容器的Excel工作表对象，其Cells属性用来获取一个Range对象，该对象表示工作表上的所有单元格（不仅仅是当前正在使用的单元格）。Cells属性语法格式如下： [BrowsableAttribute(false)] public virtual Range Cells { get; } 参数说明 属性值：一个Range对象，表示工作表上的所有单元格（不仅仅是当前正在使用的单元格）。 （2）Range对象的Text属性 Range对象的Text属性用来获取指定单元格中的内容，其语法格式如下： object Text {get;} 参数说明 属性值：指定单元格的内容。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为CalMultiSheet。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个ToolStrip控件，分别用来作为程序的两个工具栏，其中第一个工具栏用来选择Excel模板文件及其工作表，第二个工具栏用来输入要计算的列、行及执行合并计算操作；添加一个WebBrowser控件，用来显示Excel文件。 （3）程序主要代码如下：</p>
<p>private void CalcData(int P_int_Row, string P_str_Column)<br>{<br>    CloseProcess(“EXCEL”);                                //关闭所有Excel进程<br>    string P_str_workBook1 = Application.StartupPath + “\\Excel1.xls”;        //记录第一个要计算的工作簿路径<br>    string P_str_workBook2 = Application.StartupPath + “\\Excel2.xls”;        //记录第二个要计算的工作簿路径<br>    string P_str_workBook3 = Application.StartupPath + “\\Excel3.xls”;        //记录第三个要计算的工作簿路径<br>    string P_str_workBook4 = Application.StartupPath + “\\Sum.xls”;        //记录存储计算结果的工作簿路径<br>object missing = System.Reflection.Missing.Value;                //定义object缺省值<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.ApplicationClass excel1 = new Microsoft.Office.Interop.Excel.ApplicationClass();<br>    excel1.Visible = false;                                    //设置Excel文件隐藏<br>    //打开第一个计算的工作簿<br>    Microsoft.Office.Interop.Excel.Workbook workbook1 = excel1.Workbooks.Open(P_str_workBook1, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>    //记录要计算的第一个工作表<br>Microsoft.Office.Interop.Excel._Worksheet worksheet1 = (Microsoft.Office.Interop.Excel._Worksheet)workbook1.Worksheets.get_Item(tscbox_Sheet.Text);<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.ApplicationClass excel2 = new Microsoft.Office.Interop.Excel.ApplicationClass();<br>    excel2.Visible = false;                                    //设置Excel文件隐藏<br>    //打开第二个计算的工作簿<br>    Microsoft.Office.Interop.Excel.Workbook workbook2 = excel2.Workbooks.Open(P_str_workBook2, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>    //记录要计算的第二个工作表<br>Microsoft.Office.Interop.Excel._Worksheet worksheet2 = (Microsoft.Office.Interop.Excel._Worksheet)workbook2.Worksheets.get_Item(tscbox_Sheet.Text);<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.ApplicationClass excel3 = new Microsoft.Office.Interop.Excel.ApplicationClass();<br>    excel3.Visible = false;                                    //设置Excel文件隐藏<br>    //打开第三个计算的工作簿<br>    Microsoft.Office.Interop.Excel.Workbook workbook3 = excel3.Workbooks.Open(P_str_workBook3, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>    //记录要计算的第三个工作表<br>Microsoft.Office.Interop.Excel._Worksheet worksheet3 = (Microsoft.Office.Interop.Excel._Worksheet)workbook3.Worksheets.get_Item(tscbox_Sheet.Text);<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.ApplicationClass excel4 = new Microsoft.Office.Interop.Excel.ApplicationClass();<br>    excel4.Visible = false;                                    //设置Excel文件隐藏<br>    //打开存储计算结果的工作簿<br>    Microsoft.Office.Interop.Excel.Workbook workbook4 = excel4.Workbooks.Open(P_str_workBook4, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>    //记录要存储结算结果的工作表<br>    Microsoft.Office.Interop.Excel._Worksheet worksheet4 = (Microsoft.Office.Interop.Excel._Worksheet)workbook4.Worksheets.get_Item(tscbox_Sheet.Text);<br>    excel4.DisplayAlerts = false;                                //设置保存Excel时不显示对话框<br>    worksheet4.Activate();                                    //激活工作表<br>    Decimal P_dml_NumOne = 0;                            //获取第一个工作表的值<br>    Decimal P_dml_NumTwo = 0;                            //获取第二个工作表的值<br>    Decimal P_dml_NumThree = 0;                            //获取第三个工作表的值<br>    //判断指定单元格内容是否为空<br>    if (((Microsoft.Office.Interop.Excel.Range)worksheet1.Cells[P_int_Row, P_str_Column]).Text.ToString() == “” || ((Microsoft.Office.Interop.Excel.Range)worksheet1.Cells[P_int_Row, P_str_Column]).Text == null)<br>    {<br>        P_dml_NumOne = 0;                                //将第一个值设置为0<br>    }<br>    else<br>    {<br>        P_dml_NumOne = Convert.ToDecimal(((Microsoft.Office.Interop.Excel.Range)worksheet1.Cells[P_int_Row, P_str_Column]).Text);                                //记录第一个值<br>    }<br>    //判断指定单元格内容是否为空<br>    if (((Microsoft.Office.Interop.Excel.Range)worksheet2.Cells[P_int_Row, P_str_Column]).Text.ToString() == “” || ((Microsoft.Office.Interop.Excel.Range)worksheet2.Cells[P_int_Row, P_str_Column]).Text == null)<br>    {<br>        P_dml_NumTwo = 0;                                //将第二个值设置为0<br>    }<br>    else<br>    {<br>        P_dml_NumTwo = Convert.ToDecimal(((Microsoft.Office.Interop.Excel.Range)worksheet2.Cells[P_int_Row, P_str_Column]).Text);                                //记录第二个值<br>    }<br>    //判断指定单元格内容是否为空<br>    if (((Microsoft.Office.Interop.Excel.Range)worksheet3.Cells[P_int_Row, P_str_Column]).Text.ToString() == “” || ((Microsoft.Office.Interop.Excel.Range)worksheet3.Cells[P_int_Row, P_str_Column]).Text == null)<br>    {<br>        P_dml_NumThree = 0;                                //将第三个值设置为0<br>    }<br>    else<br>{<br>//记录第三个值<br>        P_dml_NumThree = Convert.ToDecimal(((Microsoft.Office.Interop.Excel.Range)worksheet3.Cells[P_int_Row, P_str_Column]).Text);<br>    }<br>    Decimal P_dml_Sum = P_dml_NumOne + P_dml_NumTwo + P_dml_NumThree;//计算总和<br>    try<br>{<br>//向工作簿的指定单元格中写入计算后的数据<br>        worksheet4.Cells[P_int_Row, P_str_Column] = P_dml_Sum.ToString();<br>        workbook4.Save();                                //保存Excel文件<br>    }<br>    catch<br>    {<br>        MessageBox.Show(“写入第” + P_int_Row.ToString() + “行，第” + P_str_Column + “列时出错！”);<br>    }<br>    finally<br>    {<br>        workbook4.Save();                                //保存Excel文件<br>        //退出打开的4个Excel文件<br>        excel1.Quit();<br>        excel2.Quit();<br>        excel3.Quit();<br>        excel4.Quit();<br>    }<br>    WBrowser_Excel.Navigate(P_str_workBook4);                    //在窗体中显示多表计算后的Excel文件<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟050：如何在程序中打开Excel文件？ 打开Excel文件时，可以使用Workbooks对象的Open方法来实现，该方法的第一个参数为要打开的Excel文件，其他的参数表示Excel的相关设置，实际使用时，直接用Missing.Value的值来表示即可。例如，本实例中打开指定Excel工作表的实现代码如下：</p>
<p>Microsoft.Office.Interop.Excel.Workbook workbook1 = excel1.Workbooks.Open(P_str_workBook1, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Excel对数据进行格式转换</title>
    <url>/zh-CN/2019/08/08/e5-88-a9-e7-94-a8excel-e5-af-b9-e6-95-b0-e6-8d-ae-e8-bf-9b-e8-a1-8c-e6-a0-bc-e5-bc-8f-e8-bd-ac-e6-8d-a2.html</url>
    <content><![CDATA[<h2 id="利用Excel对数据进行格式转换"><a href="#利用Excel对数据进行格式转换" class="headerlink" title="利用Excel对数据进行格式转换"></a>利用Excel对数据进行格式转换</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用C#代码实现了利用Excel对数据进行格式转换的功能。运行本实例，如图1所示，首先选择查询条件，并输入查询关键字，单击“查询”按钮，在Sql Server数据库中执行查询，并将查询结果显示在数据表格控件中；然后单击“Excel格式转换”按钮，将数据表格控件中的查询结果输出到Excel文件中，并对Excel文件中的数据进行格式转换，这里将日期类型转换为长日期格式，数字转换为“000,000.00”格式，字符串格式化为使用双引号括起来，如图2所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-08-08232560.png" alt=""> 图1 利用Excel对数据进行格式转换 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-08-08232830.png" alt=""> 图2 格式转换之后的Excel文件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在对数据进行格式转换时，主要是通过DataGridViewCell对象的ValueType属性判断DataGridView单元格中的数据类型来实现的，下面对其进行详细讲解。 DataGridViewCell对象表示DataGridView控件中的单个单元格，其ValueType属性用来获取或设置单元格中值的数据类型，该属性的语法格式如下： [BrowsableAttribute(false)] public virtual Type ValueType { get; set; } 参数说明 属性值：System.Type类型，表示单元格中值的数据类型。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为FormatDataInExcel。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个ComboBox控件，用来选择查询条件；添加一个TextBox控件，用来输入查询关键字；添加一个DataGridView控件，用来显示Sql Server数据库中的数据；添加两个Button控件，分别用来执行数据库查询操作，和将数据库查询结果输出到Excel文件并对不同的列进行格式转换的操作。 （3）程序主要代码如下：</p>
<p>private void btn_Excel_Click(object sender, EventArgs e)<br>{<br>    if (dgv_Info.Rows.Count == 0)                        //判断是否有数据<br>        return;                                    //返回<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.Application();<br>    excel.Application.Workbooks.Add(true);                    //在Excel中添加一个工作簿<br>    excel.Visible = true;                                //设置Excel显示<br>    //生成字段名称<br>    for (int i = 0; i &lt; dgv_Info.ColumnCount; i++)<br>    {<br>        excel.Cells[1, i + 1] = dgv_Info.Columns[i].HeaderText;        //将数据表格控件中的列表头填充到Excel中<br>    }<br>    //填充数据<br>    for (int i = 0; i &lt; dgv_Info.RowCount - 1; i++)                //遍历数据表格控件的所有行<br>    {<br>        for (int j = 0; j &lt; dgv_Info.ColumnCount; j++)            //遍历数据表格控件的所有列<br>        {<br>            if (dgv_Info[j, i].ValueType == typeof(string))            //判断遍历到的数据是否是字符串类型<br>            {<br>//格式化为字符串类型并填充Excel表格<br>                excel.Cells[i + 2, j + 1] = ““” + dgv_Info[j, i].Value.ToString().Trim() + “””;<br>            }<br>//判断遍历到的数据是否是16位或者32位数字类型<br>            else if (dgv_Info[j, i].ValueType == typeof(Int16) || dgv_Info[j, i].ValueType == typeof(Int32))<br>            {<br>//格式化为32位数字类型并填充Excel表格<br>                excel.Cells[i + 2, j + 1] = Convert.ToInt32(dgv_Info[j, i].Value).ToString(“N”);<br>            }<br>            else if (dgv_Info[j, i].ValueType == typeof(Int64))        //判断遍历到的数据是否是64位数字类型<br>            {<br>//格式化为64位数字类型并填充Excel表格<br>                excel.Cells[i + 2, j + 1] = Convert.ToInt64(dgv_Info[j, i].Value).ToString(“N”);<br>            }<br>            else if (dgv_Info[j, i].ValueType == typeof(DateTime))    //判断遍历到的数据是否是日期类型<br>            {<br>//格式化为长日期形式并填充Excel表格<br>                excel.Cells[i + 2, j + 1] = Convert.ToDateTime(dgv_Info[j, i].Value).ToLongDateString();<br>            }<br>            else<br>            {<br>                excel.Cells[i + 2, j + 1] = dgv_Info[j, i].Value.ToString();//填充Excel表格<br>            }<br>        }<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟051：方便的使用“对象初始化器”！ 从C#3.0版本开始，我们可以方便的使用“对象初始化器”对所有的对象进行初始化，对象初始化器允许我们在一条语句中为指定对象的多个字段和属性赋值。实例中使用了对象初始化器初始化对象，并将初始化后的对象添加到集合中。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Excel打印学生信息报表</title>
    <url>/zh-CN/2019/07/07/e5-88-a9-e7-94-a8excel-e6-89-93-e5-8d-b0-e5-ad-a6-e7-94-9f-e4-bf-a1-e6-81-af-e6-8a-a5-e8-a1-a8.html</url>
    <content><![CDATA[<h2 id="利用Excel打印学生信息报表"><a href="#利用Excel打印学生信息报表" class="headerlink" title="利用Excel打印学生信息报表"></a>利用Excel打印学生信息报表</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>Microsoft Excel是微软公司提供的用于办公管理的应用软件，具有强大的报表统计等功能。本实例在打印学生信息时，通过将数据导入到Excel文件中进行打印。运行本实例，如图1所示，单击“输出Excel”按钮，DataGridView控件中的数据便以Excel文件方式打开，如图2所示，然后用户便可以用Excel自带的打印功能对学生信息进行打印。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-07-09220546.png" alt=""> 图1 利用Excel打印学生信息报表 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-07-0922078.png" alt=""> 图2 输出的Excel报表</p>
<h3 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h3><p>本实例中首先通过调用Microsoft Excel自动化对象模型的Workbooks对象的Add方法创建一个新的工作簿，然后通过设置Excel对象的Cells属性，向新建的工作簿中添加数据记录。下面对Workbooks对象的Add方法和Excel对象的Cells属性进行详细介绍。 （1）Workbooks对象的Add方法 该方法主要用来创建一个新的工作簿，其使用语法格式如下： Workbook Add([In, Optional] object Template); 参数说明如下。 Template：指定是否添加工作簿，如果为True，表示添加；否则，表示不添加。 返回值：返回Workbook类型，表示一个Excel工作簿。 （2）Excel对象的Cells属性 该属性用来指定Excel工作簿中单元格的内容。例如，下面的代码用来指定Excel工作簿中第一行第一列的单元格中的内容为“Excel”： excel.Cells[0, 0] = “Excel”;</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>（1）新建一个Windows应用程序，将其命名为PrintStudentInfo，默认主窗体为PrintStudentInfo。 （2）在PrintStudentInfo窗体中添加一个DataGridView控件和一个Button控件，其中，DataGridView控件用来显示数据库中的记录，Button控件用来将DataGridView控件中的数据以Excel格式输出。 （3）主要程序代码。 “输出Excel”按钮的Click事件实现代码如下：</p>
<p>private void button1_Click(object sender, EventArgs e)<br>{<br>    ExportDataGridview(dataGridView1, true);             //将DataGridView控件中的数据导出到Excel<br>}<br>自定义方法ExportDataGridview用来实现将DataGridView控件中数据导出到Excel。代码如下：<br>public bool ExportDataGridview(DataGridView dgv, bool isShowExcle)<br>{<br>    if (dgv.Rows.Count == 0)                        //当DataGridView控件中没有数据时<br>        return false;                                 //返回false<br>    //建立Excel对象<br>    Excel.Application excel = new Excel.Application();    //实例化一个Excel对象<br>    excel.Application.Workbooks.Add(true);                 //添加内容<br>    excel.Visible = isShowExcle;                         //设置为显示Excel<br>    //生成字段名称<br>    for (int i = 0; i &lt; dgv.ColumnCount; i++)                //循环遍历DataGridView控件中的每一列<br>    {<br>        excel.Cells[1, i + 1] = dgv.Columns[i].HeaderText;     //向Excel中填充数据<br>    }<br>    //填充数据<br>    for (int i = 0; i &lt; dgv.RowCount - 1; i++)                //循环遍历DataGridView控件中的每一行<br>    {<br>        for (int j = 0; j &lt; dgv.ColumnCount; j++)            //循环遍历DataGridView控件中的每一列<br>        {<br>            if (dgv[j, i].ValueType == typeof(string))     //当当前数据类型为字符串时<br>            {<br>                excel.Cells[i + 2, j + 1] = “‘“ + dgv[j, i].Value.ToString();    //向Excel中填充数据<br>            }<br>            else                                            //当数据类型为其它类型时<br>            {<br>                excel.Cells[i + 2, j + 1] = dgv[j, i].Value.ToString();        //在Excel中直接显示内容<br>            }<br>        }<br>    }<br>    return true;                                                 //返回真<br>}</p>
<p>  <img data-src="https://cdn.fesugar.com/2019/07/2019-07-07-09220892.png" alt="注意"> 注意：在程序中对Excel进行操作控制时，需要引用Excel动态链接库（Microsoft Excel 9.0 Object Library）。添加方法如下：选中当前项目，单击右键，选择“添加引用”选项，在弹出的“添加引用”对话框中选择“COM”选项卡，然后找到要引用的Excel动态链接库，单击“确定”按钮即可。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Image制作小动画</title>
    <url>/zh-CN/2019/07/09/e5-88-a9-e7-94-a8image-e5-88-b6-e4-bd-9c-e5-b0-8f-e5-8a-a8-e7-94-bb.html</url>
    <content><![CDATA[<h2 id="利用Image制作小动画"><a href="#利用Image制作小动画" class="headerlink" title="利用Image制作小动画"></a>利用Image制作小动画</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例实现了用图片控件制作小动画的功能，运行程序，窗体中间会显示一个小动画。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-09-15005010.png" alt=""> 图1 利用Image制作小动画</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>动画的实现主要在一定的时间内显示连续的图片，本实例通过添加Timer计时器，并在Timer计时器内显示固定数量的图标来实现动画效果。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为TailorAnimation。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个PictureBox控件，用来显示图片；添加一个Timer计时器组件，用来控制动画显示频率。 （3）程序主要代码如下：</p>
<p>private void Frm_Main_Load(object sender, EventArgs e)<br>{<br>//截取图片所在的文件路径<br>    strPath = Application.StartupPath.Substring(0, Application.StartupPath.Substring(0, Application.StartupPath.LastIndexOf(“\&quot;)).LastIndexOf(“\&quot;));<br>    pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage;                 //设置图片的显示类型<br>    pictureBox1.Image = Image.FromFile(strPath + @”\image\1.jpg”);            //为pictureBox1设置显示的图片<br>}<br>private void timer1_Tick(object sender, EventArgs e)<br>{<br>    Random r = new Random();                                     //声明一个随机类的对象<br>    pictureBox1.Image = Image.FromFile(strPath + @”\image\“ + r.Next(1, 5) + “.jpg”);    //为pictureBox1设置显示图片<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟005：Timer计时器组件的使用。 Timer组件是一个计时器组件，它主要用来按用户定义的时间间隔来引发事件，引发的事件一般为周期性的，每隔若干秒或若干毫秒执行一次。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>制作家庭影集</title>
    <url>/zh-CN/2019/07/09/e5-88-b6-e4-bd-9c-e5-ae-b6-e5-ba-ad-e5-bd-b1-e9-9b-86.html</url>
    <content><![CDATA[<h2 id="制作家庭影集"><a href="#制作家庭影集" class="headerlink" title="制作家庭影集"></a>制作家庭影集</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>许多家庭为了防止照片的损坏，便将图片存入电脑中，为了更方便的浏览图片，本实例制作了一个多图片的浏览程序，运行本实例，单击“上一张”、“下一张”按钮，可以对图片进行快速浏览。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-09-14583875.png" alt=""> 图1 制作家庭影集</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现时，首先通过DirectoryInfo类的GetFileSystemInfos方法从指定的文件夹中获取图片信息；然后将所有的图片名称取出来放在一个字符串中，并通过Split方法分割字符串生成一个存储图片名称的数组，数组的大小就是图片的数量；最后通过一个变量进行增加或减少作为数组下标从而实现图片的显示。下面对本实例中用到的关键技术进行详细介绍。 （1）DirectoryInfo类的GetFileSystemInfos方法 该方法用来返回表示某个目录中所有文件和子目录的强类型FileSystemInfo项的数组，其语法格式如下： public Rectangle WorkingArea { get; } 参数说明 返回值：强类型FileSystemInfo项的数组。 （2）Split方法 该方法返回的字符串数组包含字符串中的子字符串（由指定Unicode字符数组的元素分隔），其语法格式如下： public string[] Split(char[] separator) 参数说明 separator：分隔此实例中子字符串的Unicode字符数组、不包含分隔符的空数组或null。 返回值：一个数组，其元素包含此实例中的子字符串，这些子字符串由separator参数中的一个或多个字符分隔。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为TailorFamilyAlbum。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个Button控件和一个PictureBox控件，分别用来执行上一张、下一张导向操作以及显示图片信息。 （3）程序主要代码如下：</p>
<p>public void GetAllFiles(DirectoryInfo dir)<br>   {<br>       FileSystemInfo[] fileinfo = dir.GetFileSystemInfos( );     //初始化一个FileSystemInfo类型的数组<br>       foreach (FileSystemInfo i in fileinfo)                 //循环遍历fileinfo中的每一个记录<br>       {<br>           if (i is DirectoryInfo)                     //当i在类DirectoryInfo中存在时<br>           {<br>               GetAllFiles((DirectoryInfo)i);             //获取i下的所有文件<br>           }<br>           else                                //当不存在该i时<br>           {<br>               string str = i.FullName;                 //记录变量i的全名<br>               int b = str.LastIndexOf(“\&quot;);                //在此示例中获取最后一个匹配项的索引<br>               string strType = str.Substring(b + 1);         //保存文件的后缀<br>               //当文件格式为“jpg”或者“bmp”时<br>               if (strType.Substring(strType.Length - 3) == “jpg” || strType.Substring(strType.Length - 3) == “bmp”)<br>               {<br>                   strInfo += strType+ “#”;                //为变量strInfo赋值<br>               }<br>            }<br>       }<br>   }</p>
<p>  Frm_Main窗体加载时，调用GetAllFiles方法，并将该方法的返回值转化为一个字符串数组，用于存放图片名。代码如下：</p>
<p>private void Frm_Main_Load(object sender, EventArgs e)<br>{<br>    DirectoryInfo dir = new DirectoryInfo(strPath);             //创建一个DirectoryInfo对象<br>    GetAllFiles(dir);                             //获取dir下的所有文件<br>    if (strInfo != “”)                                //当字符串不为空时<br>    {<br>        strName = strInfo.Split(‘#’);                     //获取文件名<br>        Num = 0;                                 //初始化Num的值<br>        showPic(Num);                             //显示图片<br>        Count = strName.Length-1;                     //记录Array中的元素数<br>    }<br>    else                                    //当字符串为空时<br>    {<br>        MessageBox.Show(“影集里没有照片”);            //弹出信息提示<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟006：妙用foreach语句！ foreach循环专门用来遍历数组和集合的元素，foreach的工作原理是逐个枚举出数组或集合中的每一个元素，每当枚举一个元素就执行一次语句块中的内容，在使用foreach遍历的过程中要注意不可以更改遍历中的集合。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>制作开机祝福程序</title>
    <url>/zh-CN/2019/07/17/e5-88-b6-e4-bd-9c-e5-bc-80-e6-9c-ba-e7-a5-9d-e7-a6-8f-e7-a8-8b-e5-ba-8f.html</url>
    <content><![CDATA[<h2 id="制作开机祝福程序"><a href="#制作开机祝福程序" class="headerlink" title="制作开机祝福程序"></a>制作开机祝福程序</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>运行Windows的应用程序有很多种方法，双击程序的快捷方式、双击程序的可执行文件、在命令行模式中输入程序文件名、双击程序的关联文件等都可以运行目标程序，然而Windows中有许多程序需要在开机后自动运行的。当然这样的程序最好不是很多，因为太多会影响Windows启动的速度。本实例将利用C#语言制作一个开机祝福程序。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-17-14384627.png" alt=""> 图1 制作开机祝福程序</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现的关键是如何在系统启动时自动运行程序，下面就对其进行详细介绍。 系统启动时自动运行程序有很多种方法，最为常用的一种方法就是利用系统注册表。在注册表中的“HKEY_LOCAL_MACHINE\SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION \RUN”键下可以添加Windows启动后自动运行的程序，这种方法需要对注册表进行操作，C#中可以使用Registry类来实现，使用该类可以方便的对注册表进行操作，该类中的SetValue方法能够向注册表中添加或修改一个字符串值，其语法格式如下： public static void SetValue (string keyName, string valueName,Object value) 参数说明 keyName：以有效注册表根（如“HKEY_CURRENT_USER”）开头的键的完整注册表路径。 valueName：名称/值对的名称。 value：要存储的值。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为BootStrapBeatitude。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个Label控件，分别用来显示当前日期和时间；添加两个Button控件，分别用来显示信息和执行退出程序操作。 （3）程序主要代码如下：</p>
<p>private void Frm_Main_Load(object sender, EventArgs e)<br>{<br>GraphicsPath gp = new GraphicsPath();                             //初始化一个表示一系列相互连接的直线和曲线的类<br>//初始化一个矩形操作区域<br>    Rectangle rect = new Rectangle(new Point(0, 0), new Size(this.Width, this.Height));<br>    gp.AddEllipse(rect);                                        //向当前指定的路径下添加一个椭圆<br>    this.Region = new Region(gp);                                //设置与此控件关联的窗口区域<br>    this.label3.Text = DateTime.Now.ToShortDateString();                    //在label3控件中显示当前的日期<br>    this.label5.Text = DateTime.Now.ToShortTimeString();                     //在label5中显示当前的时间<br>    GraphicsPath gpstirng = new GraphicsPath();                        //初始化一个表示一系列相互连接的直线和曲线的类<br>    FontFamily family = new FontFamily(“宋体”);                        //初始化一个字体样式类<br>    int fontStyle = (int)FontStyle.Italic;                                //设置字体的样式类型<br>    int emSize = 25;                                        //初始化一个emSize变量<br>    Point origin = new Point(0, 0);                                //初始化一个有序实数对的实例<br>    StringFormat format = StringFormat.GenericDefault;                    //创建一个包含文本布局信息的对象<br>    gpstirng.AddString(“开开心心每一天”, family, fontStyle, emSize, origin, format);    //向指定的路径添加字符串<br>this.button1.Region = new Region(gpstirng);                         //设置与button1控件关联的窗口区域<br>Registry.LocalMachine.CreateSubKey(@”SOFTWARE\MICROSOFT\WINDOWS\CURRENTVERSION\RUN”).SetValue(“MyAngel”, Application.StartupPath + “\\Ex05_13.exe”, RegistryValueKind.String);            //打开注册表中的现有项并设置其中的键值类型<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟017：注册表的使用。 注册表的层次结构非常类似于文件系统，它记录了用户账号、服务器硬件以及应用程序的设置信息等。同INI文件相比，注册表可以控制的数据更多，而且不仅仅限于处理字符串类型的数据。注册表也包含了一些系统配置的信息，这些信息根据操作系统的不同而不同。用户在“开始”/“运行”里输入regedit后，单击“确定”按钮即可打开注册表编辑器。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>制作电影特效效果</title>
    <url>/zh-CN/2019/07/08/e5-88-b6-e4-bd-9c-e7-94-b5-e5-bd-b1-e7-89-b9-e6-95-88-e6-95-88-e6-9e-9c.html</url>
    <content><![CDATA[<h2 id="制作电影特效效果"><a href="#制作电影特效效果" class="headerlink" title="制作电影特效效果"></a>制作电影特效效果</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>随着现代高科技越来越快的发展，电影特效在现代电影中的使用越来越多，而它们这样做的目的无非是为了更好的吸引观看者的眼球，同样的，如果开发人员能在开发的程序中实现一些电影特效效果，也一定可以为程序增色不少。本实例实现了两种常见的电影特效效果，实例运行结果如图1和图2所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-08-13503264.png" alt=""> 图1 文字特效 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-08-13503455.png" alt=""> 图2 图片特效</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现时主要用到了Label控件的Font属性和PictureBox控件的Size属性，下面分别对它们进行详细讲解。 （1）Label控件的Font属性 Label控件表示一个标签控件，其Font属性用于获取或设置控件显示的文字的字体，该属性语法格式如下： public virtual Font Font { get; set; } 参数说明 属性值：要应用于由控件显示的文本的Font。默认为DefaultFont属性的值。 （2）PictureBox控件的Size属性 PictureBox控件用于显示位图、GIF、JPEG、图元文件或图标格式的图形，其Size属性用于获取或设置控件的高度和宽度，该属性语法格式如下： public Size Size { get; set; } 参数说明 属性值：表示控件的高度和宽度（以像素为单位）。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为MovieSpecific。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个Label控件，用来显示动态缩放的文字；添加一个PictureBox控件，用来显示动态缩放的图片；添加两个Button控件，分别用来执行文字和图片缩放操作；添加一个Timer计时器组件，用来控制文字和图片的缩放。 （3）程序主要代码如下：</p>
<p>private void button1_Click(object sender, EventArgs e)<br>{<br>    timer1.Enabled = true;                                                    //启动计时器<br>    pictureBox1.Visible = false;                                                //隐藏PictureBox控件<br>    label1.Visible = true;                                                    //显示Label控件<br>}<br>private void button3_Click(object sender, EventArgs e)<br>{<br>    label1.Visible = false;                                                    //隐藏Label控件<br>    timer1.Enabled = true;                                                    //启动计时器<br>    pictureBox1.Visible = true;                                                //显示PictureBox控件<br>}<br>private void timer1_Tick(object sender, EventArgs e)<br>{<br>    label1.Font = new Font(label1.Font.FontFamily, label1.Font.Size + 1);                        //使字体逐步加一<br>    pictureBox1.Size = new Size(pictureBox1.Size.Width + 5, pictureBox1.Size.Height + 5);            //使图片逐渐增大<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟008：Timer计时器组件的使用。 Timer组件是一个计时器组件，它主要用来按用户定义的时间间隔来引发事件，引发的事件一般为周期性的，每隔若干秒或若干毫秒执行一次。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>制作AVI播放器</title>
    <url>/zh-CN/2019/07/09/e5-88-b6-e4-bd-9cavi-e6-92-ad-e6-94-be-e5-99-a8.html</url>
    <content><![CDATA[<h2 id="制作AVI播放器"><a href="#制作AVI播放器" class="headerlink" title="制作AVI播放器"></a>制作AVI播放器</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>相信大家都使用过“金山影霸”、“RealOne”等影视播放器，其强大的媒体播放功能深受大家的喜爱。是否想过自己设计一个AVI播放器呢？本实例中笔者设计了一个AVI播放器，实现了对AVI文件的基本播放与重复播放的功能。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-09-14565476.png" alt=""> 图1 制作AVI播放器</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时主要用到了Microsoft Animation Control Version 6.0组件，该组件可以一帧一帧的播放AVI文件，在使用该组件进行开发程序前，必须将Microsoft Animation Control Version 6.0组件添加到工具箱中，步骤如下： （1）选择工具箱，单击鼠标右键，在弹出的快捷菜单中选择“选择项”。 （2）弹出“选择工具箱项”对话框，选择“COM组件”选项卡。 （3）在COM组件列表中，选择名称为“Microsoft Animation Control Version 6.0”的项，单击“确定”按钮，该组件将会自动添加到“工具箱”中。 Microsoft Animation Control Version 6.0组件提供了多个属性、方法用于控制多媒体文件的播放，其常用的属性和方法如表1所示。 表1 Microsoft Animation Control Version 6.0组件的常用属性和方法</p>
<p>属性、方法</p>
<p>说明</p>
<p>AutoPlay属性</p>
<p>确定程序运行时，媒体播放器是否自动播放</p>
<p>Open方法</p>
<p>打开一个媒体文件</p>
<p>Stop方法</p>
<p>停止媒体文件的播放</p>
<p>Play方法</p>
<p>播放媒体文件</p>
<p><img data-src="https://cdn.fesugar.com/2019/07/2019-07-09-14565645.jpeg" alt="注意"> 注意：Play方法可以重载，本实例中使用了它的第一种重载形式，该方法具有3个参数，第一个参数是重复播放次数，第二个参数是起始帧的位置，第3个参数是结束帧的位置。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为AviPlay。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个AxAnimation组件，用来播放AVI文件；添加两个Button控件，分别用来执行重复播放指定帧操作和播放AVI文件操作；添加两个TextBox控件，分别用来设置要重复播放的起始帧和结束帧。 （3）程序主要代码如下：</p>
<p>private void Frm_Main_Load(object sender, EventArgs e)<br>{<br>    this.axAnimation1.Open(Application.StartupPath + “//clock.avi”);        //加载AVI文件<br>}<br>private void button1_Click(object sender, EventArgs e)<br>{<br>    try<br>    {<br>        this.axAnimation1.Stop();                             //停止播放<br>        object start = this.textBox1.Text;                         //保存起始帧中的数据<br>        object end = this.textBox2.Text;                         //保存结束帧中的数据<br>        object time = 20;                                     //初始化变量time<br>        this.axAnimation1.Play(time, start, end);                     //播放指定的帧数<br>    }<br>    catch<br>    {<br>        MessageBox.Show(“请输入正确帧数！”);<br>    }<br>}<br>private void button2_Click(object sender, EventArgs e)<br>{<br>    this.axAnimation1.Play();                                //播放多媒体文件<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟007：object类型的使用。 object类是Object类的别名，它支持.NET Framework类层次结构中的所有类，并为派生类提供低级别服务，它是.NET Framework中所有类的最终基类。一般在程序中定义变量的类型时，如果不确定变量的类型，则可以使用object类型来定义。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>制作自己的网络浏览软件</title>
    <url>/zh-CN/2019/10/03/e5-88-b6-e4-bd-9c-e8-87-aa-e5-b7-b1-e7-9a-84-e7-bd-91-e7-bb-9c-e6-b5-8f-e8-a7-88-e8-bd-af-e4-bb-b6.html</url>
    <content><![CDATA[<h2 id="制作自己的网络浏览软件"><a href="#制作自己的网络浏览软件" class="headerlink" title="制作自己的网络浏览软件"></a>制作自己的网络浏览软件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>浏览器是上网所需的必备工具，最早的浏览器是在1993年美国伊利诺洲由伊利诺思大学的国家计算机中心开发出的MOSAIC浏览器，它以HTTP通信协议为基础，其功能仅限于浏览静态网页。随着网络技术的不断发展，如今的浏览器不仅能浏览静态网页，而且还能解释动态网页。例如，大家经常使用的”Microsoft Internet Explorer”，此外还有Netscape公司开发的”Netscape Navigator”，以及Sun公司开发的”Sun Jave Browser”。本实例设计了一个浏览器软件，运行结果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0847_1.png" alt=""></p>
<p>图1 制作自己的网络浏览软件</p>
<h3 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h3><p>实现本实例功能主要用到了ＷebBrowser控件的CanGoForward属性、Url属性、Navigate方法、Print方法、GoSearch方法、GoHome方法、Refresh方法、Stop方法、GoForward方法、GoBack方法、ShowSaveAsDialog方法、ShowPropertiesDialog方法、ShowPrintPreviewDialog方法、ShowPageSetupDialog方法、Navigated事件和CanGoForwardChanged事件。下面分别进行介绍。 （1）WebBrowser 控件 WebBrowser控件为WebBrowser ActiveX控件提供了托管包装。托管包装使用户可以在Windows窗体客户端应用程序中显示网页。使用WebBrowser控件，可以实现应用程序中的Internet Explorer Web浏览功能，还可以禁用默认的Internet Explorer功能，并将该控件用作简单的HTML文档查看器。此外，可以使用该控件将基于DHTML的用户界面元素添加到窗体中，还可以隐藏这些元素在WebBrowser控件中承载的事实。通过这种方法，可以将Web控件和Windows窗体控件无缝地整合到一个应用程序中。 （2）CanGoForward属性 此属性获取一个值，该值指示导航历史记录中的下一页是否可用，如果可用，GoForward方法才能成功。其语法格式如下：</p>
<p>public bool CanGoForward { get; }</p>
<p>l 属性值：如果控件可以向前导航，则为True；否则为False。</p>
<p>（3）Url属性 此属性获取或设置当前文档的URL。其语法格式如下：</p>
<p>public Uri Url { get; set; }</p>
<p>l 属性值：URL，表示当前文档的名称。</p>
<p>（4）Navigate方法 此方法将指定的URL所指示的位置上的文档加载到WebBrowser控件中，替换上一个文档。其语法格式如下：</p>
<p>public void Navigate (Uri url)</p>
<p>参数说明如下。</p>
<p>l url：一个Url，表示要加载的文档的URL。</p>
<p>（5）Print方法 此方法使用当前打印和页面设置打印当前显示在WebBrowser控件中的文档。其语法格式如下：</p>
<p>public void Print ()</p>
<p>（6）GoSearch方法 此方法将WebBrowser控件导航到当前用户的默认搜索页。其语法格式如下：</p>
<p>public void GoSearch ()</p>
<p>（7）GoHome方法 此方法将WebBrowser控件导航到当前用户的主页。其语法格式如下：</p>
<p>public void GoHome ()</p>
<p>（8）Refresh方法 此方法通过检查服务器获取更新版本，重新加载当前显示在WebBrowser控件中的文档。其语法格式如下：</p>
<p>public override void Refresh ()</p>
<p>（9）Stop方法 此方法取消所有挂起的导航并停止所有的动态页元素（如背景声音和动画）。其语法格式如下：</p>
<p>public void Stop ()</p>
<p>（10）GoForward方法 此方法如果导航历史记录中的下一页可用，则将WebBrowser控件导航到该页。其语法格式如下：</p>
<p>public bool GoForward ()</p>
<p>l 返回值：如果导航成功，则为True；如果导航历史记录中的下一页不可用，则为False。</p>
<p>（11）GoBack方法 此方法如果导航历史记录中的上一页可用，则将WebBrowser控件导航到该页。其语法格式如下：</p>
<p>public bool GoBack ()</p>
<p>l 返回值：如果导航成功，则为True；如果导航历史记录中的上一页不可用，则为False。</p>
<p>（12）ShowSaveAsDialog方法 此方法打开Internet Explorer 的”保存网页”对话框，如果承载的文档不是HTML页，则打开其”保存”对话框。其语法格式如下：</p>
<p>public void ShowSaveAsDialog ()</p>
<p>（13）ShowPropertiesDialog方法 此方法打开当前文档的Internet Explorer”属性”对话框。其语法格式如下：</p>
<p>public void ShowPropertiesDialog ()</p>
<p>（14）ShowPrintPreviewDialog方法 此方法打开Internet Explorer的”打印预览”对话框。其语法格式如下：</p>
<p>public void ShowPrintPreviewDialog ()</p>
<p>（15）ShowPageSetupDialog方法 此方法打开Internet Explorer的”页面设置”对话框。其语法格式如下：</p>
<p>public void ShowPageSetupDialog ()</p>
<p>（16）Navigated 事件 此事件在WebBrowser控件导航到新文档并开始加载该文档时发生。其语法格式如下：</p>
<p>public event WebBrowserNavigatedEventHandler Navigated</p>
<p>（17）CanGoForwardChanged事件 此事件在CanGoForward属性值更改时发生。其语法格式如下：</p>
<p>public event EventHandler CanGoForwardChanged</p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>（1）新建一个Windows应用程序，将其命名为”制作自己的网络浏览软件”，默认窗体为Form1。 （2）在Form1窗体中主要添加一个WebBrowser控件，用于显示浏览网页；添加两个ToolStrip控件，用于制作导航按钮和IE浏览器地址的输入；添加一个MenuStrip控件，用于制作IE浏览器的菜单栏。 （3）主要程序代码。 页面设置的实现代码如下：</p>
<p>private void dToolStripMenuItem_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>webBrowser1.ShowPageSetupDialog();                            //打开页面设置窗体</code></pre><p>}</p>
<p>  打印浏览菜单的实现代码如下：</p>
<p>private void 打印浏览UToolStripMenuItem_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>webBrowser1.ShowPrintPreviewDialog();                            //打开打印预览窗体</code></pre><p>}</p>
<p>  打印网页的实现代码如下：</p>
<p>private void 打印PToolStripMenuItem_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>webBrowser1.Print();                                        //打印网页</code></pre><p>}</p>
<p>  页面属性的实现代码如下：</p>
<p>private void 属性NToolStripMenuItem_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>webBrowser1.ShowPropertiesDialog();                            //打开页面属性窗体</code></pre><p>}</p>
<p>  退出网站的实现代码如下：</p>
<p>private void 退出IToolStripMenuItem_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>Application.Exit();                                        //退出浏览器</code></pre><p>}</p>
<p>  保存当前网页的实现代码如下：</p>
<p>private void 保存DToolStripMenuItem_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>webBrowser1.ShowSaveAsDialog();                            //保存当前网页</code></pre><p>}</p>
<p>  网页导航的实现代码如下：</p>
<p>private void GoaButton_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>Navigate(toolStripTextBox1.Text);                                //文件导航</code></pre><p>}</p>
<p>  返回上一页的实现代码如下：</p>
<p>private void backButton_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>webBrowser1.GoBack();                                    //如果导航记录可用</code></pre><p>}</p>
<p>  导向下一页的实现代码如下：</p>
<p>private void forwardButton_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>webBrowser1.GoForward();                                    //导向下一页</code></pre><p>}</p>
<p>  取消当前页的实现代码如下：</p>
<p>private void stopButton_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>webBrowser1.Stop();                                        //取消当前页</code></pre><p>}</p>
<p>  刷新当前页的实现代码如下：</p>
<p>private void refreshButton_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>if (!webBrowser1.Url.Equals(&quot;about:blank&quot;))


{


    webBrowser1.Refresh();                                    //使用控件重新加载页


}</code></pre><p>}</p>
<p>  返回主页的实现代码如下：</p>
<p>private void homeButton_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>webBrowser1.GoHome();                                    //返回主页</code></pre><p>}</p>
<p>  导航当前页的实现代码如下：</p>
<p>private void searchButton_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>webBrowser1.GoSearch();                                    //控件导航当前页</code></pre><p>}</p>
<p>  自定义Navigate方法用来实现页面导航，实现代码如下：</p>
<p>private void Navigate(String address)                                 //实现页面导航</p>
<p>{</p>
<pre><code>if (String.IsNullOrEmpty(address)) return;                            //判断是否输入地址


if (address.Equals(&quot;about:blank&quot;)) return;                            //判断是否是空白页面


if (!address.StartsWith(&quot;http://&quot;)) address = &quot;http://&quot; + address;            //设置标准的地址格式


try


{


    webBrowser1.Navigate(new Uri(address));                        //转到指定的网站


}


catch (System.UriFormatException)                                //如果发生异常


{


    return;                                                //返回


}</code></pre><p>}</p>
<p>  显示当前网站的IP地址的实现代码如下：</p>
<p>private void webBrowser1_Navigated(object sender, WebBrowserNavigatedEventArgs e)</p>
<p>{</p>
<pre><code>toolStripTextBox1.Text = webBrowser1.Url.ToString();                //显示网址</code></pre><p>}</p>
<p>  判断是否可以导航下一页的实现代码如下：</p>
<p>private void webBrowser1_CanGoForwardChanged(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>forwardButton.Enabled = webBrowser1.CanGoForward;                //如果可以导航下一页则激活按钮</code></pre><p>}</p>
<p>  在地址框中判断是否输入回车的实现代码如下：</p>
<p>private void toolStripTextBox1_KeyDown(object sender, KeyEventArgs e)</p>
<p>{</p>
<pre><code>if (e.KeyCode == Keys.Enter)                                    //判断是否输入回车键


{


    Navigate(toolStripTextBox1.Text);                            //如果输入回车键则定位到指定的网站


}</code></pre><p>}</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>制作Vista风格的日历</title>
    <url>/zh-CN/2019/09/10/e5-88-b6-e4-bd-9cvista-e9-a3-8e-e6-a0-bc-e7-9a-84-e6-97-a5-e5-8e-86.html</url>
    <content><![CDATA[<h2 id="制作Vista风格的日历"><a href="#制作Vista风格的日历" class="headerlink" title="制作Vista风格的日历"></a>制作Vista风格的日历</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在人们的日常生活中，查询日期是非常普遍的，本实例将制作一个简单的Vista风格的日历，只显示当前系统日期的年、月、日，以及当前日期所对应的甲子年和农历。实例运行结果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1533_Vista1.png" alt=""></p>
<p>图1 制作Vista风格的日历</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例主要使用DateTime结构来获取当前系统的日期，以及获取日期中的年、月、日，然后用ChineseLunisolarCalendar类的GetSexagenaryYear方法获取指定日期的甲子年。下面对本实例中用到的关键技术进行详细讲解。 （1）DateTime结构 该结构表示时间上的一刻，通常以日期和当天的时间表示，本实例主要使用其相关属性获取日期中的年、月、日等信息。DateTime结构的常用属性及说明如表1所示。 表1 DateTime结构的常用属性及说明</p>
<p>属性</p>
<p>说明</p>
<p>Date</p>
<p>获取DateTime结构的日期部分</p>
<p>Day</p>
<p>获取DateTime结构所表示的日期为该月中的第几天</p>
<p>DayOfWeek</p>
<p>获取DateTime结构所表示的日期是星期几</p>
<p>DayOfYear</p>
<p>获取DateTime结构所表示的日期是该年中的第几天</p>
<p>Hour</p>
<p>获取DateTime结构所表示日期的小时部分</p>
<p>Millisecond</p>
<p>获取DateTime结构所表示日期的毫秒部分</p>
<p>Minute</p>
<p>获取DateTime结构所表示日期的分钟部分</p>
<p>Month</p>
<p>获取DateTime结构所表示日期的月份部分</p>
<p>Now</p>
<p>获取一个 DateTime 对象，该对象设置为此计算机上的当前日期和时间，表示为本地时间</p>
<p>TimeOfDay</p>
<p>获取DateTime结构的当天的时间</p>
<p>Today</p>
<p>获取当前日期</p>
<p>Year</p>
<p>获取DateTime结构所表示日期的年份部分</p>
<p>（2）ChineseLunisolarCalendar类的GetSexagenaryYear方法  该方法用于计算与指定日期对应的甲子（60年）循环中的年，其语法格式如下：</p>
<p>public virtual int GetSexagenaryYear (DateTime time)</p>
<p>参数说明 R time：要读取的DateTime对象。  返回值：甲子循环中的一个从1到60的数字，它与date参数对应。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为BeautifulCalendar。 （2）更改默认窗体Form1的Name属性为Frm_Main，设置其FormBorderStyle属性为None，BackColor属性和TransparencyKey属性为Color.red，以便使窗体处于透明状态。 （3）在当前项目中添加一个用户控件，将其命名为DateTimeControl。 （4）程序主要代码如下： 在dateTimeControl控件的”代码编辑”窗口中设置变量和常量值，代码如下：</p>
<p>int yy = 0;                                                //年</p>
<p>int mm = 0;                                                //月</p>
<p>int dd = 0;                                                 //日</p>
<p>string yymm = “”;                                            //当前年月</p>
<p>public const string CelestialStem = “甲乙丙丁戊己庚辛壬癸”;</p>
<p>public const string TerrestrialBranch = “子丑寅卯辰巳午未申酉戌亥”;</p>
<p>public const string Animals = “鼠牛虎兔龙蛇马羊猴鸡狗猪”;</p>
<p>public const string ChineseNumber = “〇一二三四五六七八九”;</p>
<p>在dateTimeControl控件的Paint事件中，将当前日期的年、月、日，以及相应的农历年份在指定的位置进行绘制。实现代码如下：</p>
<p>private void DateTimeControl_Paint(object sender, PaintEventArgs e)<br>{<br>    Image img = new Bitmap(Properties.Resources.backdrop1);                //从资源文件中读取背景图片<br>    e.Graphics.DrawImageUnscaled(img, new Point(0, 0));                    //绘制背景图片<br>    yymm = yy.ToString() + “年” + “ “ + mm.ToString() + “月”;                //记录当前的年月<br>    Font Myfont = new Font(“幼圆”, 12, FontStyle.Bold);                    //设置字体样式<br>    float Date_Y = (this.Width - StringSize(yymm, Myfont, true)) / 2F;            //设置文本的显示位置<br>                                                                                  //绘制日期<br>    e.Graphics.DrawString(yymm, Myfont, new SolidBrush(Color.White), new PointF(Date_Y, 20F));<br>    Myfont = new Font(“新宋体”, 65, FontStyle.Bold);                        //设置天的字体样式<br>    float Date_D = (this.Width - StringSize(dd.ToString(), Myfont, true)) / 2F;         //设置文本的位置<br>                                                                                        //绘制天<br>    e.Graphics.DrawString(dd.ToString(), Myfont, new SolidBrush(Color.Black), new PointF(Date_D + 3, 30F));<br>    //绘制天的阴影<br>    e.Graphics.DrawString(dd.ToString(), Myfont, new SolidBrush(Color.White), new PointF(Date_D, 30F));<br>    string MyWeek = GetDayOfWeekString(this.Date);                    //获取今天是周几<br>    Myfont = new Font(“幼圆”, 12, FontStyle.Bold);                        //设置周的字体样式<br>    Date_Y = (this.Width - StringSize(MyWeek, Myfont, true)) / 2F;                //设置文本的位置<br>                                                                                  //绘制今天是周几<br>    e.Graphics.DrawString(MyWeek, Myfont, new SolidBrush(Color.White), new PointF(Date_Y, 110F));<br>    int tem_n = calendar.GetSexagenaryYear(Date);                        //获取今天在那个甲子年中<br>                                                                         //获取农历年干支<br>    string Armour = CelestialStem.Substring((tem_n - 1) % 10, 1) + TerrestrialBranch.Substring((tem_n - 1) % 12, 1);<br>    tem_n = calendar.GetSexagenaryYear(Date);                        //获取今天在那个甲子年中<br>    string Resemble = Animals.Substring((tem_n - 1) % 12, 1);                //获取生肖<br>                                                                             //农历日期<br>    string tem_embolism = “”;                                    //记录是否为闰年<br>    string tem_Lunardata = “”;                                    //记录农历日期<br>    GetLunarCalendar(Date, out tem_embolism, out tem_Lunardata);            //获取农历的相关信息<br>                                                                            //记录农历的信息<br>    string LunarInfo = Armour + Resemble + tem_embolism + “ “ + LunarYear(Date.Year) + “年” + tem_Lunardata;<br>    Myfont = new Font(“黑体”, 7.5F);                                //设置文本的字体样式<br>    Date_Y = (this.Width - StringSize(LunarInfo, Myfont, true)) / 2F;            //设置农历的显示位置<br>                                                                                 //绘制农历<br>    e.Graphics.DrawString(LunarInfo, Myfont, new SolidBrush(Color.White), new PointF(Date_Y, 130F));<br>}</p>
<p>自定义方法LunarYear将获取的农历年份转换成大写形式。实现代码如下：</p>
<p>/// <summary><br>/// 将农历年份转换成大写<br>/// </summary><br>/// <param name="date">阳历年份</param><br>/// <returns>农历年份</returns><br>public string LunarYear(int Y)<br>{<br>    string m_LunarYearText = “”;<br>    StringBuilder sb = new StringBuilder();                            //创建StringBuilder对象<br>    int year = Y;                                            //记录年份<br>    int d;<br>    do<br>    {<br>        d = year % 10;                                        //获取年份的最后一位数字<br>        sb.Insert(0, ChineseNumber[d]);                            //将数字转换成大写<br>        year = year / 10;                                        //舍去年份的最后一个数字<br>    } while (year &gt; 0);                                        //如果年份大于0,继续循环<br>    m_LunarYearText = sb.ToString();                                //获取获当前年份的大写<br>    return m_LunarYearText;<br>}</p>
<p>自定义方法GetLunarCalendar根据指定的日期获取当前日期是否为闰年，以及该日期所对应的农历日期，并用embolism和Lunardata参数返回。代码如下：</p>
<p>/// <summary><br>/// 获取对应日期的农历及其他信息<br>/// </summary><br>/// <param name="dtDay">农历日期</param><br>/// <returns>农历信息</returns><br>public static void GetLunarCalendar(DateTime dtDay, out string embolism, out string Lunardata)<br>{<br>    string sYear = dtDay.Year.ToString();                            //获取当前日期的年份<br>    string sMonth = dtDay.Month.ToString();                            //获取当前日期的月份<br>    string sDay = dtDay.Day.ToString();                                //获取当前日期的日<br>    int year;<br>    int month;<br>    int day;<br>    try<br>    {<br>        year = int.Parse(sYear);                                    //将年转换成32位整数<br>        month = int.Parse(sMonth);                                //将月转换成32位整数<br>        day = int.Parse(sDay);                                    //将日转换成32位整数<br>    }<br>    catch<br>    {<br>        year = DateTime.Now.Year;                                //获取系统时间的年份<br>        month = DateTime.Now.Month;                            //获取系统时间的月份<br>        day = DateTime.Now.Day;                                //获取系统时间的日<br>    }<br>    int nTheDate;<br>    int nIsEnd;<br>    int k, m, n, nBit, i;<br>    string calendar = string.Empty;<br>    //计算到初始时间1921年2月8日的天数：1921-2-8(正月初一)<br>    nTheDate = (year - 1921) * 365 + (year - 1921) / 4 + day + MonthAdd[month - 1] - 38;<br>    if ((year % 4 == 0) &amp;&amp; (month &gt; 2))<br>        nTheDate += 1;<br>    //计算天干，地支，月，日<br>    nIsEnd = 0;<br>    m = 0;<br>    k = 0;<br>    n = 0;<br>    while (nIsEnd != 1)<br>    {<br>        if (LunarData[m] &lt; 4095)<br>            k = 11;<br>        else<br>            k = 12;<br>        n = k;<br>        while (n &gt;= 0)<br>        {<br>            //获取LunarData[m]的第n个二进制位的值<br>            nBit = LunarData[m];<br>            for (i = 1; i &lt; n + 1; i++)<br>                nBit = nBit / 2;<br>            nBit = nBit % 2;<br>            if (nTheDate &lt;= (29 + nBit))<br>            {<br>                nIsEnd = 1;<br>                break;<br>            }<br>            nTheDate = nTheDate - 29 - nBit;<br>            n = n - 1;<br>        }<br>        if (nIsEnd == 1)<br>            break;<br>        m = m + 1;<br>    }<br>    year = 1921 + m;<br>    month = k - n + 1;<br>    day = nTheDate;<br>    #region 格式化日期显示为三月廿四<br>    if (k == 12)<br>    {<br>        if (month == LunarData[m] / 65536 + 1)<br>            month = 1 - month;<br>        else if (month &gt; LunarData[m] / 65536 + 1)<br>            month = month - 1;<br>    }<br>    //农历月<br>    if (month &lt; 1)<br>    {<br>        embolism = “闰”;<br>        Lunardata = MonthName[-1 * month].ToString() + “月”;<br>    }<br>    else<br>    {<br>        embolism = “”;<br>        Lunardata = MonthName[month].ToString() + “月”;<br>    }<br>    //农历日<br>    Lunardata += DayName[day].ToString();<br>    #endregion<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟009：使用DateTime.Now属性获取系统时间！ 使用DateTime.Now属性可以方便的获取系统时间，而且可以使用格式化方式方便的得到系统时间的字符串表示形式，代码如下：</p>
<p>string P_str = DateTime.Now.ToString(“yyyy年M月d日h时m分s秒fff毫秒”);</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>十字光标定位</title>
    <url>/zh-CN/2019/07/15/e5-8d-81-e5-ad-97-e5-85-89-e6-a0-87-e5-ae-9a-e4-bd-8d.html</url>
    <content><![CDATA[<h2 id="十字光标定位"><a href="#十字光标定位" class="headerlink" title="十字光标定位"></a>十字光标定位</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在一些工程设计软件中，经常会看到一个用来精确定位的十字光标，这个光标在屏幕或地图上垂直相交形成一个十字形状，用此光标可以对一些物体在水平或垂直方向进行衡量，从而达到定位的目的。本实例将在指定图像上实现十字光标定位的功能。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-15-03293898.png" alt="{422B3054-F6BA-44C4-9F06-F58CD9D39494}"> 图1 十字光标定位</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>十字光标其实是两条相交的直线，这两条直线的焦点就是鼠标的位置，画两条经过鼠标焦点的水平和垂直直线即可形成十字光标。 本实例实现十字光标定位功能时，使用了Graphics对象的DrawLine方法，下面对其进行详细讲解。 DrawLine方法为重载方法，其常用的两种重载形式如下： （1）第一种用于绘制一条连接两个Point结构的线。 语法如下： public void DrawLine (Pen pen,Point pt1,Point pt2) 参数说明 pen：Pen对象，它确定线条的颜色、宽度和样式。 pt1：Point结构，它表示要连接的第一个点。 pt2：Point结构，它表示要连接的第二个点。 （2）第二种用于绘制一条连接由坐标指定的两个点的线条。 语法如下： public void DrawLine (Pen pen,int x1,int y1,int x2,int y2) DrawLine方法语法中的参数及说明如表1所示。 表1 DrawLine方法语法中的参数及说明</p>
<p>参数</p>
<p>说明</p>
<p>pen</p>
<p>Pen对象，它确定线条的颜色、宽度和样式</p>
<p>x1</p>
<p>第一个点的x坐标</p>
<p>y1</p>
<p>第一个点的y坐标</p>
<p>x2</p>
<p>第二个点的x坐标</p>
<p>y2</p>
<p>第二个点的y坐标</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为CrossCursor。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个Button控件和一个PictureBox控件，其中，Button控件用来执行打开图片操作，PictureBox控件用来显示选择的图片。 （3）程序主要代码如下：</p>
<p>private void pictureBox1_MouseDown(object sender, MouseEventArgs e)<br>{<br>    Graphics myGraphics = pictureBox1.CreateGraphics();<br>    //通过调用Graphics对象的DrawLine方法实现鼠标十字定位功能<br>    myGraphics.DrawLine(new Pen(Color.Black, 1), new Point(e.X, 0), new Point(e.X, e.Y));<br>    myGraphics.DrawLine(new Pen(Color.Black, 1), new Point(e.X, e.Y), new Point(e.X, pictureBox1.Height - e.Y));<br>    myGraphics.DrawLine(new Pen(Color.Black, 1), new Point(0, e.Y), new Point(e.X, e.Y));<br>    myGraphics.DrawLine(new Pen(Color.Black, 1), new Point(e.X, e.Y), new Point(pictureBox1.Width - e.X, e.Y));<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟002：使用DrawLine方法绘制坐标轴。 一般在绘制坐标轴时，都需要用到DrawLine方法。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>向文件中写入追加数据</title>
    <url>/zh-CN/2019/08/02/e5-90-91-e6-96-87-e4-bb-b6-e4-b8-ad-e5-86-99-e5-85-a5-e8-bf-bd-e5-8a-a0-e6-95-b0-e6-8d-ae.html</url>
    <content><![CDATA[<h2 id="向文件中写入追加数据"><a href="#向文件中写入追加数据" class="headerlink" title="向文件中写入追加数据"></a>向文件中写入追加数据</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用StreamWriter类的Write方法实现向文件中写入数据，首先选择要写入数据的文件，然后在窗体下方的TextBox控件中输入要写入的内容，最后单击“写入”按钮写入数据。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-02-12061083.png" alt=""> 图1 向文件中写入追加数据</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例主要用到了StreamWriter类的构造方法和Write方法，下面对本实例中用到的关键技术进行详细讲解。 （1）StreamReader类的构造方法 该方法实现使用默认编码和缓冲区大小，为指定路径上的指定文件初始化StreamWriter 类的新实例。其语法格式如下： public StreamWriter(string path) 参数说明 path：要向其中写入的完整文件路径。 （2）StreamWriter类的Write方法 该方法实现将字符串写入流，该方法的重载形式有多种。本实例的方法如下： public override void Write(string value) 参数说明 value：要写入流的字符串。如果 value 为空，则不写入任何内容。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为AddDataToFile。 （2）在默认窗体Form1中添加两个文本框，分别用来显示文件路径和输入要写入文件的内容；添加Button控件，分别用来打开指定文件和向该文件中写入内容。 （3）程序主要代码如下：</p>
<p>private void button2_Click(object sender, EventArgs e)<br>{<br>    if (String.IsNullOrEmpty(textBox1.Text.Trim()))                        //若未选择文件<br>    {<br>        MessageBox.Show(“请设置文件”);<br>        return;<br>    }<br>    if (String.IsNullOrEmpty(textBox2.Text.Trim()))                        //若未输入要写入文件的内容<br>    {<br>        MessageBox.Show(“请输入要写入的文件内容”);<br>        return;<br>    }<br>    try<br>    {<br>        StreamWriter SWriter = new StreamWriter(textBox1.Text);                //创建StreamWriter对象<br>        SWriter.Write(textBox2.Text);                                //向文件中写入指定的内容<br>        SWriter.Close();                                        //关闭StreamWriter对象和基础流<br>        MessageBox.Show(“写入文件成功！”);<br>    }<br>    catch (Exception ex)<br>    {<br>        MessageBox.Show(ex.Message);<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟008：使用StreamWriter类写文本文件。 StreamWriter类实现了TextWriter抽象类，常用来向文本文件中写入数据。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>向窗体中拖放图片并显示</title>
    <url>/zh-CN/2019/10/03/e5-90-91-e7-aa-97-e4-bd-93-e4-b8-ad-e6-8b-96-e6-94-be-e5-9b-be-e7-89-87-e5-b9-b6-e6-98-be-e7-a4-ba.html</url>
    <content><![CDATA[<h2 id="向窗体中拖放图片并显示"><a href="#向窗体中拖放图片并显示" class="headerlink" title="向窗体中拖放图片并显示"></a>向窗体中拖放图片并显示</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>当用户查看图片时，为了节省图片打开或关闭的操作，可以直接将图片拖放到窗体中进行显示，本实例使用C#语言实现了这样的功能。运行本实例，将图片拖放到窗体中，即可方便的查看图片。实例运行结果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0823_1-1.png" alt=""></p>
<p>图1 向窗体中拖放图片并显示</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时主要用到了DragEventArgs类和GetData方法，下面分别对它们进行详细讲解。</p>
<p>（1）DragEventArgs类</p>
<p>DragEventArgs类为 DragDrop、DragEnter 或 DragOver 事件提供数据，其常用的属性及说明如表1所示。</p>
<p>表1 DragEventArgs类的常用属性及说明</p>
<p>属性</p>
<p>说明</p>
<p>AllowedEffect</p>
<p>获取拖动事件的发起方（或源）所允许的拖放操作</p>
<p>Data</p>
<p>获取IDataObject，它包含与此事件关联的数据</p>
<p>Effect</p>
<p>获取或设置拖放操作中目标放置效果</p>
<p>KeyState</p>
<p>获取Shift、Ctrl 和Alt键的当前状态以及鼠标按钮的状态</p>
<p>X</p>
<p>获取鼠标指针在屏幕坐标系中的x坐标</p>
<p>Y</p>
<p>获取鼠标指针在屏幕坐标系中的y坐标</p>
<p>（2）GetData方法</p>
<p>该方法检索与指定数据格式相关联的数据，并使用一个布尔值确定是否将数据转换成该格式，其语法格式如下：</p>
<p>Object GetData (string format, bool autoConvert)</p>
<p>参数说明</p>
<p>R format：要检索的数据的格式，用DataFormats类成员进行设置。DataFormats类的成员及说明如表2所示。</p>
<p>表2 DataFormats类成员及说明</p>
<p>类成员</p>
<p>说明</p>
<p>Bitmap</p>
<p>指定Windows位图格式</p>
<p>CommaSeparatedValue</p>
<p>指定以逗号分隔值（CSV）的格式，这是电子表格常用的交换格式</p>
<p>Dib</p>
<p>指定Windows与设备无关的位图（DIB）格式</p>
<p>Dif</p>
<p>指定Windows数据交换格式（DIF），Windows窗体不直接使用此格式</p>
<p>EnhancedMetafile</p>
<p>指定Windows增强型图元文件格式</p>
<p>FileDrop</p>
<p>指定Windows文件放置格式，Windows窗体不直接使用此格式</p>
<p>MetafilePict</p>
<p>指定Windows图元文件格式，Windows窗体不直接使用此格式</p>
<p>OemText</p>
<p>指定标准Windows原始设备制造商（OEM）文本格式</p>
<p> autoConvert：将数据转换成指定格式，值为true；反之，值为false。</p>
<p>} 返回值：与指定格式关联的数据，或为空引用。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为DragImageToForm。</p>
<p>（2）更改默认窗体Form1的Name属性为Frm_Main。</p>
<p>（3）程序主要代码如下：</p>
<p>/// <summary></p>
<p>/// 在窗体背景中显示被拖放的图片</p>
<p>/// </summary></p>
<p>/// <param Frm="Form">窗体</param></p>
<p>/// <param e="DragEventArgs">DragDrop、DragEnter 或 DragOver 事件提供数据</param></p>
<p>public void SetDragImageToFrm(Form Frm, DragEventArgs e)</p>
<p>{</p>
<p>if (Var_Style == true)</p>
<p>{</p>
<p>e.Effect = DragDropEffects.Copy;                        //设置拖放操作中目标放置类型为复制</p>
<p>String[] str_Drop = (String[])e.Data.GetData(DataFormats.FileDrop, true);//检索数据格式相关联的数据</p>
<p>string tempstr;</p>
<p>Bitmap bkImage;                                    //定义Bitmap变量</p>
<p>tempstr = str_Drop[0];                                //获取拖放文件的目录</p>
<p>try</p>
<p>{</p>
<p>bkImage = new Bitmap(tempstr);                        //存储拖放的图片</p>
<p>//根据图片设置窗体的大小</p>
<p>Frm.Size = new System.Drawing.Size(bkImage.Width + 6, bkImage.Height + 33);</p>
<p>Frm.BackgroundImage = bkImage;                    //在窗体背景中显示图片</p>
<p>}</p>
<p>catch { }</p>
<p>}</p>
<p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟005：如何设置窗体的背景图片？</p>
<p>设置窗体的背景图片时，需要使用窗体的BackgroundImage属性实现，该属性用来获取或设置在窗体中显示的背景图片；另外，也可以通过在”属性”窗口中设置BackgroundImage属性实现。</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>向Word文档中写入文字</title>
    <url>/zh-CN/2019/09/10/e5-90-91word-e6-96-87-e6-a1-a3-e4-b8-ad-e5-86-99-e5-85-a5-e6-96-87-e5-ad-97.html</url>
    <content><![CDATA[<h2 id="向Word文档中写入文字"><a href="#向Word文档中写入文字" class="headerlink" title="向Word文档中写入文字"></a>向Word文档中写入文字</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>Word有着强大的文本编辑功能，我们可以轻松的在Word中输入文本内容，更改文字字体，设置文字大小、颜色，方便的对文本内容排版。在前面的实例中已经详细介绍了怎样使用C#创建Word文档，本实例将会使用C#方便的向指定的Word文档中输入文本内容。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1529_Word1.png" alt=""></p>
<p>图1 向Word文档中写入文字</p>
<p>实例运行中单击”创建Word文档”按钮，会根据用户选择的路径位置创建Word文档并向文档中添加文字，而文档的名称就是当前系统日期与时间。创建的Word文档如图2所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1529_Word2.png" alt=""></p>
<p>图2 被写入文字的Word文档</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍怎样使用Word文档中Range属性向Word中添加文本信息，下面对本实例用到的关键技术进行详细讲解。 读取或设置Word文档中的文本内容的方式基本相同，首先是得到文本内容的范围，然后通过范围对象读取或设置文本信息。实例中首先使用了Paragraphs集合中的索引获取Word文档中的段落对象，然后通过Paragraph段落对象的Range属性得到文档中段落的范围，最后通过范围对象的Text属性获取或设置段落内的文本信息。</p>
<p>说明：在Word文档的操作中也可以使用Range对象的Collapse方法折叠Range对象。折叠后的Range对象将不包含文本或其它信息，只是标注文档中的一个位置。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为AddLetter。 （2）使用C#操作Word文档，需要引用相关的COM组件，引用COM组件的步骤请参照实例426中的设计过程。 （3）更改默认窗体Form1的Name属性为Frm_Main，更改Text属性为”向Word文档中写入文字”，并向窗体中添加两个TextBox控件，控件分别用输入字符串和显示Word文档保存路径；向窗体中添加3个Button按钮，这3个按钮分别用于选择文档保存路径、创建Word文档和显示Word文档。 （4）程序主要代码如下：</p>
<p>private void btn_New_Click(object sender, EventArgs e)<br>{<br>    btn_New.Enabled = false;                                            //停用新建按钮<br>    ThreadPool.QueueUserWorkItem(                                        //使用线程池<br>    (P_temp) =&gt;                                                //使用lambda表达式<br>{<br>        G_wa = new Word.Application();                                    //创建Word应用程序对象<br>    Word.Document P_wd = G_wa.Documents.Add(                        //建立新文档<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing);<br>        Word.Range P_Range = P_wd.Paragraphs[1].Range;                        //得到文档的范围对象<br>    P_Range.Text = txt_add.Text;                                    //向文档中添加字符串<br>    G_str_path = string.Format(                                    //计算文件保存路径<br>    @”{0}\{1}”, G_FolderBrowserDialog.SelectedPath,<br>    DateTime.Now.ToString(“yyyy年M月d日h时s分m秒fff毫秒”) + “.doc”);<br>        P_wd.SaveAs(                                            //保存Word文件<br>    ref G_str_path,<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>    ref G_missing, ref G_missing, ref G_missing);<br>        ((Word._Application)G_wa.Application).Quit(                            //退出应用程序<br>    ref G_missing, ref G_missing, ref G_missing);<br>        this.Invoke(                                                //开始执行窗体线程<br>    (MethodInvoker)(() =&gt;                                    //使用lambda表达式<br>{<br>        btn_Display.Enabled = true;                                //启用显示按钮<br>    MessageBox.Show(“成功创建Word文档！”, “提示！”);                //弹出消息对话框<br>}));<br>    });<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟003：Range属性的妙用！ 通过Document对象的Range方法可以返回一个Range对象，如果Range方法中的参数是默认参数，此时的Range是文档中所有内容的范围，可以通过Range.Text属性获取或设置Range对象范围内的文本内容。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>向Word文档中插入Windows控件</title>
    <url>/zh-CN/2019/09/10/e5-90-91word-e6-96-87-e6-a1-a3-e4-b8-ad-e6-8f-92-e5-85-a5windows-e6-8e-a7-e4-bb-b6.html</url>
    <content><![CDATA[<h2 id="向Word文档中插入Windows控件"><a href="#向Word文档中插入Windows控件" class="headerlink" title="向Word文档中插入Windows控件"></a>向Word文档中插入Windows控件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>Word是一个功能强大的文字处理软件，在Word文档中可以方便的对文字信息进行排版，也可以向文档中插入生动、直观的图片信息，本实例将会介绍一个有趣的功能，向Word文档中插入Windows控件，并且此控件还可以响应用户事件。比如，向Word文档中插入Button按钮，此按钮也可以响应用户的单击事件。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1525_WordWindo1.png" alt=""></p>
<p>图1 向Word文档中插入Windows控件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍怎样使用Controls集合的AddButton方法向文档中插入Windows按钮控件，下面对本实例用到的关键技术进行详细讲解。 使用Controls集合的AddButton方法可以方便的向Word文档中插入按钮控件。AddButton的语法格式如下：</p>
<p>public Button AddButton(Range range, float width, float height, string name);</p>
<p>AddButton方法中的参数说明如表1所示。 表1 AddButton方法中的参数说明</p>
<p>参数</p>
<p>描述</p>
<p>range</p>
<p>将要插入Windows控件所在的范围</p>
<p>width</p>
<p>插入Windows控件的宽度</p>
<p>height</p>
<p>插入Windows控件的高度</p>
<p>name</p>
<p>插入Windows控件的名称</p>
<p>说明：实例中介绍了向Word文档中插入Windows控件的方法，当AddButton方法执行后将会向Word文档中插入Button按钮同时还会返回此Button对象的引用，可以通过设置此Button对象的属性和事件来控制Word文档中Button按钮的状态和事件。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，选择文件菜单中的”新建”/“项目”，此时会弹出”新建项目”窗口，在”新建项目”窗口的”项目类型”中选择”Visual C#”/“Office”，在右侧模板中选择”Word 2003 文档”，并在名称中添写”InsertControl”，并选择项目保存位置，单击确定按钮新建项目。如图2所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1525_WordWindo2.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/09/091019_1525_WordWindo3.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/09/091019_1525_WordWindo4.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/09/091019_1525_WordWindo5.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/09/091019_1525_WordWindo6.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/09/091019_1525_WordWindo7.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/09/091019_1525_WordWindo8.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/09/091019_1525_WordWindo9.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/09/091019_1525_WordWindo10.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/09/091019_1525_WordWindo11.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/09/091019_1525_WordWindo12.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/09/091019_1525_WordWindo13.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/09/091019_1525_WordWindo14.png" alt=""></p>
<p>图2 在VS2008中创建Word 2003 文档</p>
<p>（2）在打开的Word文档中单击鼠标右键选择”查看代码”，在Startup事件中写入代码如下：</p>
<p>private void ThisDocument_Startup(object sender, System.EventArgs e)<br>{<br>    Word.Range P_Range1 = this.Paragraphs[1].Range;                                //得到文档范围<br>    Microsoft.Office.Tools.Word.Controls.Button P_btn =                                //向文档中添加按钮<br>    this.Controls.AddButton(P_Range1, 50, 20, “button1”);<br>    P_btn.Text = “Button按钮”;                                                //设置按钮文本<br>    P_btn.Height = 50;                                                    //设置按钮高度<br>    P_btn.Width = 100;                                                    //设置按钮宽度<br>    P_btn.Click += new EventHandler(P_btn_Click);                                    //添加单击事件<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟006：怎样向Word文档中插入多个Windows控件？ 使用Controls集合的AddButton方法可以向Word文档中添加Button按钮，同样的也可以使用其它方法向文档中添加多个Windows控件，如：使用AddTextBox方法可以向文档中添加文本框控件，使用AddDataGridView方法可以向文档中添加DataGridView控件。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>图片自动播放</title>
    <url>/zh-CN/2019/07/15/e5-9b-be-e7-89-87-e8-87-aa-e5-8a-a8-e6-92-ad-e6-94-be.html</url>
    <content><![CDATA[<h2 id="图片自动播放"><a href="#图片自动播放" class="headerlink" title="图片自动播放"></a>图片自动播放</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>当图片过多时，浏览这些图片就变得很繁琐。为使浏览图片变得更加方便、快捷，开发本实例用于自动播放图片。本实例提供选择图片目录、设置播放的时间间隔和选择播放模式等功能，实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-15-03252459.png" alt=""> 图1 图片自动播放</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现图片自动播放功能时，主要是通过使用Timer组件来控制的，下面就对该组件进行详细讲解。 Timer组件表示一个计时器，它可以按用户定义的时间间隔来引发事件，引发的事件一般为周期性的，每隔若干秒或若干毫秒执行一次，其常用的属性、方法及事件如表1所示。 表1 Timer组件的常用属性、方法及事件</p>
<p>属性、方法及事件</p>
<p>说明</p>
<p>Enabled属性</p>
<p>获取或设置计时器是否正在运行</p>
<p>Interval属性</p>
<p>获取或设置在相对于上一次发生的Tick事件引发Tick事件之前的时间（以毫秒为单位）</p>
<p>Start方法</p>
<p>启动计时器</p>
<p>Stop方法</p>
<p>停止计时器</p>
<p>Tick事件</p>
<p>当指定的计时器间隔已过去而且计时器处于启用状态时发生</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为PicPlay。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个ListBox控件，用来显示图片列表；添加一个PictureBox控件，用来显示图片；添加两个TextBox控件，分别用来显示图片目录和输入图片切换的时间间隔；添加一个FolderBrowserDialog组件，用来选择图片目录；添加一个ComboBox控件，用来选择图片播放方式；添加一个Timer组件，用来控制图片的切换。 （3）在项目中添加一个新的Windows窗体，命名为Frm_Browser.cs，用来以幻灯片形式浏览图片。 （4）程序主要代码如下： Frm_Main窗体中单击“开始播放”按钮，开始自动播放图片，程序会判断是在当前窗口播放还是全屏播放。如果选择全屏播放图片，程序会将播放的图片路径传递给另一个窗体，然后打开这个窗体，使窗体全屏，从而实现全屏播放图片的功能。“开始播放”按钮的Click事件代码如下：</p>
<p>private void button5_Click(object sender, EventArgs e)<br>{<br>    if (Pflag)<br>    {<br>        if (txtTime.Text != “”)<br>        {<br>            if (cbbShowType.SelectedIndex == 1)                    //如果选择“适应窗口大小播放”<br>            {<br>                timer1.Interval = int.Parse(txtTime.Text.Trim());            //设定切换的时间间隔<br>                timer1.Start();                                //开始图片切换<br>                button5.Enabled = false;                        //禁用菜单<br>            }<br>            else                                        //否则全屏播放<br>            {<br>                Frm_Browser frm2 = new Frm_Browser ();            //创建Frm_Browser对象<br>                frm2.fsi = al;                                //存储图片路径的集合<br>                frm2.picPath = txtPicPath.Text.Trim();                //图片路径<br>                frm2.mytimer = int.Parse(txtTime.Text.Trim());            //切换的时间间隔<br>                frm2.ShowDialog();                            //打开窗体Frm_Browser<br>            }<br>        }<br>    }<br>}</p>
<p>  Frm_Browser窗体中使用Timer组件来控制图片的自动播放，实现的思路是设置Timer控件的时间间隔后，在其Tick事件中编写代码，使图片在PictureBox控件中显示，这样在一定的时间间隔内，会显示不同的图片，代码如下：</p>
<p>private void timer1_Tick(object sender, EventArgs e)<br>{<br>    if (MM &lt; listBox1.Items.Count)                            //如果当前切换的图片小于总的图片数量<br>    {<br>        if (txtPicPath.Text.Trim().Length == 3)                    //如果指定的目录是磁盘根目录<br>        {<br>              //设置PictureBox显示图片<br>            pictureBox1.Image = Image.FromFile(txtPicPath.Text.Trim() + listBox1.Items[MM].ToString());<br>            listBox1.SetSelected(MM, true);                        //设置索引等于MM的项目被选择<br>        }<br>        else                                            //如果不是磁盘根目录<br>        {<br>              //获取路径后还要加上“\\”，然后再加上图片名称<br>            pictureBox1.Image = Image.FromFile(txtPicPath.Text.Trim() + “\&quot; + listBox1.Items[MM].ToString());<br>            listBox1.SetSelected(MM, true);                        //设置索引等于MM的项目被选择<br>        }<br>    }<br>    MM++;                                            //MM自增<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟004：启动和关闭Timer计时器的两种方法。 启动Timer计时器时，可以将其Enabled属性设置为true，或者调用其Start方法；而关闭Timer计时器时，则需要将其Enabled属性设置为false，或者调用其Stop方法。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>在关闭窗体时弹出确认对话框</title>
    <url>/zh-CN/2019/10/03/e5-9c-a8-e5-85-b3-e9-97-ad-e7-aa-97-e4-bd-93-e6-97-b6-e5-bc-b9-e5-87-ba-e7-a1-ae-e8-ae-a4-e5-af-b9-e8-af-9d-e6-a1-86.html</url>
    <content><![CDATA[<h2 id="在关闭窗体时弹出确认对话框"><a href="#在关闭窗体时弹出确认对话框" class="headerlink" title="在关闭窗体时弹出确认对话框"></a>在关闭窗体时弹出确认对话框</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>用户对程序进行操作时，难免会有错误操作的情况，例如不小心关闭程序，如果尚有许多资料没有保存，那么损失将非常严重，所以最好使程序具有灵活的交互性。人机交互过程一般都是通过对话框来实现的，对话框中有提示信息，并且提供按钮让用户选择，例如”是”或”否”。这样用户就能够对所做的动作进行确认。正如前面所说的不小心关闭程序，如果在关闭程序之前提示用户将要关闭程序，并且提供用户选择是否继续下去，这样就大大减少了误操作现象。本实例就实现了在关闭窗体时弹出确认对话框的功能，实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0822_1.png" alt=""></p>
<p>图1 在关闭窗体时弹出确认对话框</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时主要用到了窗体的FormClosing事件、FormClosingEventArgs类的Cancel属性以及MessageBox参数的返回值，下面对本实例用到的关键技术进行详细讲解。</p>
<p>（1）窗体的FormClosing事件</p>
<p>FormClosing事件在关闭窗体前发生，其语法格式如下：</p>
<p>public event FormClosingEventHandler FormClosing</p>
<p>（2）FormClosingEventArgs类的Cancel属性</p>
<p>FormClosingEventArgs类用来为FormClosing事件提供数据，其Cancel属性用来获取或设置指示是否应取消事件的值，该属性语法格式如下：</p>
<p>public bool Cancel { get; set; }</p>
<p>参数说明</p>
<p>R 属性值：如果取消事件，则为True；否则为False。</p>
<p>（3）MessageBox参数的返回值</p>
<p>获取MessageBox参数的返回值时需要用到MessageBox类的Show方法，该方法用来显示消息框，它有多种重载形式，最常用的语法格式如下：</p>
<p>public static MessageBoxResult Show(string messageBoxText,string caption,MessageBoxButton button)</p>
<p>Show方法语法中的参数及说明如表1所示。</p>
<p>表1 Show方法语法中的参数及说明</p>
<p>参数</p>
<p>描述</p>
<p>messageBoxText</p>
<p>指定要显示的文本</p>
<p>caption</p>
<p>指定要显示的标题栏标题</p>
<p>button</p>
<p>一个MessageBoxButton枚举值，用于指定要显示哪个按钮或哪些按钮</p>
<p>返回值</p>
<p>一个MessageBoxResult值，用于指定用户单击了哪个消息框按钮</p>
<p>例如，本实例中判断MessageBox参数的返回值是否为”是”的代码如下：</p>
<p>if (MessageBox.Show(“将要关闭窗体，是否继续？”, “询问”, MessageBoxButtons.YesNo) == DialogResult.Yes)</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为ShowDialogByClose。</p>
<p>（2）更改默认窗体Form1的Name属性为Frm_Main，并为该窗体设置指定的背景图片。</p>
<p>（3）程序主要代码如下：</p>
<p>private void Frm_Main_FormClosing(object sender, FormClosingEventArgs e)        //触发窗体关闭事件</p>
<p>{</p>
<p>//判断是否单击了”是”按钮</p>
<p>if (MessageBox.Show(“将要关闭窗体，是否继续？”, “询问”, MessageBoxButtons.YesNo) == DialogResult.Yes)</p>
<p>{</p>
<p>e.Cancel = false;                                        //关闭窗体</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>e.Cancel = true;                                        //取消事件的执行</p>
<p>}</p>
<p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟007：FormClosing事件的妙用！</p>
<p>开发网络程序或多线程程序时，可以在窗体的FormClosing事件中关闭网络连接或多线程，以便释放网络连接或多线程所占用的系统资源。</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>在打印预览中显示Word文档</title>
    <url>/zh-CN/2019/08/25/e5-9c-a8-e6-89-93-e5-8d-b0-e9-a2-84-e8-a7-88-e4-b8-ad-e6-98-be-e7-a4-baword-e6-96-87-e6-a1-a3.html</url>
    <content><![CDATA[<h2 id="在打印预览中显示Word文档"><a href="#在打印预览中显示Word文档" class="headerlink" title="在打印预览中显示Word文档"></a>在打印预览中显示Word文档</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在打印Word文档之前，我们经常会使用打印预览功能预览打印效果，实例中将会介绍一种方法，可以方便的打开Word文档，打开文档的同时也会打开文档的打印预览。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-01321219.png" alt=""> 图1 在打印预览中显示Word文档 实例运行中单击“打开Word文档并预览”按钮，此时会打开Word文档并启用预览功能，如图2所示。 图2 启用打印预览功能的Word文档</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍使用PrintPreview方法在打印预览窗体中显示Word文档，下面对本实例用到的关键技术进行详细讲解。 在打开Word文档后，我们可以使用Document文档对象的PrintPreview方法轻松的显示打印预览窗体。在打印预览窗体中，我们可以方便的调节显示比例，清晰直观的预览Word文档的打印信息。 说明：由于打印预览是在Word文档中运行的，所以在使用PrintPreview方法打开打印预览窗口前，首先要使用Document对象的Open方法打开Word文档。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为WordPreView。 （2）使用C#操作Word文档，需要引用相关的COM组件，引用COM组件的步骤请参照实例426中的设计过程。 （3）更改默认窗体Form1的Name属性为Frm_Main，更改Text属性为“在打印预览中显示Word文档”，向窗体中添加一个TextBox控件，用于显示打开Word文档的路径；向窗体中添加两个Button按钮，分别用于浏览Word文档和打开并预览Word文档。 （4）程序主要代码如下：</p>
<p>private void btn_Open_Click(object sender, EventArgs e)<br>{<br>    btn_Open.Enabled = false;                                            //停用打开按钮<br>    ThreadPool.QueueUserWorkItem(                                        //开始线程池<br>        (pp) =&gt;                                                    //使用lambda表达式<br>        {<br>            G_wa = new Microsoft.Office.Interop.Word.Application();                     //创建应用程序对象<br>            G_wa.Visible = true;                                        //将文档设置为可见<br>            object P_FileName = G_OpenFileDialog.FileName;                        //设置打开文档参数<br>            Word.Document P_Document = G_wa.Documents.Open(                    //打开Word文档<br>                ref P_FileName, ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                ref G_missing, ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                ref G_missing, ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                ref G_missing);<br>            P_Document.PrintPreview();                                    //打开预览窗口<br>        });<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟024：方便的使用Word文档的打印预览功能！ 在Word文档的操作过程中，我们可以使用Document文档对象的PrintPreview方法轻松的显示打印预览页面，由于打印预览是在Word文档中运行的，所以在使用PrintPreview方法打开打印预览窗口前，首先要使用Document对象的Open方法打开Word文档。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>在柱形图的指定位置显示说明文字</title>
    <url>/zh-CN/2019/07/07/e5-9c-a8-e6-9f-b1-e5-bd-a2-e5-9b-be-e7-9a-84-e6-8c-87-e5-ae-9a-e4-bd-8d-e7-bd-ae-e6-98-be-e7-a4-ba-e8-af-b4-e6-98-8e-e6-96-87-e5-ad-97.html</url>
    <content><![CDATA[<h2 id="在柱形图的指定位置显示说明文字"><a href="#在柱形图的指定位置显示说明文字" class="headerlink" title="在柱形图的指定位置显示说明文字"></a>在柱形图的指定位置显示说明文字</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在实际中使用柱形图统计分析一些数据时，通常都会在柱形图上显示说明文字，以便能够让用户更清楚的了解统计分析的数据。本实例使用C#实现了在柱形图上绘制说明文字的功能，实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-07-09322324.png" alt=""> 图1 在柱形图的指定位置显示说明文字</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在绘制柱形图及柱形图上的文字时，主要用到了Graphics类的FillRectangle方法和DrawString方法，下面分别对它们进行详细讲解。 Graphics类的DrawString方法主要用于在指定位置用指定的Brush和Font对象绘制文本字符串，其语法格式如下。 public void DrawString(string s,Font font,Brush brush,PointF point) DrawString方法语法中的参数及说明如表1所示。 表1 DrawString方法语法中的参数及说明</p>
<p>参数</p>
<p>说明</p>
<p>s</p>
<p>要绘制的字符串</p>
<p>font</p>
<p>定义字符串的文本格式</p>
<p>brush</p>
<p>确定所绘制文本的颜色和纹理</p>
<p>point</p>
<p>指定所绘制文本的左上角</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为TextInColumn。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个Panel控件，用于显示绘制的标有说明文字的柱形图。 （3）程序主要代码如下：</p>
<p>private void ShowPic()<br>{<br>    Conn();                                                    //打开数据库<br>    using (cmd = new SqlCommand(“SELECT TOP 3 * FROM tb_Rectangle order by t_Num desc”, con))<br>    {<br>        SqlDataReader dr = cmd.ExecuteReader();                            //创建SqlDataReader对象<br>        Bitmap bitM = new Bitmap(this.panel1.Width, this.panel1.Height);            //创建画布<br>        Graphics g = Graphics.FromImage(bitM);                            //创建Graphics对象<br>        Pen p = new Pen(new SolidBrush(Color.SlateGray), 1.0f);                    //创建Pen对象<br>        p.DashStyle= System.Drawing.Drawing2D.DashStyle.Dash;                //设置虚线<br>        g.Clear(Color.White);                                        //设置画布颜色<br>        for (int i = 0; i &lt; 5; i++)<br>        {<br>               //绘制水平线条<br>            g.DrawLine(p, 50, this.panel1.Height - 20 - i * 20, this.panel1.Width - 40, this.panel1.Height - 20 - i * 20);<br>            g.DrawString(Convert.ToString(i * 100), new Font(“Times New Roman”, 10, FontStyle.Regular), new SolidBrush(Color.Black), 20, this.panel1.Height - 27 - i * 20);                                        //绘制商品的增长值<br>        }<br>        for (int j = 0; j &lt; 4; j++)<br>        {<br>            g.DrawLine(p, 50 , this.panel1.Height - 20, 50, 20);                    //绘制垂直线条<br>            if (dr.Read())<br>            {<br>                int x, y, w, h;                                        //声明变量存储坐标和大小<br>                g.DrawString(dr[0].ToString(), new Font(“宋体”, 9, FontStyle.Regular), new SolidBrush(Color.Black), 76 + 40 * j, this.panel1.Height - 16);                                                        //绘制商品名称<br>                x = 78 + 40 * j;                                    //X坐标<br>//Y坐标<br>                y = this.panel1.Height - 20 - Convert.ToInt32((Convert.ToDouble(Convert.ToDouble(dr[1].ToString()) * 20 / 100)));<br>                w = 24;                                            //宽度<br>                h = Convert.ToInt32(Convert.ToDouble(dr[1].ToString()) * 20 / 100);        //高度<br>                g.FillRectangle(new SolidBrush(Color.SlateGray), x, y, w, h);            //绘制柱形图<br>//在柱形图指定的位置绘制文字<br>                g.DrawString((h*100/20).ToString(), new Font(“宋体”, 8,FontStyle.Bold), new SolidBrush(Color.Tomato), new Point(x+4,y-10));<br>            }<br>        }<br>        this.panel1.BackgroundImage = bitM;                                //显示绘制的图形<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟007：FillRectangle方法的使用。 FillRectangle方法为可重载方法，它有4种重载形式，分别用来填充由Rectangle结构、RectangleF结构以及一对坐标、一个宽度、一个高度指定的矩形的内部。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>在DataGridView中添加“合计”和“平均值”</title>
    <url>/zh-CN/2020/03/02/e5-9c-a8datagridview-e4-b8-ad-e6-b7-bb-e5-8a-a0-e5-90-88-e8-ae-a1-e5-92-8c-e5-b9-b3-e5-9d-87-e5-80-bc.html</url>
    <content><![CDATA[<h2 id="在DataGridView中添加”合计”和”平均值”"><a href="#在DataGridView中添加”合计”和”平均值”" class="headerlink" title="在DataGridView中添加”合计”和”平均值”"></a>在DataGridView中添加”合计”和”平均值”</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例实现为DataGridView控件中的第一个列的所有行求和，为第二个列的所有行求平均数。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2020/03/030220_0405_DataGridVie1.png" alt=""></p>
<p>图1 在DataGridView中添加”合计”和”平均值”</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在使实现时主要用到了List<T>的ForEach方法，该方法实现对List<T> 的每个元素执行指定操作，本实例使用该方法来计算float类型元素的和，该方法的语法格式如下：</p>
<p>public void ForEach(Action<T> action)</p>
<p>参数说明 R action：要对List<T>的每个元素执行的 System.Action<T> 委托。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为SumAndAverage。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个DataGridView控件，用来显示绑定的数据。 （3）程序主要代码如下：</p>
<p>private void Frm_Main_Load(object sender, EventArgs e)<br>{<br>    G_Fruit = new List<Fruit>() {                        //创建集合并添加元素<br>new Fruit(){Name=”苹果”,Price=30},<br>new Fruit(){Name=”橘子”,Price=40},<br>new Fruit(){Name=”鸭梨”,Price=33},<br>new Fruit(){Name=”水蜜桃”,Price=31}};<br>    dgv_Message.Columns.Add(“Fruit”, “水果”);                //添加列<br>    dgv_Message.Columns.Add(“Pric”, “价格”);                //添加列<br>    foreach (Fruit f in G_Fruit)                            //添加元素<br>    {<br>        dgv_Message.Rows.Add(new string[]<br>        {<br>f.Name,<br>f.Price.ToString()<br>        });<br>    }<br>    dgv_Message.Columns[0].Width = 200;                    //设置列宽度<br>    dgv_Message.Columns[1].Width = 170;                    //设置列宽度<br>    float sum = 0;                                    //定义float类型变量<br>    G_Fruit.ForEach(<br>    (pp) =&gt;<br>    {<br>        sum += pp.Price;                            //求和<br>    });<br>    dgv_Message.Rows.Add(new string[]                    //在新列中显示平均值及合计信息<br>    {<br>“合计： “+sum.ToString()+” 元”,<br>“平均价格： “+(sum/G_Fruit.Count).ToString()+” 元”<br>    });<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟015：填充DataGridView控件的单元格 在使用DataGridView控件显示数据时，可以使用字符串数组为DataGridView控件的新增行填充单元格。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>在Excel的指定范围内搜索文本</title>
    <url>/zh-CN/2019/08/08/e5-9c-a8excel-e7-9a-84-e6-8c-87-e5-ae-9a-e8-8c-83-e5-9b-b4-e5-86-85-e6-90-9c-e7-b4-a2-e6-96-87-e6-9c-ac.html</url>
    <content><![CDATA[<h2 id="在Excel的指定范围内搜索文本"><a href="#在Excel的指定范围内搜索文本" class="headerlink" title="在Excel的指定范围内搜索文本"></a>在Excel的指定范围内搜索文本</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用C#代码实现了在Excel的指定范围内搜索文本的功能。运行本实例，如图1所示，首先单击上面工具栏中的“打开Excel文件”按钮，打开指定的Excel文件，并且选择要操作的工作表；然后在下面的工具栏中输入查找的范围及文本，单击“搜索”按钮，即可在指定工作表的指定范围内搜索文本，并将搜索到的文本以红色字体显示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-08-14260052.png" alt=""> 图1 在Excel的指定范围内搜索文本</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现在Excel的指定范围内搜索文本时，主要用到了Microsoft Excel自动化对象模型的Range对象的Find方法，下面对其进行详细讲解。 Range对象表示Excel数据表格中一定区域的单元格，该区域中可以包括一个单元格、多个连续的单元格以及多个不连续的单元格，其Find方法用来在Range对象中查找文本，并返回包含查找文本的单元格，该方法语法格式如下：</p>
<p>Range Find([In] object What, [In, Optional] object After, [In, Optional] object LookIn, [In, Optional] object LookAt, [In, Optional] object SearchOrder, [In, Optional] XlSearchDirection SearchDirection, [In, Optional] object MatchCase, [In, Optional] object MatchByte, [In, Optional] object SearchFormat);</p>
<p>Find方法语法中的参数说明如表1所示。 表1 Find方法语法中的参数说明</p>
<p>参数</p>
<p>描述</p>
<p>What</p>
<p>要搜索的文本</p>
<p>After</p>
<p>单个单元格，搜索区域将从该单元格之后开始</p>
<p>LookIn</p>
<p>要搜索的数据类型</p>
<p>LookAt</p>
<p>指定是否匹配整个单元格的内容</p>
<p>SearchOrder</p>
<p>指定按行或者列方式搜索</p>
<p>SearchDirection</p>
<p>指定向前或向后搜索</p>
<p>MatchCase</p>
<p>指定搜索时是否区分大小写</p>
<p>MatchByte</p>
<p>指定是否对双字节进行完全匹配</p>
<p>SearchFormat</p>
<p>指定搜索文本是否格式化</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为SearchTextInRange。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个ToolStrip控件，分别用来作为程序的两个工具栏，其中第一个工具栏用来选择Excel文件及其工作表，第二个工具栏用来输入查找范围、要查找的文本及执行查找操作；添加一个WebBrowser控件，用来显示Excel文件。 （3）程序主要代码如下：</p>
<p>private void tsbtn_Query_Click(object sender, EventArgs e)<br>{<br>    CloseProcess(“EXCEL”);                                        //关闭所有Excel进程<br>    string P_str_Excel = tstxt_Excel.Text;                                //记录Excel文件路径<br>    string P_str_SheetName = tscbox_Sheet.Text;                            //记录选择的工作表名称<br>    object P_obj_Start = tstxt_Start.Text;                                //记录开始单元格<br>    object P_obj_End = tstxt_End.Text;                                    //记录结束单元格<br>object missing = System.Reflection.Missing.Value;                        //定义object缺省值<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.Application();<br>    //打开Excel文件<br>    Microsoft.Office.Interop.Excel.Workbook workbook = excel.Workbooks.Open(P_str_Excel, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>Microsoft.Office.Interop.Excel.Worksheet worksheet;                            //声明工作表<br>//获取选择的工作表<br>worksheet = ((Microsoft.Office.Interop.Excel.Worksheet)workbook.Worksheets[P_str_SheetName]);<br>//定义查找范围<br>    Microsoft.Office.Interop.Excel.Range searchRange = worksheet.get_Range(P_obj_Start, P_obj_End);<br>    Microsoft.Office.Interop.Excel.Range currentRange = null;                    //定义当前找到的范围<br>    Microsoft.Office.Interop.Excel.Range firstRange = null;                        //定义找到的第一个范围<br>    object P_obj_Text = tstxt_Text.Text;                                    //记录要搜索的文本<br>    //搜索第一个匹配项，指定从其后开始搜索的单元格以外的所有参数<br>    currentRange = searchRange.Find(P_obj_Text, missing, Microsoft.Office.Interop.Excel.XlFindLookIn.xlValues, Microsoft.Office.Interop.Excel.XlLookAt.xlPart, Microsoft.Office.Interop.Excel.XlSearchOrder.xlByRows, Microsoft.Office.Interop.Excel.XlSearchDirection.xlNext, false, missing, missing);<br>    while (currentRange != null)                                        //一直搜索，直到没有匹配项<br>    {<br>        if (firstRange == null)                                        //如果第一个范围不包含任何值<br>        {<br>            firstRange = currentRange;                                    //记录当前范围<br>        }<br>        //如果查找范围的地址与第一个查找范围的地址匹配<br>        else if (currentRange.get_Address(missing, missing, Microsoft.Office.Interop.Excel.XlReferenceStyle.xlA1, missing, missing) == firstRange.get_Address(missing, missing, Microsoft.Office.Interop.Excel.XlReferenceStyle.xlA1, missing, missing))<br>        {<br>            break;                                                //退出<br>        }<br>        //为单元格加边框<br>        currentRange.BorderAround(Microsoft.Office.Interop.Excel.XlLineStyle.xlContinuous, Microsoft.Office.Interop.Excel.XlBorderWeight.xlThin, Microsoft.Office.Interop.Excel.XlColorIndex.xlColorIndexAutomatic, Color.Black.ToArgb());<br>        currentRange.Font.Color = System.Drawing.ColorTranslator.ToOle(Color.Red);        //设置搜索到的文本颜色<br>        currentRange.Font.Bold = true;                                    //设置搜索到的文本为粗体<br>        currentRange = searchRange.FindNext(currentRange);                    //查找下一处<br>    }<br>    MessageBox.Show(“搜索完毕！”, “提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>    excel.DisplayAlerts = false;                                        //设置保存Excel时不显示对话框<br>    workbook.Save();                                            //保存工作表<br>    CloseProcess(“EXCEL”);                                        //关闭所有Excel进程<br>    WBrowser_Excel.Navigate(P_str_Excel);                                //在窗体中重新显示Excel文件内容<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟047：Font对象的妙用！ 如果理解了实例中Font对象的使用方法，那么就可以轻松的设置其Name属性更改Excel文件中字体的名称，设置Size属性更改Excel文件中字体的大小，设置Color属性更改Excel文件中字体的颜色。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>在Word文档中建立小型应用程序</title>
    <url>/zh-CN/2019/08/25/e5-9c-a8word-e6-96-87-e6-a1-a3-e4-b8-ad-e5-bb-ba-e7-ab-8b-e5-b0-8f-e5-9e-8b-e5-ba-94-e7-94-a8-e7-a8-8b-e5-ba-8f.html</url>
    <content><![CDATA[<h2 id="在Word文档中建立小型应用程序"><a href="#在Word文档中建立小型应用程序" class="headerlink" title="在Word文档中建立小型应用程序"></a>在Word文档中建立小型应用程序</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>使用C#可以向Word文档中添加文本、图片等信息，也可以向Word文档中添加窗体控件，在下面的实例中将会使用C#向Word文档中添加多个窗体控件，从而组合成为一个小型应用程序。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082519_0126_Word1.png" alt=""></p>
<p>图1 在Word文档中建立小型应用程序</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍使用Controls集合的多个方法，方便的向Word文档中插入Windows控件，在Word文档中建立一个小型的应用程序，下面对本实例用到的关键技术进行详细讲解。 （1）向Word文档中添加TextBox控件 使用Controls集合的AddTextBox方法可以方便的向Word文档中插入文本框控件。AddTextBox的语法格式如下：</p>
<p>public TextBox AddTextBox(Range range, float width, float height, string name);</p>
<p>AddTextBox方法中的参数说明如表1所示。 表1 AddTextBox方法中的参数说明</p>
<p>参数</p>
<p>描述</p>
<p>range</p>
<p>将要插入Windows控件所在的范围</p>
<p>width</p>
<p>插入Windows控件的宽度</p>
<p>height</p>
<p>插入Windows控件的高度</p>
<p>name</p>
<p>插入Windows控件的名称</p>
<p>从AddTextBox的语法格式中可以看到，AddTextBox方法执行后将会向Word文档中添加一个TextBox文本框并返回此TextBox对象的引用。  （2）向Word文档中添加Button按钮 使用Controls集合的AddButton方法可以方便的向Word文档中插入按钮控件。AddButton的语法格式如下：</p>
<p>public Button AddButton(Range range, float width, float height, string name);</p>
<p>AddButton方法中的参数说明如表2所示。 表2 AddButton方法中的参数说明</p>
<p>参数</p>
<p>描述</p>
<p>range</p>
<p>将要插入Windows控件所在的范围</p>
<p>width</p>
<p>插入Windows控件的宽度</p>
<p>height</p>
<p>插入Windows控件的高度</p>
<p>name</p>
<p>插入Windows控件的名称</p>
<p>从AddButton的语法格式中可以看到，AddButton方法执行后将会向Word文档中添加一个Button按钮并返回此Button对象的引用。  （3）向Word文档中添加DataGridView控件 使用Controls集合的AddDataGridView方法可以方便的向Word文档中插入DataGridView控件。AddDataGridView的语法格式如下：</p>
<p>public DataGridView AddDataGridView(Range range, float width, float height, string name);</p>
<p>AddDataGridView方法中的参数说明如表3所示。 表3 AddDataGridView方法中的参数说明</p>
<p>参数</p>
<p>描述</p>
<p>range</p>
<p>将要插入Windows控件所在的范围</p>
<p>width</p>
<p>插入Windows控件的宽度</p>
<p>height</p>
<p>插入Windows控件的高度</p>
<p>name</p>
<p>插入Windows控件的名称</p>
<p>说明：Controls集合中的多个添加控件的方法都会向Word文档中添加控件并返回相应控件对象的引用，通过方法返回的控件对象可以轻松的控制Word文档中的Windows控件。实例中向Word文档添加了多个Windows控件，并在Word文档中创建了一个小型应用程序。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，选择文件菜单中的”新建”/“项目”，此时会弹出”新建项目”窗口，在”新建项目”窗口的”项目类型”中选择”Visual C#”/“Office”，在右侧模板中选择”Word 2003 文档”，并在名称中添写”ApplicationInWord”，并选择项目保存位置，单击确定按钮新建项目。如图2所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082519_0126_Word2.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/08/082519_0126_Word3.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/08/082519_0126_Word4.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/08/082519_0126_Word5.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/08/082519_0126_Word6.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/08/082519_0126_Word7.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/08/082519_0126_Word8.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/08/082519_0126_Word9.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/08/082519_0126_Word10.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/08/082519_0126_Word11.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/08/082519_0126_Word12.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/08/082519_0126_Word13.png" alt="">)<img data-src="https://cdn.fesugar.com/2019/08/082519_0126_Word14.png" alt=""></p>
<p>图2 在VS2008中创建Word 2003 文档 （2）在打开的Word文档中单击鼠标右键选择”查看代码”，在Startup事件中写入代码如下：</p>
<p>private void ThisDocument_Startup(object sender, System.EventArgs e)<br>{<br>    Word.Range P_Range =                                             //得到文档区域<br>        this.ActiveWindow.Document.Range(ref G_Missing, ref G_Missing);<br>    P_Range.Text = “姓名：    “;                                        //添加文本内容<br>    object P_Range_O = Word.WdCollapseDirection.wdCollapseEnd;                    //创建折叠参数对象<br>    P_Range.Collapse(ref P_Range_O);                                        //折叠Range<br>    G_Txt_Name = this.Controls.AddTextBox(P_Range, 100, 20, “P_Txt_Name”);            //添加控件<br>    P_Range = this.Paragraphs.Add(ref G_Missing).Range;                            //添加段落<br>    P_Range = this.Paragraphs.Add(ref G_Missing).Range;                            //添加段落<br>    P_Range = this.Paragraphs[this.Paragraphs.Count - 1].Range;                        //得到最后一个段落<br>    G_Txt_Age = this.Controls.AddTextBox(P_Range, 100, 20, “P_Txt_Age”);                //添加控件<br>    P_Range = this.Paragraphs[this.Paragraphs.Count - 1].Range;                        //得到最后一个段落<br>    object P_Range_O2 = Word.WdCollapseDirection.wdCollapseStart;                    //创建折叠参数对象<br>    P_Range.Collapse(ref P_Range_O2);                                    //折叠Range<br>    P_Range.Text = “年龄：    “;                                        //添加文本<br>    AddControl();                                                    //向文档中添加控件<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟026：怎样理解折叠Range的概念？ 向Word文档中添加Windows控件或文本内容时，经常会使用Collapse方法折叠Range并向Range中继续添加信息，所谓的折叠Range是指起始位置和结束位置相同的Range对象。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>在Word文档中插入图片</title>
    <url>/zh-CN/2019/09/10/e5-9c-a8word-e6-96-87-e6-a1-a3-e4-b8-ad-e6-8f-92-e5-85-a5-e5-9b-be-e7-89-87.html</url>
    <content><![CDATA[<h2 id="在Word文档中插入图片"><a href="#在Word文档中插入图片" class="headerlink" title="在Word文档中插入图片"></a>在Word文档中插入图片</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在Word文档的使用过程中，我们可以轻松的向文档中插入图片信息，那么，怎样使用C#向Word文档中插入图片呢？本实例将会介绍一种方法，可以方便的实现上述功能。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1528_Word1.png" alt=""></p>
<p>图1 在Word文档中插入图片</p>
<p>实例运行中单击”创建Word文档”按钮，会根据用户选择的路径位置创建Word文档并向文档中添加图片，而文档的名称就是当前系统日期与时间。创建的Word文档如图2所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1528_Word2.png" alt=""></p>
<p>图2 被插入图片的Word文档</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍怎样使用InlineShapes集合的AddPicture方法向Word文档中插入图片，下面对本实例用到的关键技术进行详细讲解。 使用Documents对象的Add方法可以创建Word文档，使用Open方法可以打开Word文档，当得到文档对象后可以根据InlineShapes属性得到InlineShape对象的集合，InlineShape对象包括图片、ActiveX控件等信息。使用InlineShapes集合的AddPicture方法可以方便的向文档中插入图片，AddPicture方法的语法格式如下：</p>
<p>InlineShape AddPicture(string FileName, ref object LinkToFile, ref object SaveWithDocument, ref object Range);</p>
<p>AddPicture方法中的参数说明如表1所示。 表1 AddPicture方法中的参数说明</p>
<p>参数</p>
<p>描述</p>
<p>FileName</p>
<p>将要插入的图片文件名称及路径</p>
<p>LinkToFile</p>
<p>如果为true，则将图片链接到创建该对象的文件；如果为false则将图片作为该文件的独立副本，默认为false</p>
<p>SaveWithDocument</p>
<p>如果为true，则链接的图片与工作表一起保存，默认为false</p>
<p>Range</p>
<p>插入图片的范围</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为AddImage。 （2）使用C#操作Word文档，需要引用相关的COM组件，引用COM组件的步骤请参照实例426中的设计过程。 （3）更改默认窗体Form1的Name属性为Frm_Main，更改Text属性为”在Word文档中插入图片”，并向窗体中添加两个TextBox控件，控件分别用显示图片路径和显示Word文档保存路径；向窗体中添加4个Button按钮，这4个按钮分别用于选择向Word文档中插入的图片、选择Word文档保存路径、创建Word文档和显示Word文档。 （4）程序主要代码如下：</p>
<p>private void btn_New_Click(object sender, EventArgs e)<br>{<br>    btn_New.Enabled = false;                                            //停用新建按钮<br>    ThreadPool.QueueUserWorkItem(                                        //使用线程池<br>    (P_temp) =&gt;                                                //使用lambda表达式<br>{<br>        G_wa = new Word.Application();                                    //创建Word应用程序对象<br>    Word.Document P_wd = G_wa.Documents.Add(                        //建立新文档<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing);<br>        Word.Range P_Range = P_wd.Paragraphs[1].Range;                        //得到段落范围<br>    object P_Ranges = P_Range;                                    //创建ojbect对象<br>    P_wd.InlineShapes.AddPicture(                                    //向文档中插入图片<br>    G_OpenFileDialog.FileName, ref G_missing, ref G_missing, ref P_Ranges);<br>        G_str_path = string.Format(                                    //计算文件保存路径<br>    @”{0}\{1}”, G_FolderBrowserDialog.SelectedPath,<br>    DateTime.Now.ToString(“yyyy年M月d日h时s分m秒fff毫秒”) + “.doc”);<br>        P_wd.SaveAs(                                            //保存Word文件<br>    ref G_str_path,<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>    ref G_missing, ref G_missing, ref G_missing);<br>        ((Word._Application)G_wa.Application).Quit(                            //退出应用程序<br>    ref G_missing, ref G_missing, ref G_missing);<br>        this.Invoke(                                                //开始执行窗体线程<br>    (MethodInvoker)(() =&gt;                                    //使用lambda表达式<br>{<br>        btn_Display.Enabled = true;                                //启用显示按钮<br>    MessageBox.Show(“成功创建Word文档！”, “提示！”);                //弹出消息对话框<br>}));<br>    });<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟004：可以使用AddPicture方法向Word中插入多个图片！ 实例中已经介绍使用AddPicture方法向Word文档中插入图片，如果已经理解了插入图片的方法，那么向文档中插入多个图片实现起来也会变得很简单，AddPicture方法的最后一个参数是指定将图片插入到Word文档中的哪个范围，可以根据自己的选择将多个图片插入到文档中不同位置。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>在Word文档中绘制表格</title>
    <url>/zh-CN/2019/09/10/e5-9c-a8word-e6-96-87-e6-a1-a3-e4-b8-ad-e7-bb-98-e5-88-b6-e8-a1-a8-e6-a0-bc.html</url>
    <content><![CDATA[<h2 id="在Word文档中绘制表格"><a href="#在Word文档中绘制表格" class="headerlink" title="在Word文档中绘制表格"></a>在Word文档中绘制表格</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>使用Excel可以方便的处理表格信息，但是在Word中也可以简单的使用表格，在Word菜单中单击”表格”/“插入”/“表格”，在插入表格窗口中添加表格的行数和列数，最后单击”确定”按钮插入表格。在实例中我们可以使用C#方便的向指定的Word文档中插入表格，并在表格中添加相应信息。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1527_Word1.png" alt=""></p>
<p>图1 在Word文档中绘制表格</p>
<p>实例运行中单击”创建Word文档”按钮，会根据用户选择的路径位置创建Word文档并向文档中绘制表格，而文档的名称就是当前系统日期与时间。创建的Word文档如图2所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1527_Word2.png" alt=""></p>
<p>图2 Word文档中的表格</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍怎样使用Tabels集合的Add方法在文档中绘制表格，下面对本实例用到的关键技术进行详细讲解。 通过Document对象的Tables属性可以得到Tables集合，使用Tables集合对象的Add方法可以轻松的在Word文档中绘制表格，Add方法的语法格式如下：</p>
<p>Table Add(Range Range, int NumRows, int NumColumns, ref object DefaultTableBehavior, ref object AutoFitBehavior);</p>
<p>Add方法中的参数说明如表1所示。 表1 Add方法中的参数说明</p>
<p>参数</p>
<p>描述</p>
<p>Range</p>
<p>插入表格所在的范围</p>
<p>NumRows</p>
<p>插入表格的行数</p>
<p>NumColumns</p>
<p>插入表格的列数</p>
<p>DefaultTableBehavior</p>
<p>WdDefaultTableBehavior枚举值，指定表格的自适应方式</p>
<p>AutoFitBehavior</p>
<p>WdAutoFitBehavior枚举值，指定表格的自适应方式</p>
<p>说明：在Word文档中插入表格后可以使用表格对象的Cell方法获取或设置表格中的文本内容，Cell方法接受两个参数，两个参数分别为表格中行与列的索引，要注意一点，表格中的行与列的索引值从1开始。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为AddTable。 （2）使用C#操作Word文档，需要引用相关的COM组件，引用COM组件的步骤请参照实例426中的设计过程。 （3）更改默认窗体Form1的Name属性为Frm_Main，更改Text属性为”在Word文档中绘制表格”，并向窗体中添加3个TextBox控件，3个TextBox控件分别用显示Word文档保存路径、设置插入表格行数和设置插入表格列数；向窗体中添加3个Button按钮，这3个按钮分别用于选择Word文档保存路径、创建Word文档和显示Word文档。 （4）程序主要代码如下：</p>
<p>private void btn_New_Click(object sender, EventArgs e)<br>{<br>    G_ToolProgressBar.Minimum = 1;                                        //设置进度条最小值<br>    G_ToolProgressBar.Maximum = int.Parse(txt_row.Text) + 1;                         //设置进度条最大值<br>    btn_New.Enabled = false;                                            //停用新建按钮<br>    ThreadPool.QueueUserWorkItem(                                        //使用线程池<br>    (P_temp) =&gt;                                                //使用lambda表达式<br>{<br>        G_wa = new Word.Application();                                    //创建Word应用程序对象<br>    Word.Document P_wd = G_wa.Documents.Add(                        //建立新文档<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing);<br>        Word.Range P_Range = P_wd.Paragraphs[1].Range;                        //得到文档范围对象<br>    object P_DefaultTable =                                         //创建表格参数对象<br>    Word.WdDefaultTableBehavior.wdWord8TableBehavior;<br>        object P_AutoFit = Word.WdAutoFitBehavior.wdAutoFitWindow;                 //创建表格参数对象<br>    Word.Table P_WordTable = P_Range.Tables.Add(                        //向文档中添加表格<br>    P_Range, int.Parse(txt_row.Text), int.Parse(txt_column.Text), ref P_DefaultTable, ref P_AutoFit);<br>        for (int i = 1; i &lt; int.Parse(txt_row.Text) + 1; i++)<br>        {<br>            for (int j = 1; j &lt; int.Parse(txt_column.Text) + 1; j++)<br>            {<br>                P_WordTable.Cell(i, j).Range.Text =                            //向表格中添加数据<br>            string.Format(“{0}行 {1}列”, i.ToString(), j.ToString());<br>                Thread.Sleep(10);                                    //线程挂起10毫秒<br>        }<br>            this.Invoke(                                            //调用窗体线程<br>        (MethodInvoker)(() =&gt;                                 //使用Lambda表达式<br>{<br>        G_ToolProgressBar.Value = i + 1;                        //设置进度信息<br>}));<br>        }<br>        G_str_path = string.Format(                                    //计算文件保存路径<br>    @”{0}\{1}”, G_FolderBrowserDialog.SelectedPath,<br>    DateTime.Now.ToString(“yyyy年M月d日h时s分m秒fff毫秒”) + “.doc”);<br>        P_wd.SaveAs(                                            //保存Word文件<br>    ref G_str_path,<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>    ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>    ref G_missing, ref G_missing, ref G_missing);<br>        ((Word._Application)G_wa.Application).Quit(                            //退出应用程序<br>    ref G_missing, ref G_missing, ref G_missing);<br>        this.Invoke(                                                //开始执行窗体线程<br>    (MethodInvoker)(() =&gt;                                    //使用lambda表达式<br>{<br>        btn_Display.Enabled = true;                                //启用显示按钮<br>    MessageBox.Show(“成功创建Word文档！”, “提示！”);                //弹出消息对话框<br>}));<br>    });<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟005：使用Cell方法轻松的获取或设置表格中的文本信息！ 表格对象的Cell方法提供了两个参数并返回一个Range对象。方法中的两个参数分别为表格对象中的行与列的索引，有一点要注意，参数中行与列的索引都是从1开始的，根据两个参数可以找到并返回表格中的单元格的Range对象，并可以根据Range对象的Text属性获取或设置单元格的文本内容。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>多功能MP3播放器</title>
    <url>/zh-CN/2019/07/29/e5-a4-9a-e5-8a-9f-e8-83-bdmp3-e6-92-ad-e6-94-be-e5-99-a8.html</url>
    <content><![CDATA[<h2 id="多功能MP3播放器"><a href="#多功能MP3播放器" class="headerlink" title="多功能MP3播放器"></a>多功能MP3播放器</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在过去，都是通过唱片或磁带存储音乐，使用起来非常不便，而且唱片和磁带容易损坏。随着网络的流行，现在听音乐大多都是从网络上下载。音乐文件的格式有很多，例如：WMA、RM和MP3等，比较常用的是MP3格式的文件。当从网络上将MP3格式的音乐下载到本地计算机后，需要通过播放器进行播放，通过本实例可以播放MP3格式的音乐，实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-28-16564134.png" alt=""> 图1 多功能MP3播放器</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时，主要是使用Windows Media Player组件实现播放MP3文件功能。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为MP3Player。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个OpenFileDialog控件，用来显示打开对话框；添加一个Timer组件，用来显示播放状态及控制播放进度条的滚动；添加两个HScrollBar控件，分别用来作为播放进度条和音量控制器；添加7个PictureBox控件，分别用来实现窗体最小化、关闭窗体、拖动窗体、播放MP3、暂停MP3、停止MP3和调节音量功能；添加一个Windows Media Player组件，用于播放MP3文件。 （3）程序主要代码如下： 如果想播放MP3文件，可以单击播放按钮，弹出选择MP3文件的窗口。选择之后，将文件的路径赋给axWindowsMediaPlayer1对象的URL属性，实现自动播放MP3的功能，代码如下：</p>
<p>private void pictureBox4_Click(object sender, EventArgs e)                //打开播放<br>{<br>    if (!flag)                                            //标记是暂停播放器还是选择打开文件<br>    {<br>        if (openFileDialog1.ShowDialog() == DialogResult.OK)            //选择文件<br>        {<br>            axWindowsMediaPlayer1.URL = openFileDialog1.FileName;        //将选择文件的路径赋值给URL属性<br>            m = 1;<br>            lblSongTitle.Text= “ 歌曲名称：” + axWindowsMediaPlayer1.currentMedia.getItemInfo(“Title”);<br>        }<br>    }<br>    else<br>    {<br>        axWindowsMediaPlayer1.Ctlcontrols.play();                    //如果是暂停播放器则调用play方法播放<br>    }<br>}</p>
<p>  如果想暂停播放MP3文件，可以单击暂停按钮。此时，会调用axWindowsMediaPlayer1对象的pause方法，实现暂停播放MP3的功能，代码如下：</p>
<p>private void pictureBox5_Click(object sender, EventArgs e)<br>{<br>    axWindowsMediaPlayer1.Ctlcontrols.pause();                    //暂停<br>    flag = true;                                        //设置flag为true，单击播放按钮直接播放<br>}</p>
<p>  如果想停止播放MP3文件，可以单击停止按钮。此时，会调用axWindowsMediaPlayer1对象的stop方法，实现停止播放MP3的功能，代码如下：</p>
<p>private void pictureBox6_Click(object sender, EventArgs e)<br>{<br>    axWindowsMediaPlayer1.Ctlcontrols.stop();                    //停止<br>    flag = false;                                        //设置flag为false，单击播放按钮选择新文件<br>}</p>
<p>  如果想静音，可以单击静音按钮。将axWindowsMediaPlayer1对象的mute属性设为true，则静音，设为false则取消静音，代码如下：</p>
<p>private void pictureBox7_Click(object sender, EventArgs e)                //静音<br>{<br>    if (MM)<br>    {<br>        pictureBox7.Image = (Image)Properties.Resources.音量按钮变色;        //设置按钮图标<br>        axWindowsMediaPlayer1.settings.mute = true;                //静音<br>        MM = false;                                    //MM设为false，用于控制按钮的图标切换<br>    }<br>    else                                            //如果MM为false<br>    {<br>        pictureBox7.Image = (Image)Properties.Resources.音量按钮;        //恢复原来的图标<br>        axWindowsMediaPlayer1.settings.mute = false;                //取消静音<br>        MM = true;                                    //MM设为true<br>    }<br>}</p>
<p>  当播放MP3文件时，程序提供一个进度条，用于显示歌曲播放的进度，这个功能是在Timer组件的Tick事件里实现的。在此事件中，除了显示歌曲播放的进度外，还实现了获取当前播放状态的功能，代码如下：</p>
<p>private void timer1_Tick(object sender, EventArgs e)<br>{<br>    int i =(int) axWindowsMediaPlayer1.playState;                    //获取播放器状态<br>    switch(i)                                            //通过switch语句判断<br>    {<br>        case 1: lblStauts.Text = “状态：停止”; break;                    //1表示停止<br>        case 2: lblStauts.Text = “状态：暂停”; break;                    //2表示暂停<br>        case 3: lblStauts.Text = “状态：播放”; break;                    //3表示播放<br>        case 6: lblStauts.Text = “状态：正在缓冲”; break;                //6表示正在缓冲<br>        case 9: lblStauts.Text = “状态：正在连接”; break;                //9表示正在连接<br>        case 10: lblStauts.Text = “状态：准备就绪”; break;                //10表示准备就绪<br>    }<br>    lbljindu.Text = axWindowsMediaPlayer1.Ctlcontrols.currentPositionString;    //显示播放的进度信息<br>    if (m == 1)<br>    {<br>        //设置进度条的最大值是音乐的总的播放时间<br>           hScrollBar1.Maximum = (int)axWindowsMediaPlayer1.currentMedia.duration;<br>        hScrollBar1.Minimum = 0;                            //最小值为0<br>//当前值是音乐的当前播放进度<br>        hScrollBar1.Value = (int)axWindowsMediaPlayer1.Ctlcontrols.currentPosition;<br>        hScrollBar2.Value=axWindowsMediaPlayer1.settings.volume;        //音量控制<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟004：多媒体播放器介绍。 多媒体播放器，其实一种能够播放视频文件的程序，它一般理解为多种媒体的综合，现在市场上最流行的多媒体播放器主要有酷我播放器和暴风影音播放器等。多媒体播放器最常见、最主要的功能如下： （1）可以播放MP3、WAV、AVI、DAT、RM、RMVB、MP4等各种格式的音频/视频文件； （2）暂停、播放、快进和快退播放文件； （3）设置音频、视频大小； （4）设置播放文件的播放模式（如单曲播放、顺序播放、循环播放等）； （5）实现字幕滚动，并根据选择的字幕移动播放进度条。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用GZip压缩文件</title>
    <url>/zh-CN/2019/08/03/e5-a6-82-e4-bd-95-e4-bd-bf-e7-94-a8gzip-e5-8e-8b-e7-bc-a9-e6-96-87-e4-bb-b6.html</url>
    <content><![CDATA[<h2 id="如何使用GZip压缩文件"><a href="#如何使用GZip压缩文件" class="headerlink" title="如何使用GZip压缩文件"></a>如何使用GZip压缩文件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用GZipStream类的Write方法实现对文件的压缩，在本实例的窗体中，首先选择要压缩的源文件，然后输入压缩文件的名称，最后单击“压缩”按钮实现将指定的文件压缩为GZip格式。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-03-04573020.png" alt=""> 图1 使用GZip压缩文件 注意：当压缩文件时，不需要指明压缩文件的扩展名，程序会自动为压缩文件设置扩展名(gzip)。</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>GZipStream类位于System.IO.Compression命名空间下，提供用于压缩和解压缩流的方法和属性。该类用来表示GZip数据格式，这种数据格式包括一个检测数据损坏的循环冗余校验值。当使用GZipStream类构造一个压缩流后，就可以使用该类的Write方法写数据，从而实现压缩文件功能。下面将介绍该类的Write方法。 Write方法实现从指定的字节数组中将要压缩的字节写入基础流，其语法格式如下： public override void Write(byte[] array, int offset, int count) Write方法语法中的参数说明如表1所示。 表1 Write方法语法中的参数说明</p>
<p>参数</p>
<p>说明</p>
<p>array</p>
<p>用于存储要压缩字节的数组</p>
<p>offset</p>
<p>数组中开始读取的位置</p>
<p>count</p>
<p>压缩的字节数</p>
<p>返回值</p>
<p>无返回值</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为GZipFile。 （2）在默认窗体Form中添加两个TextBox控件，分别用来显示源文件路径及输入压缩文件名称；添加两个Button按钮，分别用来选择要压缩的文件及实现压缩文件。 （3）主要程序代码如下：</p>
<p>private void button2_Click(object sender, EventArgs e)<br>{<br>    if (String.IsNullOrEmpty(textBox1.Text))                //若未选择源文件<br>    {<br>        MessageBox.Show(“请选择源文件!”,”信息提示”);<br>        return;<br>    }<br>    if (String.IsNullOrEmpty(textBox2.Text))                //若未输入压缩文件名称<br>    {<br>        MessageBox.Show(“请输入压缩文件名!”, “信息提示”);<br>        return;<br>    }<br>    string str1 = textBox1.Text;                        //获取源文件路径<br>    string str2 = textBox2.Text.Trim()+”.gzip”;                //获取压缩文件的名称<br>    byte[] myByte = null;                            //定义字节数组引用<br>    FileStream myStream = null;                        //表示源文件的文件流<br>    FileStream myDesStream = null;                    //表示压缩文件的文件流<br>    GZipStream myComStream = null;                    //表示压缩流<br>    try<br>    {<br>        //获取源文件的文件流<br>        myStream = new FileStream(str1, FileMode.Open, FileAccess.Read, FileShare.Read);<br>        myByte = new byte[myStream.Length];            //根据源文件流的大小创建缓冲区<br>        myStream.Read(myByte, 0, myByte.Length);            //把源文件的文件流写入缓冲区<br>        //创建压缩文件的文件流<br>        myDesStream = new FileStream(str2, FileMode.OpenOrCreate, FileAccess.Write);<br>        //根据压缩文件的文件流生成压缩流<br>        myComStream = new GZipStream(myDesStream, CompressionMode.Compress, true);<br>        myComStream.Write(myByte, 0, myByte.Length);        //把源文件的文件流写入压缩流<br>        MessageBox.Show(“压缩文件完成！”);<br>    }<br>    catch { }<br>    finally<br>    {<br>        myStream.Close();<br>        myComStream.Close();<br>        myDesStream.Close();<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟006：创建压缩流 通过创建GZipStream对象来创建压缩流时，需要给构造方法的第二个参数传入CompressionMode.Compress枚举值。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用GZip解压文件</title>
    <url>/zh-CN/2019/08/03/e5-a6-82-e4-bd-95-e4-bd-bf-e7-94-a8gzip-e8-a7-a3-e5-8e-8b-e6-96-87-e4-bb-b6.html</url>
    <content><![CDATA[<h2 id="如何使用GZip解压文件"><a href="#如何使用GZip解压文件" class="headerlink" title="如何使用GZip解压文件"></a>如何使用GZip解压文件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用GZipStream类的Read方法实现对文件的解压，在本实例的窗体中，首先选择要解压的GZip格式文件，然后输入解压文件的名称，最后单击“解压”按钮实现解压GZip格式的文件。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-03-04560077.png" alt=""> 图1 使用GZip解压文件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>若要使用GZipStream类构造一个解压缩流，则需要该类的Read方法读取数据，从而实现解压缩文件功能。下面将介绍该类的Read方法。 Read方法实现将若干解压缩的字节读入指定的字节数组，其语法格式如下： public override int Read(byte[] array, int offset, int count) Read方法语法中的参数说明如表1所示。 表1 Read方法语法中的参数说明</p>
<p>参数</p>
<p>说明</p>
<p>array</p>
<p>用于存储解压缩的字节的数组</p>
<p>offset</p>
<p>数组中开始读取的位置</p>
<p>count</p>
<p>解压缩的字节数</p>
<p>返回值</p>
<p>解压缩到字节数组中的字节数。如果已到达流的末尾，则返回 0 或已读取的字节数</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为UnGzipFile。 （2）在默认窗体Form中添加两个TextBox控件，分别用来显示GZip文件路径、输入解压文件名称；添加两个Button按钮，分别用来选择Gzip格式文件及实现解压文件。 （3）程序主要代码如下：</p>
<p>private void button2_Click(object sender, EventArgs e)<br>{<br>    if (String.IsNullOrEmpty(textBox1.Text))                        //若未选择gzip文件<br>    {<br>        MessageBox.Show(“请选择GZIP文件!”, “信息提示”);<br>        return;<br>    }<br>    if (String.IsNullOrEmpty(textBox2.Text))                        //若未输入解压文件名<br>    {<br>        MessageBox.Show(“请输入解压文件名!”, “信息提示”);<br>        return;<br>    }<br>    string str1 = textBox1.Text;                                //获取gzip文件的名称<br>    string str2 = textBox2.Text.Trim();                            //获取解压文件名<br>    byte[] myByte = null;                                    //定义字节数组引用<br>    FileStream myStream = null;                                //表示gzip文件的文件流<br>    FileStream myDesStream = null;                            //表示解压文件的文件流<br>    GZipStream myDeComStream = null;                        //表示解压缩流<br>    try<br>    {<br>        myStream = new FileStream(str1, FileMode.Open);                //获取gzip文件的文件流<br>        //根据gzip文件的文件流生成解压缩流<br>        myDeComStream = new GZipStream(myStream, CompressionMode.Decompress, true);<br>        myByte = new byte[4];                                //创建4个字节大小的缓冲区<br>        int myPosition = (int)myStream.Length - 4;<br>        myStream.Position = myPosition;                        //设置此流的当前位置<br>        myStream.Read(myByte, 0, 4);                            //读入4个字节到缓冲区<br>        myStream.Position = 0;                                //重新设置此流的当前位置<br>        int myLength = BitConverter.ToInt32(myByte, 0);<br>        byte[] myData = new byte[myLength + 100];                    //创建缓冲区<br>        int myOffset = 0;                                    //表示解压缩流的开始读取位置<br>        int myTotal = 0;                                    //表示从解压缩流中总共读取的字节数<br>        while (true)<br>        {<br>            //从解压缩流中读取数据写入缓冲区<br>            int myBytesRead = myDeComStream.Read(myData, myOffset, 100);<br>            if (myBytesRead == 0)                            //若读取解压缩流结束<br>                break;<br>            myOffset += myBytesRead;                        //设置新的起始位置<br>            myTotal += myBytesRead;                            //获取总共读取的字节数<br>        }<br>        myDesStream = new FileStream(str2, FileMode.Create);            //创建解压文件的文件流<br>        myDesStream.Write(myData, 0, myTotal);                    //把缓冲区中的数据写入文件流<br>        myDesStream.Flush();<br>        MessageBox.Show(“解压文件完成！”);<br>    }<br>    catch { }<br>    finally<br>    {<br>        myStream.Close();<br>        myDeComStream.Close();<br>        myDesStream.Close();<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟007：创建解压缩流 通过创建GZipStream对象来创建解压缩流时，需要给构造方法的第二个参数传入CompressionMode.Decompress枚举值。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用WinRAR压缩文件</title>
    <url>/zh-CN/2019/08/03/e5-a6-82-e4-bd-95-e4-bd-bf-e7-94-a8winrar-e5-8e-8b-e7-bc-a9-e6-96-87-e4-bb-b6.html</url>
    <content><![CDATA[<h2 id="如何使用WinRAR压缩文件"><a href="#如何使用WinRAR压缩文件" class="headerlink" title="如何使用WinRAR压缩文件"></a>如何使用WinRAR压缩文件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例通过使用C#语言执行WinRAR软件的压缩命令来实现压缩文件。运行本实例，首先在窗体中选择要压缩的源文件，然后输入压缩文件的名称，最后单击“压缩”按钮实现将指定的文件压缩为rar格式。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-03-0400108.png" alt=""> 图1 使用WinRAR压缩文件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>WinRAR软件可以使用命令行模式实现对文件的压缩，本实例使用的压缩文件的语法格式如下： WinRAR a rarFile sourceFile WinRAR软件的压缩命令参数及说明如表1所示。 表1 WinRAR软件的压缩命令参数及说明</p>
<p>参数</p>
<p>说明</p>
<p>WinRAR</p>
<p>WinRAR软件的执行命令</p>
<p>a</p>
<p>WinRAR软件的压缩命令，表示添加文件到压缩文件</p>
<p>rarFile</p>
<p>压缩文件的名称</p>
<p>sourceFile</p>
<p>被压缩的文件</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/2019-08-03-04001410.jpeg" alt="提示"> 说明：压缩文件时，生成的压缩文件位于被压缩文件所在的目录。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为WinRARFile。 （2）在默认窗体Form1中添加两个TextBox控件，分别用来显示源文件路径及输入压缩文件名称；添加两个Button按钮，分别用来选择要压缩的文件及实现压缩文件。 （3）程序主要代码如下：</p>
<p>private void button3_Click(object sender, EventArgs e)<br>{<br>    if (String.IsNullOrEmpty(textBox1.Text))                                //若未选择源文件<br>    {<br>        MessageBox.Show(“请选择源文件!”, “信息提示”);<br>        return;<br>    }<br>    if (String.IsNullOrEmpty(textBox2.Text))                                //若未输入压缩文件名<br>    {<br>        MessageBox.Show(“请输入压缩文件名!”, “信息提示”);<br>        return;<br>    }<br>    String myRar;                                                //表示WinRAR.exe所在路径<br>    RegistryKey myReg;                                            //声明RegistryKey引用<br>    Object myObj;                                                //声明Object引用<br>    String myInfo;                                                //表示压缩命令的字符串<br>    ProcessStartInfo myStartInfo;                                        //声明ProcessStartInfo引用<br>    Process myProcess;                                            //声明Process类的引用<br>    string strRar;                                                //表示压缩文件名<br>    string strFile;                                                //表示源文件名<br>    try<br>    {<br>        //检索注册表HKEY_CLASSES_ROOT基项下的指定子项<br>        myReg = Registry.ClassesRoot.OpenSubKey(@”Applications\WinRAR.exe\Shell\Open\Command”);<br>        //检索子项中与指定名称关联的值<br>        myObj = myReg.GetValue(“”);<br>        //获取包含WinRAR.exe文件所在路径的字符串<br>        myRar = myObj.ToString();<br>        myReg.Close();                                            //关闭指定的注册表项<br>        //获取WinRAR.exe文件所在的完整路径<br>        myRar = myRar.Substring(1, myRar.Length - 7);<br>        strRar = textBox2.Text.Trim() + “.rar”;                                //设置压缩文件的名称<br>        strFile = textBox1.Text.Substring(textBox1.Text.LastIndexOf(“\&quot;)+1);            //获取源文件的名称<br>        myInfo = “ a “ + strRar + “ “ + strFile + “”;                            //设置压缩命令<br>        myStartInfo = new ProcessStartInfo();                                //创建ProcessStartInfo对象<br>        myStartInfo.FileName = myRar;                                //设置要启动应用程序的路径<br>        myStartInfo.Arguments = myInfo;                                //设置启动程序时的命令参数<br>        myStartInfo.WindowStyle = ProcessWindowStyle.Hidden;                    //隐藏进程窗口<br>        //设置要启动的进程的初始目录<br>        myStartInfo.WorkingDirectory = textBox1.Text.Substring(0, textBox1.Text.LastIndexOf(“\&quot;));<br>        myProcess = new Process();                                    //新建进程<br>        //设置要传递给进程的Start方法的属性<br>        myProcess.StartInfo = myStartInfo;<br>        myProcess.Start();                                        //启动进程<br>        myProcess.WaitForExit();                                    //等待关闭进程<br>        myProcess.Close();                                        //释放进程资源<br>        MessageBox.Show(“压缩文件成功！”);<br>    }<br>    catch(Exception ex)<br>    {<br>        throw ex;<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟008：隐藏启动进程时使用的窗口。 当启动一个进程之后，若不希望显示进程运行时的窗口，可以通过设置当前进程的WindowStyle属性值为ProcessWindowStyle.Hidden来实现。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>学校体操定时音乐播放</title>
    <url>/zh-CN/2019/07/18/e5-ad-a6-e6-a0-a1-e4-bd-93-e6-93-8d-e5-ae-9a-e6-97-b6-e9-9f-b3-e4-b9-90-e6-92-ad-e6-94-be.html</url>
    <content><![CDATA[<h2 id="学校体操定时音乐播放"><a href="#学校体操定时音乐播放" class="headerlink" title="学校体操定时音乐播放"></a>学校体操定时音乐播放</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>学校的广播体操，在第二节课下课时，学生到操场上集合，开始做广播体操，这时广播室内便会响起音乐。其实，这种定时播音的功能是由程序控制的，当系统时间为指定的时刻，程序就会播放音乐。本实例中笔者设计了一个定时播放音乐的程序，实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-18-15164389.png" alt=""> 图1 学校体操定时音乐播放</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现时，主要是利用Timer计时器组件定时读取系统时间，如果系统时间为指定的时刻，则利用Windows Media Player组件播放音乐。下面对本实例中用到的关键技术进行详细讲解。 Timer组件表示一个计时器，它可以按用户定义的时间间隔来引发事件，引发的事件一般为周期性的，每隔若干秒或若干毫秒执行一次，其常用的属性、方法及事件如表1所示。 表1 Timer组件的常用属性、方法及事件</p>
<p>属性、方法及事件</p>
<p>说明</p>
<p>Enabled属性</p>
<p>获取或设置计时器是否正在运行</p>
<p>Interval属性</p>
<p>获取或设置在相对于上一次发生的Tick事件引发Tick事件之前的时间（以毫秒为单位）</p>
<p>Start方法</p>
<p>启动计时器</p>
<p>Stop方法</p>
<p>停止计时器</p>
<p>Tick事件</p>
<p>当指定的计时器间隔已过去而且计时器处于启用状态时发生</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为ClockingPlayImplement。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加3个Button控件，分别用来执行德等待播放、显示选择对话框和退出应用程序功能；添加两个TextBox控件，分别用来设置播放时间和音乐文件路径；添加一个Windows Media Player组件，用来播放媒体文件。 （3）程序主要代码如下：</p>
<p>private void timer1_Tick(object sender, EventArgs e)<br>{<br>    //当当前的时间与文本框中的内容一致时<br>    if (DateTime.Now.ToShortTimeString( ) == this.textBox2.Text.Trim( ).ToString( ))<br>    {<br>        this.axWindowsMediaPlayer1.URL = this.textBox1.Text;             //设置音乐文件的播放路径<br>        this.axWindowsMediaPlayer1.Ctlcontrols.play( );                 //播放多媒体文件<br>        this.timer1.Enabled = false;                             //关闭timer1计时器<br>        this.timer2.Enabled = true;                             //启动timer2计时器<br>        this.timer2.Interval = 1000;                             //设置timer2计时器的Tick事件间隔为1s<br>        this.Show( );                                     //显示该窗体<br>    }<br>}<br>private void timer2_Tick(object sender, EventArgs e)<br>{<br>    if (this.axWindowsMediaPlayer1.status != “正在播放”)                //当多媒体处于正在播放的状态时<br>    {<br>        this.timer2.Enabled = false;                             //关闭timer2计时器<br>        MessageBox.Show(“本次播放已完成，谢谢使用！！！”);        //弹出信息提示<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟006：启动和关闭Timer计时器的两种方法。 启动Timer计时器时，可以将其Enabled属性设置为true，或者调用其Start方法；而关闭Timer计时器时，则需要将其Enabled属性设置为false，或者调用其Stop方法。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>实时读取不同数据到Excel进行汇总处理</title>
    <url>/zh-CN/2019/08/14/e5-ae-9e-e6-97-b6-e8-af-bb-e5-8f-96-e4-b8-8d-e5-90-8c-e6-95-b0-e6-8d-ae-e5-88-b0excel-e8-bf-9b-e8-a1-8c-e6-b1-87-e6-80-bb-e5-a4-84-e7-90-86.html</url>
    <content><![CDATA[<p><strong>实时读取不同数据到Excel进行汇总处理</strong></p>
<p>实例说明</p>
<p>本实例使用C#代码实现了实时读取不同数据到Excel进行汇总处理的功能。运行本实例，如图1所示，单击第一个”选择”按钮，选择要读取的文本文件；单击第二个”选择”按钮，选择要读取的Word文件；单击第3个”选择”按钮，选择要读取的Access数据库文件；单击第4个”选择”按钮，选择Excel文件；单击”开始”按钮，启动Timer计时器，并实时将各种不同的数据读取到Excel文件进行汇总处理；单击”停止”按钮，停止Timer计时器，同时停止向Excel文件中读取数据；单击”查看”按钮，查看导入数据之后的Excel文件。</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/081419_1103_Excel1.png" alt=""></p>
<p>图1 实时读取不同数据到Excel进行汇总处理 关键技术</p>
<p>本实例主要实现将3种不同的数据（文本文件数据、Word文档数据和Access数据库数据）实时汇总到Excel中的功能，在将这3种数据汇总到Excel时，分别需要用到文本文件的流读取、Word文档内容的获取和OLEDB获取Access数据等技术，另外，还需要使用Timer计时器来控制数据的实时汇总。下面对本实例中用到的关键技术进行详细讲解。</p>
<p>Timer计时器可以按用户定义的时间间隔来引发事件，引发的事件一般为周期性的，每隔若干秒或若干毫秒执行一次，其Interval属性用来获取或设置在相对于上一次发生的Tick事件引发Tick事件之前的时间（以毫秒为单位）。Interval属性语法格式如下：</p>
<p>public int Interval { get; set; }</p>
<p>参数说明</p>
<p>R  属性值：指定在相对于上一次发生的Tick事件引发Tick事件之前的毫秒数，该值不能小于1。</p>
<p>设计过程</p>
<p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为DisDataToExcel。</p>
<p>（2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加4个TextBox控件，分别用来显示选择的文本文件路径、Word文档路径、Access数据库文件路径和Excel文件路径；添加7个Button控件，分别用来执行选择文本文件、选择Word文档、选择Access数据库文件、选择Excel文件、开始和停止将不同数据导入到Excel文件中、查看Excel文件操作；添加一个Timer组件，用来实时将各种不同的数据导入到Excel中进行汇总处理。</p>
<p>（3）程序主要代码如下：</p>
<p>在timer1组件的Tick事件中，首先判断是否选择了Excel文件，如果已经选择，则分别判断是否选择了文本文件、Word文件及Access数据库文件，并调用相应的自定义方法将各种不同的数据导入到选择的Excel文件中，代码如下：</p>
<p>private void timer1_Tick(object sender, EventArgs e)<br>{<br>    if (txt_Excel.Text != “”)                                                         //判断是否选择了Excel文件<br>    {<br>        if (txt_Txt.Text != “”)                                                            //判断是否选择了文本文件<br>            TxtToExcel(txt_Txt.Text, txt_Excel.Text);                                     //将文本文件数据导入Excel<br>        if (txt_Word.Text != “”)                                                                //判断是否选择了Word文件<br>            WordToExcel(txt_Word.Text, txt_Excel.Text);                                      //将Word文件数据导入Excel<br>        if (txt_Access.Text != “”)                                                       //判断是否选择了Access文件<br>        {<br>            List<string> P_list_Tables = GetTable(txt_Access.Text);                         //获取Access中的所有表<br>            for (int i = 0; i &lt; P_list_Tables.Count; i++)                                      //遍历所有表<br>            {<br>                AccessToExcel(txt_Access.Text, P_list_Tables[i], txt_Excel.Text);          //将表中的数据导入Excel<br>            }<br>        }<br>    }<br>}</p>
<p>上面的代码中用到了TxtToExcel方法、WordToExcel方法和AccessToExcel方法，这3个方法是用户自定义的方法，下面分别进行介绍。TxtToExcel方法用来将文本文件的数据导入到Excel文件中，该方法中主要是通过文件流读取文本文件中的数据，并将读取到的数据填充到指定的Excel单元格中。TxtToExcel方法实现代码如下：</p>
<p>private void TxtToExcel(string P_str_Txt,string P_str_Excel)<br>{<br>    int P_int_Count = 0;                                                                     //记录正在读取的行数<br>    string P_str_Line;                                                                  //记录读取行的内容<br>    List<string> P_str_List = new List<string>();                                                //存储读取的所有内容<br>    StreamReader SReader = new StreamReader(P_str_Txt, Encoding.Default);                   //创建流读取对象<br>    while ((P_str_Line = SReader.ReadLine()) != null)                                                //循环读取文本文件中的每一行<br>    {<br>        P_str_List.Add(P_str_Line);                                                          //将读取到的行内容添加到泛型集合中<br>        P_int_Count++;                                                                     //使当前读取行数加1<br>}<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.Application();<br>    object missing = System.Reflection.Missing.Value;                                        //获取缺少的object类型值<br>    //打开指定的Excel文件<br>    Microsoft.Office.Interop.Excel.Workbook workbook = excel.Application.Workbooks.Open(P_str_Excel, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>    Microsoft.Office.Interop.Excel.Worksheet newWorksheet = (Microsoft.Office.Interop.Excel.Worksheet)workbook.Worksheets.Add(missing, missing, missing, missing);<br>    excel.Application.DisplayAlerts = false;                                                  //不显示提示对话框<br>    for (int i = 0; i &lt; P_str_List.Count; i++)                                                        //遍历泛型集合<br>    {<br>        newWorksheet.Cells[i + 1, 1] = P_str_List[i];                                                //直接将遍历到的内容添加到工作表中<br>    }<br>    workbook.Save();                                                                 //保存工作表<br>    workbook.Close(false, missing, missing);                                                     //关闭工作表<br>}<br>WordToExcel方法用来将Word文件中的数据导入到Excel文件中，该方法中首先需要判断Word文件中是否有表格存在，如果有表格存在，则将Word表格中的数据一一插入到Excel文件的对应单元格中；如果没有表格存在，则将Word文件中的所有内容整体插入到Excel文件的一个单元格中。WordToExcel方法实现代码如下：<br>private void WordToExcel(string P_str_Word, string P_str_Excel)<br>{<br>//创建Word对象<br>    Microsoft.Office.Interop.Word.Application word = new Microsoft.Office.Interop.Word.Application();<br>    Microsoft.Office.Interop.Word.Table table;                                                   //声明Word表格对象<br>//定义3个变量，分别用来存储表格数量、表格中的行数、列数<br>    int P_int_TableCount = 0, P_int_Row = 0, P_int_Column = 0;<br>    string P_str_Content;                                                                    //存储Word表格的单元格内容<br>    object missing = System.Reflection.Missing.Value;                                        //获取缺少的object类型值<br>object P_obj_Name;                                                               //存储遍历到的Word文件名<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.Application();<br>    //打开指定的Excel文件<br>Microsoft.Office.Interop.Excel.Workbook workbook = excel.Application.Workbooks.Open(P_str_Excel, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>//创建新工作表<br>    Microsoft.Office.Interop.Excel.Worksheet newWorksheet = (Microsoft.Office.Interop.Excel.Worksheet)workbook.Worksheets.Add(missing, missing, missing, missing);<br>    P_obj_Name = (object)P_str_Word;                                                             //记录遍历到的Word文件名<br>    //打开Word文档<br>    Microsoft.Office.Interop.Word.Document document = word.Documents.Open(ref P_obj_Name, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing);<br>    word.DisplayAlerts = Microsoft.Office.Interop.Word.WdAlertLevel.wdAlertsNone;        //设置操作Word时不显示任何对话框<br>    P_int_TableCount = document.Tables.Count;                                                //获取Word文档中表格的数量<br>    if (P_int_TableCount &gt; 0)                                                              //判断表格数量是否大于0<br>    {<br>        for (int j = 1; j &lt;= P_int_TableCount; j++)                                              //遍历所有表格<br>        {<br>            table = document.Tables[j];                                                    //记录遍历到的表格<br>            P_int_Row = table.Rows.Count;                                                    //获取表格行数<br>            P_int_Column = table.Columns.Count;                                            //获取表格列数<br>            for (int row = 1; row &lt;= P_int_Row; row++)                                        //遍历表格中的行<br>            {<br>                for (int column = 1; column &lt;= P_int_Column; column++)               //遍历表格中的列<br>                {<br>                    P_str_Content = table.Cell(row, column).Range.Text;               //获取遍历到的单元格内容<br>//将遍历到的单元格内容添加到Excel单元格中<br>                    newWorksheet.Cells[row, column] = P_str_Content.Substring(0, P_str_Content.Length - 2);<br>                }<br>            }<br>        }<br>    }<br>    else<br>    {<br>        if (P_int_Row == 0)                                                              //判断前面是否已经填充过表格<br>//直接将Word文档内容添加到工作表中<br>            newWorksheet.Cells[P_int_Row + 1, 1] = document.Content.Text;<br>        else<br>//直接将Word文档内容添加到工作表中<br>            newWorksheet.Cells[P_int_Row, 1] = document.Content.Text;<br>    }<br>    document.Close(ref missing, ref missing, ref missing);                                          //关闭Word文档<br>    excel.Application.DisplayAlerts = false;                                                  //不显示提示对话框<br>    workbook.Save();                                                                 //保存工作表<br>    workbook.Close(false, missing, missing);                                                     //关闭工作表<br>    word.Quit(ref missing, ref missing, ref missing);                                           //退出Word应用程序<br>}<br>AccessToExcel方法用来将Access数据库中的指定数据表的内容导入到Excel文件中，该方法主要通过使用“select * into from 表名”SQL语句来进行实现。AccessToExcel方法实现代码如下：<br>private void AccessToExcel(string P_str_Access,string P_str_Table,string P_str_Excel)<br>{<br>    string P_str_Con = @”Provider=Microsoft.Jet.OLEDB.4.0;Data Source=” + P_str_Access + “;Persist Security Info=True”;                                                       //记录连接Access的语句<br>    string P_str_Sql = “”;                                                                    //存储要执行的SQL语句<br>    OleDbConnection oledbcon = new OleDbConnection(P_str_Con);                          //创建OLEDB连接对象<br>    OleDbCommand oledbcom;                                                           //定义OleDbCommand对象<br>    oledbcon.Open();                                                                  //打开数据库连接<br>P_str_Sql = @”select * into [Excel 8.0;database=” + P_str_Excel + “].” + “[“ + P_str_Table + “] from “ + P_str_Table + “”;                                                      //记录连接Excel的语句<br>//创建OleDbCommand对象<br>    oledbcom = new System.Data.OleDb.OleDbCommand(P_str_Sql, oledbcon);<br>    oledbcom.ExecuteNonQuery();                                                      //将数据表的内容导入到Excel中<br>    oledbcon.Close();                                                                  //关闭数据库连接<br>    oledbcon.Dispose();                                                               //释放资源<br>}</p>
<p>秘笈心法</p>
<p>心法领悟037：使用线程代替Timer组件！</p>
<p>Timer组件可以按用户定义的时间间隔来引发Tick事件，Tick事件一般为周期性的，每隔若干秒或若干毫秒执行一次，Timer组件工作在窗体线程中，如果Timer组件中执行了较为耗时的操作，会增加窗体线程的负担，导致窗体中其它操作不能及时得到CPU资源，出现窗体长时间或短时间无响应的情况。在适当的情况下可以使用线程来代替Timer组件，这样会减少窗体线程的负担。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>实时读取Excel数据到Sql Server数据库</title>
    <url>/zh-CN/2019/08/09/e5-ae-9e-e6-97-b6-e8-af-bb-e5-8f-96excel-e6-95-b0-e6-8d-ae-e5-88-b0sql-server-e6-95-b0-e6-8d-ae-e5-ba-93.html</url>
    <content><![CDATA[<h2 id="实时读取Excel数据到Sql-Server数据库"><a href="#实时读取Excel数据到Sql-Server数据库" class="headerlink" title="实时读取Excel数据到Sql Server数据库"></a>实时读取Excel数据到Sql Server数据库</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用C#代码实现了实时将Excel文件中的数据读取到Sql Server数据库中的功能。运行本实例，如图1所示，单击“选择”按钮，选择要读取的Excel文件；然后在“Sql Server数据库连接设置”区域对数据库连接信息进行设置；最后根据用户的意愿确定“是否自动执行”复选框是否选中，单击“导出”按钮，启动Timer计时器，在Timer计时器中实时将Excel中的数据读取到Sql Server数据库中。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-09-15465724.png" alt=""> 图1 实时读取Excel数据到Sql Server数据库</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现时，首先需要将用户配置信息写入到INI文件中，然后在程序启动时，判断程序是否自动运行，如果是，则在Timer计时器中实时将Excel中的数据读取到Sql Server数据库中，在读取过程中，主要使用SqlBulkCopy类的WriteToServer方法来进行实现。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为RealTimeExcelToSql。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加4个TextBox控件，分别用来显示选择的Excel文件路径、输入Sql Server服务器名、登录用户名和登录密码；添加3个CheckBox控件，分别用来选择Sql Server数据库的登录方式和设置程序是否自动执行；添加一个ComboBox控件，用来选择要导入到的Sql Server数据库；添加3个Button控件，分别用来执行选择Excel文件、获取指定Sql Server服务器上的所有数据库和将设置写入到系统配置文件的操作；添加一个Timer组件，用来实时将Excel文件内容写入到Sql Server数据库中。 （3）程序主要代码如下：</p>
<p>private void timer1_Tick(object sender, EventArgs e)<br>{<br>    string P_str_Name = “”;                            //存储遍历到的Excel文件名<br>    List<string> P_list_SheetNames = new List<string>();            //创建泛型集合对象，用来存储工作表名称<br>    P_str_Name = txt_Path.Text;                            //记录遍历到的Excel文件名<br>    P_list_SheetNames = GetSheetName(P_str_Name);            //获取Excel文件中的所有工作表名<br>    for (int j = 0; j &lt; P_list_SheetNames.Count; j++)                //遍历所有工作表<br>    {<br>        if (ckbox_Windows.Checked)                        //如果用Windows身份验证登录Sql Server<br>            ImportDataToSql(P_str_Name, P_list_SheetNames[j], “Data Source=” + txt_Server.Text + “;Initial Catalog =” + cbox_Server.Text + “;Integrated Security=SSPI;”);                            //将工作表内容导出到Sql Server<br>        else if (ckbox_SQL.Checked)                        //如果用Sql Server身份验证登录Sql Server<br>            ImportDataToSql(P_str_Name, P_list_SheetNames[j], “Data Source=” + txt_Server.Text + “;Database=” + cbox_Server.Text + “;Uid=” + txt_Name.Text + “;Pwd=” + txt_Pwd.Text + “;”);                //将工作表内容导出到Sql Server<br>    }<br>    System.Threading.Thread.Sleep(60000);                    //使线程休眠1分钟<br>}</p>
<p>说明：上面的代码中用到了ImportDataToSql方法，该方法主要用来将Excel工作表中的数据导入到Sql Server数据库中，关于该方法的详细代码请参见实例“将多个Excel文件输出到同一Sql Server数据库”中的设计过程。</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟044：Timer计时器组件的使用。 Timer组件是一个计时器组件，它主要用来按用户定义的时间间隔来引发事件，引发的事件一般为周期性的，每隔若干秒或若干毫秒执行一次。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>实时读取Word文档中表格数据到SQL Server数据</title>
    <url>/zh-CN/2019/08/27/e5-ae-9e-e6-97-b6-e8-af-bb-e5-8f-96word-e6-96-87-e6-a1-a3-e4-b8-ad-e8-a1-a8-e6-a0-bc-e6-95-b0-e6-8d-ae-e5-88-b0sql-server-e6-95-b0-e6-8d-ae.html</url>
    <content><![CDATA[<h2 id="实时读取Word文档中表格数据到SQL-Server数据"><a href="#实时读取Word文档中表格数据到SQL-Server数据" class="headerlink" title="实时读取Word文档中表格数据到SQL Server数据"></a>实时读取Word文档中表格数据到SQL Server数据</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在窗体编程中可以使用Timer组件按照指定的时间间隔重复执行相应的操作。实例中也可以使用Timer组件每隔一段时间检测Word文档表格中的数据是否与SQL Server数据库中的数据一致，如果不一致，则更新数据库中的数据。但是，Timer组件使用的是窗体线程，如果窗体线程频繁的进行文件操作可能会导致窗体无响应或卡机的现象，所以，在实例中使用了线程代替Timer组件，实时读取Word文档中表格数据到SQL Server数据库。实例运行效果如图1与2所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-27-02551413.png" alt=""> 图1 显示SQL中的数据 图2 实时读取Word文档中表格数据</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍使用多线程技术监控Word文档中表格的变化，并将表格中更新的信息同步到SQL Server数据库，下面对本实例用到的关键技术进行详细讲解。 说明：使用线程首先要引用命名空间：“using System.Threading”。下面再次涉及到线程的使用时，将不再提示。 实例中使用了多线程技术监控Word文档中表格的变化，多线程的使用方法如图3所示。 图3 多线程的使用方法 从图3中可以看到，创建线程非常简单，首先创建线程对象，线程对象的构造方法中接受一个方法做为参数，实例中使用了Lambda表达式来代替方法，然后设置线程为后台线程，这一句是可选的，默认创建的线程为前台线程。最后使用Start方法开始执行线程。 注意：如果线程执行中发现Word文档中表格内的数据与数据集合中的数据不一致，则会立即更新数据集合中的数据，然后将数据集合中的数据更新到SQL Server数据库，将数据集合中的数据更新到SQL Server数据库使用了非常简单的方法，首先“清空”数据库中指定数据表内的所有数据，然后将数据集合中的数据“全部添加”到数据表中。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为Real-TimeToSQL。 （2）使用C#操作Word文档，需要引用相关的COM组件，引用COM组件的步骤请参照实例“创建Word文档”中的设计过程。 （3）更改默认窗体Form1的Name属性为Frm_Main，更改Text属性为“实时读取Word文档中表格数据到SQL Server数据库”，向窗体中添加4个TextBox控件，用于根据本地SQL设置填写SQL服务器连接信息；向窗体中添加一个Button按钮，用于跟踪Word文档的内容并将更新的内容同步到SQL数据库。 （4）程序主要代码如下：</p>
<p>private void btn_display_Click(object sender, EventArgs e)<br>{<br>    btn_display.Enabled = false;                                            //停用跟踪数据按钮<br>    ThreadPool.QueueUserWorkItem(                                        //开始线程池<br>        (pp) =&gt;                                                    //使用lambda表达式<br>        {<br>            G_wa = new Microsoft.Office.Interop.Word.Application();                    //创建应用程序对象<br>            G_wa.Visible = true;<br>            object P_Path = Directory.GetCurrentDirectory() + @”\Word.doc”;<br>            Word.Document P_Document = G_wa.Documents.Open(                    //打开Word文档<br>                ref P_Path, ref G_missing, ref G_missing, ref G_missing<br>                , ref G_missing, ref G_missing, ref G_missing, ref G_missing<br>                , ref G_missing, ref G_missing, ref G_missing, ref G_missing<br>                , ref G_missing, ref G_missing, ref G_missing, ref G_missing);<br>            TrackData();                                                //将Word数据更新到SQL<br>        });<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟021：使用线程代替Timer组件！ Timer组件可以按用户定义的时间间隔来引发Tick事件，Tick事件一般为周期性的，每隔若干秒或若干毫秒执行一次，Timer组件工作在窗体线程中，如果Timer组件中执行了较为耗时的操作，会增加窗体线程的负担，导致窗体中其它操作不能及时得到CPU资源，出现窗体长时间或短时间无响应的情况。在适当的情况下可以使用线程来代替Timer组件，这样会减少窗体线程的负担。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>实现动态系统托盘图标</title>
    <url>/zh-CN/2019/10/03/e5-ae-9e-e7-8e-b0-e5-8a-a8-e6-80-81-e7-b3-bb-e7-bb-9f-e6-89-98-e7-9b-98-e5-9b-be-e6-a0-87.html</url>
    <content><![CDATA[<h2 id="实现动态系统托盘图标"><a href="#实现动态系统托盘图标" class="headerlink" title="实现动态系统托盘图标"></a>实现动态系统托盘图标</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>当在QQ上收到消息时，任务栏的右下端会有一个图标在不停的闪烁，单击它就可打开信息浏览。本实例模拟信息提示功能，运行本实例，效果如图1所示，在主窗体中单击”发送消息”按钮，出现图标进行闪烁，如图2所示；单击”停止闪动”按钮，即可停止图标的闪烁，如图3所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0821_1.png" alt=""></p>
<p>图1 实现动态系统托盘图标</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0821_2.png" alt=""></p>
<p>图2 闪动图标</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0821_3.png" alt=""></p>
<p>图3 禁止图标</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现网络数据传输功能时用到了TcpListener类、TcpClient类和NetworkStream类，而在控制托盘图标的闪动时用到了Timer组件，下面对本实例用到的关键技术进行详细讲解。</p>
<p>（1）TcpListener类</p>
<p>TcpListener类用来从TCP网络客户端侦听连接，其常用方法及说明如表1所示。</p>
<p>表1 TcpListener类的常用方法及说明</p>
<p>属性</p>
<p>说明</p>
<p>AcceptTcpClient</p>
<p>接受挂起的连接请求</p>
<p>Start</p>
<p>开始侦听传入的连接请求</p>
<p>Stop</p>
<p>关闭侦听器</p>
<p>（2）TcpClient类</p>
<p>TcpClient类用来为TCP网络服务提供客户端连接，其构造函数语法格式如下：</p>
<p>public TcpClient(string hostname,int port)</p>
<p>参数说明</p>
<p>R hostname：要连接到的远程主机的DNS名。</p>
<p>R port：要连接到的远程主机的端口号。</p>
<p>（3）NetworkStream类</p>
<p>NetworkStream类提供在阻止模式下通过Stream套接字发送和接收数据的方法，其Read方法用于从NetworkStream流读取数据，语法格式如下：</p>
<p>public override int Read(byte[] buffer,int offset,int size)</p>
<p>Read方法语法中的参数及说明如表2所示。</p>
<p>表2 Read方法语法中的参数及说明</p>
<p>参数</p>
<p>描述</p>
<p>buffer</p>
<p>Byte类型的数组，它是内存中用于存储从NetworkStream读取的数据的位置</p>
<p>offset</p>
<p>buffer中开始将数据存储到的位置</p>
<p>size</p>
<p>要从NetworkStream中读取的字节数</p>
<p>返回值</p>
<p>从NetworkStream中读取的字节数</p>
<p>（4）托盘图标闪动</p>
<p>托盘图标闪动主要是在Timer组件的Tick事件中实现的。在该事件中，如果网络中有数据传输，则通过notifyIcon1控件的Icon属性更改托盘图标，这里需要注意的是，首先要准备两个图标文件，其中一个图标文件是透明的，这样两个图标文件相互切换的时候，就出现图标闪动的效果。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为DynamicTaskStock。</p>
<p>（2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个TextBox控件，用来输入对方的主机地址；添加两个Button控件，分别用来实现向对方发送消息以便使图标闪动和停止图标闪动功能。</p>
<p>（3）程序主要代码如下：</p>
<p>Frm_Main窗体中输入对方主机地址后，单击”发送消息”按钮，首先声明要发送的信息，然后根据输入的主机地址和固定端口创建一个TcpClient对象，最后将信息写入数据流进行传递。”发送消息”按钮的Click事件代码如下：</p>
<p>private void button1_Click(object sender, EventArgs e)</p>
<p>{</p>
<p>try</p>
<p>{</p>
<p>IPAddress[] ip = Dns.GetHostAddresses(Dns.GetHostName());            //获取本机地址</p>
<p>string message = “你好兄弟”;                                //传输的内容</p>
<p>TcpClient client = new TcpClient(txtAdd.Text, 888);                    //创建TcpClient对象</p>
<p>NetworkStream netstream = client.GetStream();                    //创建NetworkStream对象</p>
<p>StreamWriter wstream = new StreamWriter(netstream, Encoding.Default);    //创建StreamWriter对象</p>
<p>wstream.Write(message);                                //将信息写入流</p>
<p>wstream.Flush();</p>
<p>wstream.Close();                                        //关闭流</p>
<p>client.Close();                                        //关闭TcpClient对象</p>
<p>}</p>
<p>catch (Exception ex)</p>
<p>{</p>
<p>MessageBox.Show(ex.Message);</p>
<p>}</p>
<p>}</p>
<p>Frm_Main窗体中自定义一个StartListen方法，该方法用于监听指定端口，并通过该端口获取发送的信息。StartListen方法实现代码如下：</p>
<p>private void StartListen()</p>
<p>{</p>
<p>tcpListener = new TcpListener(888);                                //创建TcpListener对象</p>
<p>tcpListener.Start();                                        //开始监听</p>
<p>while (true)</p>
<p>{</p>
<p>TcpClient tclient = tcpListener.AcceptTcpClient();                    //接受连接请求</p>
<p>NetworkStream nstream = tclient.GetStream();                    //获取数据流</p>
<p>byte[] mbyte = new byte[1024];                                //建立缓存</p>
<p>int i = nstream.Read(mbyte, 0, mbyte.Length);                    //将数据流写入缓存</p>
<p>message = Encoding.Default.GetString(mbyte, 0, i);                    //获取传输的内容</p>
<p>}</p>
<p>}</p>
<p>Frm_Main窗体中的Timer组件主要控制系统托盘图标的闪动。实现时，首先声明一个bool类型的变量k，用于控制两个图标的切换；然后在Timer组件的Tick事件中，判断当网络中有消息传递时，开始控制托盘图标的闪动。代码如下：</p>
<p>bool k = true;                                                //一个标记，用于控制图标闪动</p>
<p>private void timer1_Tick(object sender, EventArgs e)</p>
<p>{</p>
<p>if (message.Length &gt; 0)                                    //如果网络中传输了数据</p>
<p>{</p>
<p>if (k)                                            //k为true时</p>
<p>{</p>
<p>notifyIcon1.Icon = Properties.Resources._1;                    //托盘图标为1</p>
<p>k = false;                                        //设k为false</p>
<p>}</p>
<p>else                                                //k为false时</p>
<p>{</p>
<p>notifyIcon1.Icon = Properties.Resources._2;                    //托盘图标为2，透明的图标</p>
<p>k = true;                                        //k为true</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟009：使用资源文件存储图片。</p>
<p>将图片存入资源文件中的步骤如下：首先在”解决方案资源管理器”中打开Properties中的Resources.resx文件；然后在打开的Resources.resx文件中单击”添加资源”右侧的向下箭头，在下拉项中选择”添加现有文件”，弹出”将现有文件添加到资源中”窗体，在该窗体中将指定的图片添加到资源文件中即可。</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>实现气泡提示窗口</title>
    <url>/zh-CN/2019/10/03/e5-ae-9e-e7-8e-b0-e6-b0-94-e6-b3-a1-e6-8f-90-e7-a4-ba-e7-aa-97-e5-8f-a3.html</url>
    <content><![CDATA[<h2 id="实现气泡提示窗口"><a href="#实现气泡提示窗口" class="headerlink" title="实现气泡提示窗口"></a>实现气泡提示窗口</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>气泡提示因为它的美观友好被大多数用户所接受，用户所喜爱的就是程序员要实现的。本实例实现了任务栏气泡提示，运行本实例，效果如图1所示，在主窗体中单击”提示”按钮，在任务栏中会出现一个托盘图标，在图标的右上方会出现相应的提示，如图2所示；单击”关闭”按钮，气泡提示和托盘图标同时消失。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0820_1.png" alt=""></p>
<p>图1 实现气泡提示窗口</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0820_2.png" alt=""></p>
<p>图2 气泡提示窗口</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时主要用到了NotifyIcon控件的ShowBalloonTip方法，下面对其进行详细讲解。</p>
<p>NotifyIcon控件表示在通知区域中创建图标的控件，其ShowBalloonTip方法用于在任务栏中持续显示具有指定标题、文本和图标的气球提示指定的时间，该方法常用语法格式如下：</p>
<p>Void NotifyIcon.ShowBalloonTip(int timeout,string tipTitle,string tipText,ToolTipIcon tipIcon);</p>
<p>ShowBalloonTip方法语法中的参数及说明如表1所示。</p>
<p>表1 ShowBalloonTip方法语法中的参数及说明</p>
<p>参数</p>
<p>描述</p>
<p>timeout</p>
<p>表示气球提示显示的时间长度</p>
<p>tipTitle</p>
<p>表示要在气球提示上显示的标题</p>
<p>tipText</p>
<p>表示要在气球提示上显示的文本</p>
<p>tipIcon</p>
<p>表示气球提示的图标</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为BubbleShowForm。</p>
<p>（2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个Button控件，分别用来显示气泡提示和关闭气泡提示。</p>
<p>（3）程序主要代码如下：</p>
<p>private void clewButton_Click(object sender,EventArgs e)</p>
<p>{</p>
<p>this.notifyIcon1.Visible = true;                    //设置提示控件可见</p>
<p>//显示气泡提示</p>
<p>this.notifyIcon1.ShowBalloonTip(1000,”当前时间：”,DateTime.Now.ToLocalTime().ToString(),ToolTipIcon.Info);</p>
<p>}</p>
<p>private void closeButton_Click(object sender,EventArgs e)</p>
<p>{</p>
<p>this.notifyIcon1.Visible = false;                    //设置提示控件不可见</p>
<p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟010：任务栏通知区域中图标的作用。</p>
<p>任务栏通知区域中的图标是一些进程的快捷方式，这些进程在计算机后台运行，如防病毒程序或音量控制等，这些进程不会具有自己的用户界面。</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>对子窗体进行垂直排列</title>
    <url>/zh-CN/2019/10/03/e5-af-b9-e5-ad-90-e7-aa-97-e4-bd-93-e8-bf-9b-e8-a1-8c-e5-9e-82-e7-9b-b4-e6-8e-92-e5-88-97.html</url>
    <content><![CDATA[<h2 id="对子窗体进行垂直排列"><a href="#对子窗体进行垂直排列" class="headerlink" title="对子窗体进行垂直排列"></a>对子窗体进行垂直排列</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例主要实现对多个子窗体进行垂直排列的功能，运行本实例，选择”加载子窗体”菜单项，在MDI父窗体中打开3个子窗体；选择”垂直平铺”菜单项，对打开的3个子窗体进行垂直排列，效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0837_1-1.png" alt=""></p>
<p>图1 对子窗体进行垂直排列</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例主要通过为LayoutMdi方法传递MdiLayout.TileVertical枚举值来实现子窗体的垂直排列。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为MDIVerticalSort。</p>
<p>（2）更改默认窗体Form1的Name属性为Frm_Main，并将其IsMdiContainer属性设置为True，以便作为父窗体。在Frm_Main窗体中添加一个MenuStrip控件，用来作为窗体的菜单栏，该菜单栏主要用来执行打开子窗体和对子窗体进行垂直排列操作。</p>
<p>（3）在项目中添加3个Windows窗体，分别命名为Frm_ChildOne.cs、Frm_ChildTwo.cs和Frm_ChildThree.cs，它们分别用来作为3个子窗体。</p>
<p>（4）程序主要代码如下：</p>
<p>private void 垂直平铺ToolStripMenuItem_Click(object sender, EventArgs e)</p>
<p>{</p>
<p>LayoutMdi(MdiLayout.TileVertical);                //使用MdiLayout枚举实现窗体的垂直平铺</p>
<p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟004：子窗体的概念及设置。</p>
<p>在MDI窗体中，可以放在父窗体中的其他窗体被成为”子窗体”，也称为”MDI子窗体”，可以通过设置某个窗体的MdiParent属性来确定子窗体。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>对子窗体进行层叠排列</title>
    <url>/zh-CN/2019/10/03/e5-af-b9-e5-ad-90-e7-aa-97-e4-bd-93-e8-bf-9b-e8-a1-8c-e5-b1-82-e5-8f-a0-e6-8e-92-e5-88-97.html</url>
    <content><![CDATA[<h2 id="对子窗体进行层叠排列"><a href="#对子窗体进行层叠排列" class="headerlink" title="对子窗体进行层叠排列"></a>对子窗体进行层叠排列</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例主要实现对多个子窗体进行层叠排列的功能，运行本实例，选择”加载子窗体”菜单项，在MDI父窗体中打开3个子窗体；选择”层叠排列”菜单项，对打开的3个子窗体进行层叠排列，效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0837_1.png" alt=""></p>
<p>图1 对子窗体进行层叠排列</p>
<p>说明：在MDI窗体中加载子窗体时，如果同时加载多个子窗体，默认就是以层叠方式进行排列的。</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例主要通过为LayoutMdi方法传递MdiLayout.Cascade枚举值来实现子窗体的层叠排列。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为MDICascadeSort。</p>
<p>（2）更改默认窗体Form1的Name属性为Frm_Main，并将其IsMdiContainer属性设置为True，以便作为父窗体。在Frm_Main窗体中添加一个MenuStrip控件，用来作为窗体的菜单栏，该菜单栏主要用来执行打开子窗体和对子窗体进行层叠排列操作。</p>
<p>（3）在项目中添加3个Windows窗体，分别命名为Frm_ChildOne.cs、Frm_ChildTwo.cs和Frm_ChildThree.cs，它们分别用来作为3个子窗体。</p>
<p>（4）程序主要代码如下：</p>
<p>private void 层叠排列ToolStripMenuItem_Click(object sender, EventArgs e)</p>
<p>{</p>
<p>LayoutMdi(MdiLayout.Cascade);                    //使用MdiLayout枚举实现窗体的层叠排列</p>
<p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟005：子窗体与父窗体的关系！</p>
<p>每个应用程序只能有一个父窗体，但一个父窗体可以有多个子窗体，所有的子窗体都在父窗体中显示，并且不能移出父窗体的框架区域。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>对子窗体进行水平排列</title>
    <url>/zh-CN/2019/10/03/e5-af-b9-e5-ad-90-e7-aa-97-e4-bd-93-e8-bf-9b-e8-a1-8c-e6-b0-b4-e5-b9-b3-e6-8e-92-e5-88-97.html</url>
    <content><![CDATA[<h2 id="对子窗体进行水平排列"><a href="#对子窗体进行水平排列" class="headerlink" title="对子窗体进行水平排列"></a>对子窗体进行水平排列</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在一个多文档窗体应用程序中添加完多个子窗体之后，如果一个MDI窗体中有多个子窗体同时打开，界面会显得非常的混乱，而且不容易浏览，这时可以通过使用C#中的相应方法对多个子窗体进行排列，以便使其看起来更加有序。运行本实例，选择”加载子窗体”菜单项，在MDI父窗体中打开3个子窗体，效果如图1所示；选择”水平平铺”菜单项，对打开的3个子窗体进行水平排列，效果如图2所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0837_1-2.png" alt=""></p>
<p>图1 加载所有子窗体</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0837_2.png" alt=""></p>
<p>图2 对子窗体进行水平排列</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例主要是通过用带有MdiLayout枚举的LayoutMdi方法来实现的，下面对LayoutMdi方法进行详细讲解。</p>
<p>LayoutMdi方法用来在MDI父窗体内排列多文档界面（MDI）子窗体，其语法格式如下：</p>
<p>public void LayoutMdi (MdiLayout value)</p>
<p>参数说明</p>
<p>R value：MdiLayout枚举值之一，用来定义MDI子窗体的布局。MdiLayout枚举用于指定MDI父窗体中子窗体的布局，其枚举值及说明如表1所示。</p>
<p>表1 MdiLayout枚举值及说明</p>
<p>枚举值</p>
<p>描述</p>
<p>Cascade</p>
<p>所有MDI子窗体均层叠在MDI父窗体的工作区内</p>
<p>TileHorizontal</p>
<p>所有MDI子窗体均水平平铺在MDI父窗体的工作区内</p>
<p>TileVertical</p>
<p>所有MDI子窗体均垂直平铺在MDI父窗体的工作区内</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为MDIHorizontalSort。</p>
<p>（2）更改默认窗体Form1的Name属性为Frm_Main，并将其IsMdiContainer属性设置为True，以便作为父窗体。在Frm_Main窗体中添加一个MenuStrip控件，用来作为窗体的菜单栏，该菜单栏主要用来执行打开子窗体和对子窗体进行水平排列操作。</p>
<p>（3）在项目中添加3个Windows窗体，分别命名为Frm_ChildOne.cs、Frm_ChildTwo.cs和Frm_ChildThree.cs，它们分别用来作为3个子窗体。</p>
<p>（4）程序主要代码如下：</p>
<p>Frm_Main窗体中，选择”加载子窗体”菜单项，打开添加的3个子窗体。”加载子窗体”菜单项的Click事件代码如下：</p>
<p>private void 加载子窗体ToolStripMenuItem_Click(object sender, EventArgs e)</p>
<p>{</p>
<p>Frm_ChildOne frm2 = new Frm_ChildOne();            //创建Frm_ChildOne对象</p>
<p>frm2.MdiParent = this;                            //设置MdiParent属性，将当前窗体作为父窗体</p>
<p>frm2.Show();                                //使用Show方法打开窗体</p>
<p>Frm_ChildTwo frm3 = new Frm_ChildTwo();            //创建Frm_ChildTwo对象</p>
<p>frm3.MdiParent = this;                            //设置MdiParent属性，将当前窗体作为父窗体</p>
<p>frm3.Show();                                //使用Show方法打开窗体</p>
<p>Frm_ChildThree frm4 = new Frm_ChildThree();            //创建Frm_ChildThree对象</p>
<p>frm4.MdiParent = this;                            //设置MdiParent属性，将当前窗体作为父窗体</p>
<p>frm4.Show();                                //使用Show方法打开窗体</p>
<p>}</p>
<p>选择”水平平铺”菜单项，调用LayoutMdi方法对打开的3个子窗体进行水平排列。”水平平铺”菜单项的Click事件代码如下：</p>
<p>private void 水平平铺ToolStripMenuItem_Click(object sender, EventArgs e)</p>
<p>{</p>
<p>LayoutMdi(MdiLayout.TileHorizontal);                //使用MdiLayout枚举实现窗体的水平平铺</p>
<p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟003：父窗体的概念及设置。</p>
<p>在MDI窗体中，起到容器作用的窗体被称为”父窗体”，父窗体通过将IsMdiContainer属性设置为true来实现。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title>对排序数据进行分析</title>
    <url>/zh-CN/2019/07/07/e5-af-b9-e6-8e-92-e5-ba-8f-e6-95-b0-e6-8d-ae-e8-bf-9b-e8-a1-8c-e5-88-86-e6-9e-90.html</url>
    <content><![CDATA[<h2 id="对排序数据进行分析"><a href="#对排序数据进行分析" class="headerlink" title="对排序数据进行分析"></a>对排序数据进行分析</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>使用图表显示统计信息时，数据量很大并且图表看起来会很杂乱。那么将图表按一定条件进行排序再显示给用户，这样可以解决数据量大、图表多、无法很快得到想要的信息这一棘手问题。本实例将通过柱形图对排序数据进行分析，实例运行效果如图1和图2所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-07-09371674.png" alt=""> 图1 升序排序 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-07-09371763.png" alt=""> 图2 降序排序</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现的重点是如何通过SQL语句对数据进行排序，而在排完序之后，即可调用Graphics类的FillRectangle方法绘制柱形图。下面对本实例中用到的关键技术进行详细介绍。 SQL语句的语法在索引中的各列上支持关键字ASC（升序）和DESC（降序），默认为升序。如何使用关键字ASC（升序）和DESC（降序），请看下面的例子。将“tb_Rectangle”表，按销售量（t_Num字段）查询，显示出销售量最低的3种商品，代码如下： SELECT TOP 3 * FROM tb_Rectangle order by t_Num desc</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为AnalyseSortData。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个Panel控件和两个Button控件，分别用来显示绘图结果和执行升序、降序绘图操作。 （3）程序主要代码如下：</p>
<p>private void ShowPic(string str)<br>{<br>    Conn();                                                        //打开数据库连接<br>    //生成SqlCommand对象<br>    using (cmd = new SqlCommand(“SELECT TOP 3 * FROM tb_Rectangle order by t_Num “ + str, con))<br>    {<br>        SqlDataReader dr = cmd.ExecuteReader();                                //创建SqlDataReader对象<br>        Bitmap bitM = new Bitmap(this.panel1.Width, this.panel1.Height);                //新建一张画布<br>        Graphics g = Graphics.FromImage(bitM);                                //创建Graphics对象用于绘图<br>        g.Clear(Color.White);                                            //设置画布背景<br>        for (int i = 0; i &lt; 5; i++)<br>        {<br>            g.DrawLine(new Pen(new SolidBrush(Color.Red), 2.0f), 50, this.panel1.Height - 20 - i * 20, this.panel1.Width - 40, this.panel1.Height - 20 - i * 20);                                                        //绘制水平线条<br>            g.DrawString(Convert.ToString(i * 100), new Font(“Times New Roman”, 10, FontStyle.Regular), new SolidBrush(Color.Black), 20, this.panel1.Height - 27 - i * 20);                                            //绘制商品上升数量<br>        }<br>        for (int j = 0; j &lt; 4; j++)<br>        {<br>            //绘制垂直线条<br>            g.DrawLine(new Pen(new SolidBrush(Color.Red), 1.0f), 50 + 40 * j, this.panel1.Height - 20, 50 + 40 * j, 50);<br>            if (dr.Read())<br>            {<br>                int x, y, w, h;                                            //声明变量存储坐标与宽高<br>                g.DrawString(dr[0].ToString(), new Font(“宋体”, 8, FontStyle.Regular), new SolidBrush(Color.Black), 76 + 40 * j, this.panel1.Height - 16);                                                            //绘制商品名称<br>                x = 78 + 40 * j;                                        //X坐标<br>//Y坐标<br>                y = this.panel1.Height - 20 - Convert.ToInt32((Convert.ToDouble(Convert.ToDouble(dr[1].ToString()) * 20 / 100)));<br>                w = 24;                                                //宽度<br>                h = Convert.ToInt32(Convert.ToDouble(dr[1].ToString()) * 20 / 100);            //高度<br>                g.FillRectangle(new SolidBrush(Color.FromArgb(56, 129, 78)), x, y, w, h);        //开始绘制柱形图<br>            }<br>        }<br>        if (str == “desc”)                                                //如果按降序排列<br>        {<br>            //绘制提示文字，提示商品是按降序排列的<br>            g.DrawString(“热卖前三名”, new Font(“宋体”, 9), new SolidBrush(Color.Red), this.panel1.Width / 2 - 26, 20);<br>        }<br>        else if (str == “asc”)                                            //如果按升序排列<br>        {<br>            //绘制提示文字，提示商品是按升序排列的<br>            g.DrawString(“热卖后三名”, new Font(“宋体”, 9), new SolidBrush(Color.Red), this.panel1.Width / 2 - 26, 20);<br>        }<br>        this.panel1.BackgroundImage = bitM;                                    //显示绘制的图形<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟005：使用DrawString方法绘制文本。 DrawString方法用来在指定位置并且用指定的Brush和Font对象绘制指定的文本字符串。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>对文本文件进行加密与解密</title>
    <url>/zh-CN/2019/08/06/e5-af-b9-e6-96-87-e6-9c-ac-e6-96-87-e4-bb-b6-e8-bf-9b-e8-a1-8c-e5-8a-a0-e5-af-86-e4-b8-8e-e8-a7-a3-e5-af-86.html</url>
    <content><![CDATA[<h2 id="对文本文件进行加密与解密"><a href="#对文本文件进行加密与解密" class="headerlink" title="对文本文件进行加密与解密"></a>对文本文件进行加密与解密</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在本实例的窗体中，首先选择要加密或解密的文本文件，然后单击“加密”或“解密”按钮对文本文件进行加密或解密。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-06-04370291.png" alt=""> 图1 对文本文件进行加密与解密</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时主要用到了System.Security.Cryptography命名空间下的RijndaelManaged类的CreateDecryptor方法、CreateEncryptor方法、CryptoStream类的Write方法。下面分别对它们进行详细讲解。 （1）RijndaelManaged类 该类是访问System.Security.Cryptography.Rijndael对称加密算法的托管版本，其语法格式如下： public sealed class RijndaelManaged : Rijndael 注意：此算法支持128、192或256位的密钥长度。 （2）CreateDecryptor方法 该方法位于RijndaelManaged类中，使用指定的Key和初始化向量（IV）创建对称的Rijndael解密器对象。其语法格式如下： public override IcryptoTransform　CreateDecryptor (byte[] rgbKey,byte[] rgbIV) 参数说明 rgbKey：用于对称算法的机密密钥。 rgbIV：用于对称算法的IV。 返回值：对称的Rijndael解密器对象。 （3）CreateEncryptor方法 该方法位于RijndaelManaged类中，使用指定的Key和初始化向量（IV）创建对称的Rijndael加密器对象。其语法格式如下： public override ICryptoTransform CreateEncryptor (byte[] rgbKey,byte[] rgbIV) 参数说明 rgbKe：用于对称算法的机密密钥。 rgbIV：用于对称算法的IV。 返回值：对称的Rijndael加密器对象。 （4）CryptoStream类 该类定义将数据流链接到加密转换的流，它的构造器语法格式如下： public CryptoStream (Stream stream,ICryptoTransform transform,CryptoStreamMode mode) 参数说明 stream：对其执行加密转换的流。 transform：要对流执行的加密转换。 mode：CryptoStreamMode枚举值之一。CryptoStreamMode枚举值及说明如表1所示。 表1 CryptoStreamMode枚举值及说明</p>
<p>枚举值</p>
<p>说明</p>
<p>Read</p>
<p>对加密流的读访问</p>
<p>Write</p>
<p>对加密流的写访问</p>
<p>（5）CryptoStream类的Write方法 该方法将一个字节序列写入当前CryptoStream类中，并从当前位置写入指定的字节数。其语法格式如下： public override void Write (byte[] buffer,int offset,int count) 参数说明 buffer：字节数组。该方法将count个字节从buffer复制到当前流。 offset：buffer中的字节偏移量，从此偏移量开始将字节复制到当前流。 count：要写入当前流的字节数。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为EncryptTextFileOne。 （2）在默认Form1窗体中，主要添加一个TextBox控件，用来显示文件路径；添加一个OpenFileDialog控件，用来选择要加密或解密的文件；添加3个Button控件，用来执行加密、解密和选择文件操作。 （3）程序主要代码如下： 单击“加密”按钮实现对选择的文本文件进行加密，“加密”按钮的Click事件代码如下：</p>
<p>private void button2_Click(object sender, EventArgs e)<br>{<br>    if (textBox1.Text == “”)                                    //若未选择要加密的文本文件<br>    { MessageBox.Show(“请选择要加密的文件”); }                        //如果没有选择则弹出提示<br>    else<br>    {<br>       try{<br>        string strPath = textBox1.Text;                                //加密文件的路径<br>        int intLent=strPath.LastIndexOf(“\&quot;)+1;                        //设置截取的起始位置<br>        int intLong = strPath.Length;                                //设置截取的长度<br>        string strName = strPath.Substring(intLent,intLong-intLent);            //要加密的文件名称<br>        int intTxt = strName.LastIndexOf(“.”);                            //设置截取的起始位置<br>        int intTextLeng = strName.Length;                            //设置截取的长度<br>        string strTxt = strName.Substring(intTxt,intTextLeng-intTxt);             //取出文件的扩展名<br>        strName = strName.Substring(0,intTxt);<br>        //加密后的文件名及路径<br>        string strOutName = strPath.Substring(0, strPath.LastIndexOf(“\&quot;) + 1) + strName + “Out” + strTxt;<br>//加密文件密钥<br>        byte[] key = { 24, 55, 102, 24, 98, 26, 67, 29, 84, 19, 37, 118, 104, 85, 121, 27, 93, 86, 24, 55, 102, 24, 98, 26, 67, 29, 9, 2, 49, 69, 73, 92 };<br>        byte[] IV ={ 22, 56, 82, 77, 84, 31, 74, 24, 55, 102, 24, 98, 26, 67, 29, 99 };<br>        RijndaelManaged myRijndael = new RijndaelManaged();<br>        FileStream fsOut = File.Open(strOutName, FileMode.Create, FileAccess.Write);<br>        FileStream fsIn = File.Open(strPath, FileMode.Open, FileAccess.Read);<br>//写入加密文本文件<br>        CryptoStream csDecrypt = new CryptoStream(fsOut, myRijndael.CreateEncryptor(key, IV), CryptoStreamMode.Write);<br>       BinaryReader br = new BinaryReader(fsIn);                        //创建阅读器来读加密文本<br>       csDecrypt.Write(br.ReadBytes((int)fsIn.Length), 0, (int)fsIn.Length);        //将数据写入加密文本<br>       csDecrypt.FlushFinalBlock();<br>       csDecrypt.Close();                                        //关闭CryptoStream对象<br>       fsIn.Close();                                            //关闭FileStream对象<br>       fsOut.Close();                                        //关闭FileStream对象<br>       if (MessageBox.Show(“加密成功!加密后的文件名及路径为:\n” + strOutName + “,是否册除源文件”, “信息提示”, MessageBoxButtons.YesNo) == DialogResult.Yes)<br>        {<br>            File.Delete(strPath);                                //删除指定文件<br>            textBox1.Text = “”;                                    //清空文本框<br>        }else<br>        { textBox1.Text = “”; }<br>    }<br>    catch (Exception ee)                                        //如果出现异常<br>    {<br>        MessageBox.Show(ee.Message);                            //输出异常信息<br>    }<br>    }<br>}</p>
<p>单击“解密”按钮实现对加密的文本文件进行解密，“解密”按钮的Click事件代码如下：</p>
<p>private void button3_Click(object sender, EventArgs e)<br>{<br>    if (textBox1.Text == “”)                                    //若未选择要解密的文件<br>    {<br>        MessageBox.Show(“请选择要解密的文件路径”);                    //如果没有选择则弹出提示<br>    }<br>    else<br>    {<br>        string strPath = textBox1.Text;                                //加密文件的路径<br>        int intLent = strPath.LastIndexOf(“\&quot;) + 1;                        //设置截取字符串的起始位置<br>        int intLong = strPath.Length;                                //设置截取长度<br>        string strName = strPath.Substring(intLent, intLong - intLent);            //要加密的文件名称<br>        int intTxt = strName.LastIndexOf(“.”);                            //截取字符串的起始位置<br>        int intTextLeng = strName.Length;                            //截取长度<br>        strName = strName.Substring(0, intTxt);                        //获取文件扩展名<br>        if (strName.LastIndexOf(“Out”) != -1)<br>        {<br>            strName = strName.Substring(0, strName.LastIndexOf(“Out”));<br>        }<br>        else<br>        {<br>            strName = strName + “In”;<br>        }<br>        //加密后的文件名及路径<br>        string strInName = strPath.Substring(0, strPath.LastIndexOf(“\&quot;) + 1) + strName + “.txt”;<br>//解密文件密钥<br>        byte[] key = { 24, 55, 102, 24, 98, 26, 67, 29, 84, 19, 37, 118, 104, 85, 121, 27, 93, 86, 24, 55, 102, 24, 98, 26, 67, 29, 9, 2, 49, 69, 73, 92 };<br>        byte[] IV ={ 22, 56, 82, 77, 84, 31, 74, 24, 55, 102, 24, 98, 26, 67, 29, 99 };<br>        RijndaelManaged myRijndael = new RijndaelManaged();                //创建RijndaelManaged对象<br>        //创建FileStream对象<br>        FileStream fsOut = File.Open(strPath, FileMode.Open, FileAccess.Read);<br>        CryptoStream csDecrypt = new CryptoStream(fsOut, myRijndael.CreateDecryptor(key, IV), CryptoStreamMode.Read);<br>        StreamReader sr = new StreamReader(csDecrypt);                    //把文件读出来<br>        StreamWriter sw = new StreamWriter(strInName);                    //解密后文件写入一个新文件<br>        sw.Write(sr.ReadToEnd());<br>        sw.Flush();<br>        sw.Close();<br>        sr.Close();<br>        fsOut.Close();<br>        if (MessageBox.Show(“解密成功!解密后的文件名及路径为:”+strInName+”，是否册除源文件”, “信息提示”, MessageBoxButtons.YesNo) == DialogResult.Yes)<br>        {<br>            File.Delete(strPath);                                //删除指定文件<br>            textBox1.Text = “”;                                    //清空文本框<br>        }<br>        else<br>        {<br>            textBox1.Text = “”;<br>        }<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟001：StreamWriter类的Flush方法。 在使用StreamWriter类的实例调用Write方法写入数据完毕之后，需要调用该实例的Flush，该方法实现清理当前编写器的所有缓冲区，并使所有缓冲数据写入基础流。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>将一个Word文档分割为多个小的Word文档</title>
    <url>/zh-CN/2019/09/10/e5-b0-86-e4-b8-80-e4-b8-aaword-e6-96-87-e6-a1-a3-e5-88-86-e5-89-b2-e4-b8-ba-e5-a4-9a-e4-b8-aa-e5-b0-8f-e7-9a-84word-e6-96-87-e6-a1-a3-2.html</url>
    <content><![CDATA[<h2 id="将一个Word文档分割为多个小的Word文档"><a href="#将一个Word文档分割为多个小的Word文档" class="headerlink" title="将一个Word文档分割为多个小的Word文档"></a>将一个Word文档分割为多个小的Word文档</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>将一个Word文档分割为多个文档的实现原理非常简单，首先，打开指定的Word文档并检查文档的信息，然后，跟据用户选择分割文档的方式来分割文档的内容，最后，指定的Word文档将会被分割成多个小的Word文档。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1522_Word1.png" alt=""></p>
<p>图1 将一个Word文档分割为多个小的Word文档 实例运行中单击”开始分割”按钮，会根据用户选择的方式分割Word文档，并生成多个Word文档。分割前的Word文档如图2所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1522_Word2.png" alt=""></p>
<p>图2 分割前的Word文档 实例运行中单击”开始分割”按钮，会根据用户选择的方式分割Word文档，并生成多个Word文档。分割后的Word文档如图3、4、5和6所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1522_Word3.png" alt=""></p>
<p>图3 分割后的第一个Word文档</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1522_Word4.png" alt=""></p>
<p>图4 分割后的第二个Word文档</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1522_Word5.png" alt=""></p>
<p>图5 分割后的第3个Word文档</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1522_Word6.png" alt=""></p>
<p>图6 分割后的第4个Word文档</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍怎样使用Range对象的Copy方法和Paste方法轻松的复制和粘贴Word文档中的内容，下面对本实例用到的关键技术进行详细讲解。 Range对象表示Word文档中文档内容的一段范围，要复制Word文档中的内容首先要使用Range对象的Select方法选中将要复制的Range范围，选中范围后就可以使用Range对象的Copy方法将选中范围复制到系统剪切板。现在，文档中指定的内容已经被放入剪切板，在其它Word文档的Range对象中可以调用Paste方法方便的将剪切板的内容粘贴到Word文档中。</p>
<p>提示：由于Range对象的Copy方法是将文档指定内容放入系统剪切板，所以在执行Copy方法后，用户在操作系统中的其它文本编辑器中单击”鼠标右键”并选择”粘贴”，可以将剪切板中的内容手动粘贴到文本编辑器中，但是这样做是不友好的，在用户不知情的情况下在系统剪切板中放入大量内容是不对的，所以在使用Range对象的Copy和Paste方法后不要忘记使用Clipboard.Clear方法清空系统剪切板。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为WordSplit。 （2）使用C#操作Word文档，需要引用相关的COM组件，引用COM组件的步骤请参照实例426中的设计过程。 （3）更改默认窗体Form1中的Name属性为Frm_Main，更改Text属性为”将一个Word文档分割为多个小的Word文档”，向窗体中添加两个TextBox控件，分别用于显示Word文档的打开位置和显示文档的保存位置；向窗体中添加3个Button按钮，3个按钮分别用于打开Word文档、选择文档的保存路径和分割文档。 （4）程序主要代码如下：</p>
<p>private void btn_Get_Click(object sender, EventArgs e)<br>{<br>    btn_split.Enabled = false;                                            //停用分割按钮<br>    ThreadPool.QueueUserWorkItem(                                        //开始线程池<br>    (pp) =&gt;                                                    //使用lambda表达式<br>{<br>        G_wa = new Microsoft.Office.Interop.Word.Application();                    //创建应用程序对象<br>    object P_OpenFileDialog = G_OpenFileDialog.FileName;                    //创建object对象<br>    Word.Document P_Document = G_wa.Documents.Open(                    //打开Word文档<br>    ref P_OpenFileDialog, ref G_missing, ref G_missing, ref G_missing<br>    , ref G_missing, ref G_missing, ref G_missing, ref G_missing<br>    , ref G_missing, ref G_missing, ref G_missing, ref G_missing<br>    , ref G_missing, ref G_missing, ref G_missing, ref G_missing);<br>        bool P_bl = false;                                            //定义布尔变量<br>    this.Invoke(                                                //调用窗体线程<br>    (MethodInvoker)(() =&gt;                                    //使用lambda表达式<br>{<br>        P_bl = cbox_Select.SelectedIndex == 0;<br>    }));<br>        if (P_bl)                                                //判断用什么方式分割文档<br>    {<br>            foreach (Word.Paragraph Paragraph in G_wa.ActiveDocument.Paragraphs)<br>            {<br>                Paragraph.Range.Select();                                //选择段落<br>            Paragraph.Range.Copy();                                //将段落放入剪切板<br>            AddFile();                                        //将剪切板数据放入文档<br>        }<br>        }<br>        else<br>        {<br>            Word.Range P_Range = G_wa.ActiveDocument.Content;                //得到文档区域<br>        int P_int_count = P_Range.Text.Length;                            //得到文档字符总长度<br>        int P_int_i = P_int_count / 100;                                //计算循环建立文档次数<br>        if (P_int_i &gt; 0)                                            //如果文字大于100个<br>        {<br>                for (int i = 0; i &lt; P_int_i; i++)                                //开始循环创建文档<br>            {<br>                    object P_o1 = i == 0 ? 0 : i * 100 + 1;                        //复制文档范围的开始部份<br>                object P_o2 = i * 100 + 101;                            //复制文档范围的结尾部份<br>                Word.Range P_Range_temp =                             //得到文档的范围<br>                G_wa.ActiveDocument.Range(ref P_o1, ref P_o2);<br>                    P_Range.Select();                                    //选中文档范围<br>                P_Range_temp.Copy();                                //将文档范围放入剪切板<br>                AddFile();                                        //将剪切板数据放入文档<br>            }<br>                object P_o11 = P_int_i * 100 + 1;                            //复制文档范围的开始部份<br>            Word.Range P_Range_temp1 =                             //得到文档的范围<br>            G_wa.ActiveDocument.Range(ref P_o11, ref G_missing);<br>                P_Range.Select();                                    //选中文档范围<br>            P_Range_temp1.Copy();                                //将内容放入剪切板<br>            AddFile();                                        //向新建文档中粘贴<br>        }<br>            else<br>            {<br>                Word.Range P_Range2 = G_wa.ActiveDocument.Content;             //得到文档区域<br>            P_Range.Select();                                    //选中文档范围<br>            P_Range2.Copy();                                    //将文档范围放入剪切板<br>            AddFile();                                        //将剪切板数据放入文档<br>        }<br>        }<br>    ((Word._Application)G_wa.Application).Quit(                            //退出应用程序<br>    ref G_missing, ref G_missing, ref G_missing);<br>        this.Invoke(                                                //调用窗体线程<br>    (MethodInvoker)(() =&gt;                                    //使用lambda表达式<br>{<br>        Clipboard.Clear();                                    //清空剪切板<br>    MessageBox.Show(“完成！”, “提示！”);                        //弹出消息对话框<br>    btn_split.Enabled = true;                                //启用分割按钮<br>}));<br>    });<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟009：轻松复制Word文档中的信息！ 如果复制Word文档中的信息，首先得到Word文档中将要复制内容的范围，然后通过Range对象的Select方法选中将要复制的内容，调用Range对象的Copy方法将指定的内容复制到系统剪切板，最后使用Paste方法将剪切板的内容粘贴到指定位置。要注意一点，在使用Range对象的Copy和Paste方法后不要忘记使用Clipboard.Clear方法清空剪切板中的内容。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>将多个Excel文件汇总到一个Excel文件</title>
    <url>/zh-CN/2019/08/08/e5-b0-86-e5-a4-9a-e4-b8-aaexcel-e6-96-87-e4-bb-b6-e6-b1-87-e6-80-bb-e5-88-b0-e4-b8-80-e4-b8-aaexcel-e6-96-87-e4-bb-b6.html</url>
    <content><![CDATA[<h2 id="将多个Excel文件汇总到一个Excel文件"><a href="#将多个Excel文件汇总到一个Excel文件" class="headerlink" title="将多个Excel文件汇总到一个Excel文件"></a>将多个Excel文件汇总到一个Excel文件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用C#代码实现了将多个Excel文件汇总到一个Excel文件的功能。运行本实例，如图1所示，单击第一个“选择”按钮，选择要汇总的多个Excel文件；单击第二个“选择”按钮，选择存放汇总数据的Excel文件；然后单击“汇总”按钮，将多个Excel文件汇总到一个Excel文件中；单击“查看”按钮，查看汇总数据之后的Excel文件。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-08-08210256.png" alt=""> 图1 将多个Excel文件汇总到一个Excel文件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现将多个Excel文件的内容汇总到一个Excel文件时，主要用到了Microsoft Excel自动化对象模型的Worksheet对象的Copy方法，下面对其进行详细讲解。 Worksheet对象的Copy方法用来将工作表内容复制到工作簿中的另一个位置，也可以将工作表内容复制到其他的工作表中，其语法格式如下： public virtual void Copy(Object Before,Object After) 参数说明 Before：复制工作表的放置位置之后的工作表。如果指定After，则不能指定Before。 After：复制工作表的放置位置之前的工作表。如果指定Before，则不能指定After。 说明：如果Copy方法中既未指定Before，也未指定After，则Excel将创建一个包含复制工作表的新工作簿。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为MultiExcelToOneExcel。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个TextBox控件，分别用来显示选择的多个Excel文件路径和单个Excel文件路径；添加4个Button控件，分别用来执行选择多个Excel文件、选择单个Excel文件、将多个Excel文件汇总到一个Excel文件和查看汇总的Excel文件的操作。 （3）程序主要代码如下：</p>
<p>private void btn_Gather_Click(object sender, EventArgs e)<br>{<br>    object missing = System.Reflection.Missing.Value;                    //定义object缺省值<br>    string[] P_str_Names = txt_MultiExcel.Text.Split(‘,’);                    //存储所有选择的Excel文件名<br>    string P_str_Name = “”;                                    //存储遍历到的Excel文件名<br>List<string> P_list_SheetNames = new List<string>();                    //创建泛型集合对象，用来存储工作表名称<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.Application();<br>    //打开指定的Excel文件<br>Microsoft.Office.Interop.Excel.Workbook workbook = excel.Application.Workbooks.Open(txt_Excel.Text, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>//创建新工作表<br>    Microsoft.Office.Interop.Excel.Worksheet newWorksheet = (Microsoft.Office.Interop.Excel.Worksheet)workbook.Worksheets.Add(missing, missing, missing, missing);<br>    for (int i = 0; i &lt; P_str_Names.Length - 1; i++)                            //遍历所有选择的Excel文件名<br>    {<br>        P_str_Name = P_str_Names[i];                                    //记录遍历到的Excel文件名<br>        //指定要复制的工作簿<br>        Microsoft.Office.Interop.Excel.Workbook Tempworkbook = excel.Application.Workbooks.Open(P_str_Name, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>        P_list_SheetNames = GetSheetName(P_str_Name);                        //获取Excel文件中的所有工作表名<br>        for (int j = 0; j &lt; P_list_SheetNames.Count; j++)                        //遍历所有工作表<br>        {<br>            //指定要复制的工作表<br>            Microsoft.Office.Interop.Excel.Worksheet TempWorksheet = (Microsoft.Office.Interop.Excel.Worksheet)Tempworkbook.Sheets[P_list_SheetNames[j]];    //创建新工作表<br>            TempWorksheet.Copy(missing, newWorksheet);                    //将工作表内容复制到目标工作表中<br>        }<br>        Tempworkbook.Close(false, missing, missing);                        //关闭临时工作簿<br>    }<br>    workbook.Save();                                            //保存目标工作簿<br>    workbook.Close(false, missing, missing);                                //关闭目标工作簿<br>    MessageBox.Show(“已经将所有选择的Excel工作表汇总到了一个Excel工作表中！”, “提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>    CloseProcess(“EXCEL”);                                        //关闭所有Excel进程<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟052：在Excel文件中新增工作表。 在Excel文件中新增工作表时，可以使用Excel自动化对象模型的Worksheets对象的Add方法来实现，该方法主要用来为指定的工作簿添加工作表。例如，本实例中创建新工作表的实现代码如下： Microsoft.Office.Interop.Excel.Worksheet newWorksheet = (Microsoft.Office.Interop.Excel.Worksheet)workbook.Worksheets.Add(missing, missing, missing, missing);</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>将一个Word文档分割为多个小的Word文档</title>
    <url>/zh-CN/2019/09/10/e5-b0-86-e4-b8-80-e4-b8-aaword-e6-96-87-e6-a1-a3-e5-88-86-e5-89-b2-e4-b8-ba-e5-a4-9a-e4-b8-aa-e5-b0-8f-e7-9a-84word-e6-96-87-e6-a1-a3.html</url>
    <content><![CDATA[<h2 id="将一个Word文档分割为多个小的Word文档"><a href="#将一个Word文档分割为多个小的Word文档" class="headerlink" title="将一个Word文档分割为多个小的Word文档"></a>将一个Word文档分割为多个小的Word文档</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>将一个Word文档分割为多个文档的实现原理非常简单，首先，打开指定的Word文档并检查文档的信息，然后，跟据用户选择分割文档的方式来分割文档的内容，最后，指定的Word文档将会被分割成多个小的Word文档。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_0638_Word1.png" alt=""></p>
<p>图1 将一个Word文档分割为多个小的Word文档 实例运行中单击”开始分割”按钮，会根据用户选择的方式分割Word文档，并生成多个Word文档。分割前的Word文档如图2所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_0638_Word2.png" alt=""></p>
<p>图2 分割前的Word文档 实例运行中单击”开始分割”按钮，会根据用户选择的方式分割Word文档，并生成多个Word文档。分割后的Word文档如图3、4、5和6所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_0638_Word3.png" alt=""></p>
<p>图3 分割后的第一个Word文档</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_0638_Word4.png" alt=""></p>
<p>图4 分割后的第二个Word文档</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_0638_Word5.png" alt=""></p>
<p>图5 分割后的第3个Word文档</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_0638_Word6.png" alt=""></p>
<p>图6 分割后的第4个Word文档</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍怎样使用Range对象的Copy方法和Paste方法轻松的复制和粘贴Word文档中的内容，下面对本实例用到的关键技术进行详细讲解。 Range对象表示Word文档中文档内容的一段范围，要复制Word文档中的内容首先要使用Range对象的Select方法选中将要复制的Range范围，选中范围后就可以使用Range对象的Copy方法将选中范围复制到系统剪切板。现在，文档中指定的内容已经被放入剪切板，在其它Word文档的Range对象中可以调用Paste方法方便的将剪切板的内容粘贴到Word文档中。</p>
<p>提示：由于Range对象的Copy方法是将文档指定内容放入系统剪切板，所以在执行Copy方法后，用户在操作系统中的其它文本编辑器中单击”鼠标右键”并选择”粘贴”，可以将剪切板中的内容手动粘贴到文本编辑器中，但是这样做是不友好的，在用户不知情的情况下在系统剪切板中放入大量内容是不对的，所以在使用Range对象的Copy和Paste方法后不要忘记使用Clipboard.Clear方法清空系统剪切板。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为WordSplit。 （2）使用C#操作Word文档，需要引用相关的COM组件，引用COM组件的步骤请参照实例426中的设计过程。 （3）更改默认窗体Form1中的Name属性为Frm_Main，更改Text属性为”将一个Word文档分割为多个小的Word文档”，向窗体中添加两个TextBox控件，分别用于显示Word文档的打开位置和显示文档的保存位置；向窗体中添加3个Button按钮，3个按钮分别用于打开Word文档、选择文档的保存路径和分割文档。 （4）程序主要代码如下：</p>
<p>private void btn_Get_Click(object sender, EventArgs e)<br>{<br>    btn_split.Enabled = false;                                            //停用分割按钮<br>    ThreadPool.QueueUserWorkItem(                                        //开始线程池<br>        (pp) =&gt;                                                    //使用lambda表达式<br>        {<br>            G_wa = new Microsoft.Office.Interop.Word.Application();                    //创建应用程序对象<br>            object P_OpenFileDialog = G_OpenFileDialog.FileName;                    //创建object对象<br>            Word.Document P_Document = G_wa.Documents.Open(                    //打开Word文档<br>                ref P_OpenFileDialog, ref G_missing, ref G_missing, ref G_missing<br>                , ref G_missing, ref G_missing, ref G_missing, ref G_missing<br>                , ref G_missing, ref G_missing, ref G_missing, ref G_missing<br>                , ref G_missing, ref G_missing, ref G_missing, ref G_missing);<br>            bool P_bl = false;                                            //定义布尔变量<br>            this.Invoke(                                                //调用窗体线程<br>                 (MethodInvoker)(() =&gt;                                    //使用lambda表达式<br>                    {<br>                        P_bl = cbox_Select.SelectedIndex == 0;<br>                    }));<br>            if (P_bl)                                                //判断用什么方式分割文档<br>            {<br>                foreach (Word.Paragraph Paragraph in G_wa.ActiveDocument.Paragraphs)<br>                {<br>                    Paragraph.Range.Select();                                //选择段落<br>                    Paragraph.Range.Copy();                                //将段落放入剪切板<br>                    AddFile();                                        //将剪切板数据放入文档<br>                }<br>            }<br>            else<br>            {<br>                Word.Range P_Range = G_wa.ActiveDocument.Content;                //得到文档区域<br>                int P_int_count = P_Range.Text.Length;                            //得到文档字符总长度<br>                int P_int_i = P_int_count / 100;                                //计算循环建立文档次数<br>                if (P_int_i &gt; 0)                                            //如果文字大于100个<br>                {<br>                    for (int i = 0; i &lt; P_int_i; i++)                                //开始循环创建文档<br>                    {<br>                        object P_o1 = i == 0 ? 0 : i * 100 + 1;                        //复制文档范围的开始部份<br>                        object P_o2 = i * 100 + 101;                            //复制文档范围的结尾部份<br>                        Word.Range P_Range_temp =                             //得到文档的范围<br>                            G_wa.ActiveDocument.Range(ref P_o1, ref P_o2);<br>                        P_Range.Select();                                    //选中文档范围<br>                        P_Range_temp.Copy();                                //将文档范围放入剪切板<br>                        AddFile();                                        //将剪切板数据放入文档<br>                    }<br>                    object P_o11 = P_int_i * 100 + 1;                            //复制文档范围的开始部份<br>                    Word.Range P_Range_temp1 =                             //得到文档的范围<br>                        G_wa.ActiveDocument.Range(ref P_o11, ref G_missing);<br>                    P_Range.Select();                                    //选中文档范围<br>                    P_Range_temp1.Copy();                                //将内容放入剪切板<br>                    AddFile();                                        //向新建文档中粘贴<br>                }<br>                else<br>                {<br>                    Word.Range P_Range2 = G_wa.ActiveDocument.Content;             //得到文档区域<br>                    P_Range.Select();                                    //选中文档范围<br>                    P_Range2.Copy();                                    //将文档范围放入剪切板<br>                    AddFile();                                        //将剪切板数据放入文档<br>                }<br>            }<br>            ((Word._Application)G_wa.Application).Quit(                            //退出应用程序<br>                ref G_missing, ref G_missing, ref G_missing);<br>            this.Invoke(                                                //调用窗体线程<br>                (MethodInvoker)(() =&gt;                                    //使用lambda表达式<br>                {<br>                    Clipboard.Clear();                                    //清空剪切板<br>                    MessageBox.Show(“完成！”, “提示！”);                        //弹出消息对话框<br>                    btn_split.Enabled = true;                                //启用分割按钮<br>                }));<br>        });<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟009：轻松复制Word文档中的信息！ 如果复制Word文档中的信息，首先得到Word文档中将要复制内容的范围，然后通过Range对象的Select方法选中将要复制的内容，调用Range对象的Copy方法将指定的内容复制到系统剪切板，最后使用Paste方法将剪切板的内容粘贴到指定位置。要注意一点，在使用Range对象的Copy和Paste方法后不要忘记使用Clipboard.Clear方法清空剪切板中的内容。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>将多个Excel文件输出到同一Sql Server数据库</title>
    <url>/zh-CN/2019/08/14/e5-b0-86-e5-a4-9a-e4-b8-aaexcel-e6-96-87-e4-bb-b6-e8-be-93-e5-87-ba-e5-88-b0-e5-90-8c-e4-b8-80sql-server-e6-95-b0-e6-8d-ae-e5-ba-93.html</url>
    <content><![CDATA[<h2 id="将多个Excel文件输出到同一Sql-Server数据库"><a href="#将多个Excel文件输出到同一Sql-Server数据库" class="headerlink" title="将多个Excel文件输出到同一Sql Server数据库"></a>将多个Excel文件输出到同一Sql Server数据库</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用C#代码实现了将多个Excel文件中的数据输出到同一Sql Server数据库中的功能。运行本实例，如图1所示，单击“选择”按钮，选择要读取的多个Excel文件；然后在“Sql Server数据库连接设置”区域对数据库连接信息进行设置；最后单击“导出”按钮，将多个Excel中的数据输出到同一Sql Server数据库中。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-14-1009175.png" alt=""> 图1 将多个Excel文件输出到同一Sql Server数据库</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在将多个Excel文件中的数据输出到同一Sql Server数据表时，主要用到了SqlBulkCopy类的WriteToServer方法，下面对其进行详细讲解。 SqlBulkCopy类使用户可以用其他源的数据有效批量加载到SQL Server数据表中，其WriteToServer方法用来将所有行从数据源复制到SqlBulkCopy对象的DestinationTableName属性（该属性用来指定服务器上目标表的名称）指定的目标表中，该方法有4种重载形式，本实例中用到的该方法的重载形式语法如下： public void WriteToServer(DataTable table) 参数说明 table：一个DataTable对象，它的行将被复制到目标表中。 说明：（1）Microsoft SQL Server提供了一个称为bcp的流行的命令提示符实用工具，用于将数据从一个表移动到另一个表（表既可以在同一个服务器上，也可以在不同服务器上）。SqlBulkCopy类允许编写提供类似功能的托管代码解决方案； （2）使用SqlBulkCopy类只能向SQL Server表写入数据，但是，数据源不限于SQL Server；可以使用任何数据源，只要数据可以加载到DataTable实例或者可以使用IDataReader对象读取数据。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为MultiExcelToSql。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加4个TextBox控件，分别用来显示选择的多个Excel文件路径、输入Sql Server服务器名、登录用户名和登录密码；添加两个CheckBox控件，用来选择Sql Server数据库的登录方式；添加一个ComboBox控件，用来选择要导入到的Sql Server数据库；添加3个Button控件，分别用来执行选择多个Excel文件、获取指定Sql Server服务器上的所有数据库和将多个Excel文件内容导入到同一Sql Server数据库的操作。 （3）程序主要代码如下： 选择完多个Excel文件，并对Sql Server服务器进行设置后，单击“导出”按钮，调用自定义的ImportDataToSql方法循环将多个Excel文件中的内容导出到同一个Sql Server数据库中。“导出”按钮的Click事件代码如下：</p>
<p>private void btn_Export_Click(object sender, EventArgs e)<br>{<br>    string[] P_str_Names = txt_Path.Text.Split(‘,’);                //存储所有选择的Excel文件名<br>    string P_str_Name = “”;                            //存储遍历到的Excel文件名<br>    List<string> P_list_SheetNames = new List<string>();            //创建泛型集合对象，用来存储工作表名称<br>    for (int i = 0; i &lt; P_str_Names.Length - 1; i++)                //遍历所有选择的Excel文件名<br>    {<br>        P_str_Name = P_str_Names[i];                        //记录遍历到的Excel文件名<br>        P_list_SheetNames = GetSheetName(P_str_Name);            //获取Excel文件中的所有工作表名<br>        for (int j = 0; j &lt; P_list_SheetNames.Count; j++)            //遍历所有工作表<br>        {<br>            if (ckbox_Windows.Checked)                    //如果用Windows身份验证登录Sql Server<br>                ImportDataToSql(P_str_Name, P_list_SheetNames[j], “Data Source=” + txt_Server.Text + “;Initial Catalog =” + cbox_Server.Text + “;Integrated Security=SSPI;”);        //将工作表内容导出到Sql Server<br>            else if (ckbox_SQL.Checked)                    //如果用Sql Server身份验证登录Sql Server<br>//将工作表内容导出到Sql Server<br>                ImportDataToSql(P_str_Name, P_list_SheetNames[j], “Data Source=” + txt_Server.Text + “;Database=” + cbox_Server.Text + “;Uid=” + txt_Name.Text + “;Pwd=” + txt_Pwd.Text + “;”);<br>        }<br>    }<br>    MessageBox.Show(“已经将所有选择的Excel工作表导入到了Sql Server数据库中！”, “提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>}</p>
<p>上面的代码中用到了ImportDataToSql方法，该方法主要用来将Excel中指定工作表的内容导出到Sql Server数据库中。该方法中主要使用SqlBulkCopy对象WriteToServer方法对Sql Server数据库进行数据写入操作。ImportDataToSql方法实现代码如下：</p>
<p>public void ImportDataToSql(string P_str_Excel, string P_str_SheetName, string P_str_SqlCon)<br>{<br>    DataSet myds = new DataSet();                                //创建数据集对象<br>    try<br>{<br>//获得全部数据<br>        string P_str_OledbCon = “Provider=Microsoft.Jet.OLEDB.4.0;Data Source=” + P_str_Excel + “;Extended Properties=Excel 8.0;”;<br>        OleDbConnection oledbcon = new OleDbConnection(P_str_OledbCon);        //创建Oledb数据库连接对象<br>        string P_str_ExcelSql = “”;                                //记录要执行的Excel查询语句<br>        OleDbDataAdapter oledbda = null;                            //创建Oledb数据桥接器对象<br>        P_str_ExcelSql = string.Format(“select * from [{0}$]“, P_str_SheetName);    //记录要执行的Excel查询语句<br>        oledbda = new OleDbDataAdapter(P_str_ExcelSql, P_str_OledbCon);        //使用数据桥接器执行Excel查询<br>        oledbda.Fill(myds, P_str_SheetName);                            //填充数据<br>//定义变量，用来记录创建表的SQL语句<br>        string P_str_CreateSql = string.Format(“create table {0}(“, P_str_SheetName);<br>        foreach (DataColumn c in myds.Tables[0].Columns)                    //遍历数据集中的所有行<br>        {<br>            P_str_CreateSql += string.Format(“[{0}] text,”, c.ColumnName);        //在表中创建字段<br>        }<br>        P_str_CreateSql = P_str_CreateSql + “)”;                        //完善创建表的SQL语句<br>        using (SqlConnection sqlcon = new SqlConnection(P_str_SqlCon))        //创建SQL数据库连接对象<br>        {<br>            sqlcon.Open();                                    //打开数据库连接<br>            SqlCommand sqlcmd = sqlcon.CreateCommand();                //创建执行命令对象<br>            sqlcmd.CommandText = P_str_CreateSql;                    //指定要执行的SQL语句<br>            sqlcmd.ExecuteNonQuery();                            //执行操作<br>            sqlcon.Close();                                    //关闭数据连接<br>        }<br>        using (SqlBulkCopy bcp = new SqlBulkCopy(P_str_SqlCon))            //用bcp导入数据<br>        {<br>            bcp.BatchSize = 100;                                //每次传输的行数<br>            bcp.DestinationTableName = P_str_SheetName;                //定义目标表<br>            bcp.WriteToServer(myds.Tables[0]);                        //将数据写入Sql Server数据表<br>        }<br>    }<br>    catch<br>    {<br>        MessageBox.Show(“Sql Server数据库中已经存在” + P_str_SheetName + “表！”, “警告”, MessageBoxButtons.OK, MessageBoxIcon.Warning);<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟043：程序中尽量不要使用太多嵌套for语句！ 由于嵌套for语句将消耗很大的资源，所以在实际开发项目时，能不使用嵌套for语句尽量不要使用。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>将多个Excel文件进行自动汇总</title>
    <url>/zh-CN/2019/08/06/e5-b0-86-e5-a4-9a-e4-b8-aaexcel-e6-96-87-e4-bb-b6-e8-bf-9b-e8-a1-8c-e8-87-aa-e5-8a-a8-e6-b1-87-e6-80-bb.html</url>
    <content><![CDATA[<h2 id="将多个Excel文件进行自动汇总"><a href="#将多个Excel文件进行自动汇总" class="headerlink" title="将多个Excel文件进行自动汇总"></a>将多个Excel文件进行自动汇总</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用C#代码实现了将多个Excel文件进行自动汇总的功能。运行本实例，如图1所示，单击第一个“选择”按钮，选择要汇总的多个Excel文件；单击第二个“选择”按钮，选择存放汇总数据的Excel文件；然后在“自动汇总设置”区域设置自动汇总时间，单击“设置”按钮，启动Timer计时器，在Timer计时器中实时判断当前时间是否与设置的自动汇总时间相同，如果相同，则自动将多个Excel文件汇总到一个Excel文件中；单击“查看”按钮，查看汇总数据之后的Excel文件。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-06-04410383.png" alt=""> 图1 将多个Excel文件进行自动汇总</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例主要实现自动将多个Excel文件数据汇总到一个Excel文件中，实现该功能时，首先需要把用户的设置写入到INI文件中，当程序启动时，在Timer计时器中判断系统当前时间是否与用户设置的时间相同，如果相同，则调用Microsoft Excel自动化对象模型的Worksheet对象的Copy方法自动将多个Excel文件的数据汇总到一个Excel文件中。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为AutoMultiExcelToOneExcel。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个TextBox控件，分别用来显示选择的多个Excel文件路径和单个Excel文件路径；添加两个NumericUpDown控件，分别用来设置小时和分钟；添加4个Button控件，分别用来执行选择多个Excel文件、选择单个Excel文件、将定时设置写入到系统配置文件中和查看汇总的Excel文件的操作；添加一个Timer组件，用来实时检测当前时间是否与设置的时间相同，如果相同，则自动将多个Excel文件的内容汇总到一个Excel中。 （3）程序主要代码如下： 单击“设置”按钮，把用户设置的信息写入到系统INI文件中，并启动计时器。“设置”按钮的Click事件代码如下：</p>
<p>private void btn_Set_Click(object sender, EventArgs e)<br>{<br>    WritePrivateProfileString(“Set”, “MultiExcel”, txt_MultiExcel.Text, M_str_Name);        //设置多个Excel文件路径<br>    WritePrivateProfileString(“Set”, “Excel”, txt_Excel.Text, M_str_Name);            //设置目标Excel文件路径<br>    WritePrivateProfileString(“Set”, “Hour”, nudown_Hour.Value.ToString(), M_str_Name);    //设置小时<br>    WritePrivateProfileString(“Set”, “Min”, nudown_Min.Value.ToString(), M_str_Name);    //设置分钟<br>    MessageBox.Show(“配置文件设置成功！”, “提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>    timer1.Start();                                                //启动计时器<br>}</p>
<p>说明：上面的代码中用到了WritePrivateProfileString函数，该函数主要用来对INI文件进行写入和修改操作，关于该函数的详细代码请参见实例“每天定时将各地上报结果处理到Excel”中的设计过程。 在timer1组件的Tick事件中，首先判断当前时间是否与设置的时间相同，如果相同，则自动将多个Excel文件的数据汇总到一个Excel文件中。代码如下：</p>
<p>private void timer1_Tick(object sender, EventArgs e)<br>{<br>    object missing = System.Reflection.Missing.Value;                        //定义object缺省值<br>    string[] P_str_Names = txt_MultiExcel.Text.Split(‘,’);                        //存储所有选择的Excel文件名<br>    string P_str_Name = “”;                                        //存储遍历到的Excel文件名<br>List<string> P_list_SheetNames = new List<string>();                        //创建泛型集合对象，用来存储工作表名称<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.Application();<br>    //打开指定的Excel文件<br>Microsoft.Office.Interop.Excel.Workbook workbook = excel.Application.Workbooks.Open(txt_Excel.Text, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>//创建新工作表<br>    Microsoft.Office.Interop.Excel.Worksheet newWorksheet = (Microsoft.Office.Interop.Excel.Worksheet)workbook.Worksheets.Add(missing, missing, missing, missing);<br>    if (DateTime.Now.Hour == nudown_Hour.Value &amp;&amp; DateTime.Now.Minute == nudown_Min.Value)<br>    {<br>        for (int i = 0; i &lt; P_str_Names.Length - 1; i++)                        //遍历所有选择的Excel文件名<br>        {<br>            P_str_Name = P_str_Names[i];                                //记录遍历到的Excel文件名<br>            Microsoft.Office.Interop.Excel.Workbook Tempworkbook = excel.Application.Workbooks.Open(P_str_Name, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);//指定要复制的工作簿<br>            P_list_SheetNames = GetSheetName(P_str_Name);                    //获取Excel文件中的所有工作表名<br>            for (int j = 0; j &lt; P_list_SheetNames.Count; j++)                    //遍历所有工作表<br>            {<br>                //指定要复制的工作表<br>                Microsoft.Office.Interop.Excel.Worksheet TempWorksheet = (Microsoft.Office.Interop.Excel.Worksheet)Tempworkbook.Sheets[P_list_SheetNames[j]];    //创建新工作表<br>                TempWorksheet.Copy(missing, newWorksheet);                    //将工作表内容复制到目标工作表中<br>            }<br>            Tempworkbook.Close(false, missing, missing);                        //关闭临时工作簿<br>        }<br>    }<br>    workbook.Save();                                            //保存目标工作簿<br>    workbook.Close(false, missing, missing);                                //关闭目标工作簿<br>    MessageBox.Show(“程序在” + DateTime.Now.ToShortTimeString() + “分时自动汇总了多个Excel文件！”, “提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>    CloseProcess(“EXCEL”);                                        //关闭所有Excel进程<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟053：使用文件流对INI文件进行读写。 本实例使用系统API函数实现了对INI文件进行读写的功能，但是开发人员还可以使用文件流来对INI文件进行读写，其中主要用到StreamReader类和StreamWrite类。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>将多个Word文档合并为一个Word文档</title>
    <url>/zh-CN/2019/09/10/e5-b0-86-e5-a4-9a-e4-b8-aaword-e6-96-87-e6-a1-a3-e5-90-88-e5-b9-b6-e4-b8-ba-e4-b8-80-e4-b8-aaword-e6-96-87-e6-a1-a3.html</url>
    <content><![CDATA[<h2 id="将多个Word文档合并为一个Word文档"><a href="#将多个Word文档合并为一个Word文档" class="headerlink" title="将多个Word文档合并为一个Word文档"></a>将多个Word文档合并为一个Word文档</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>将多个Word文档合并为一个Word文档，首先需要用户手动添加多个Word文档的集合，然后依次打开每一个Word文档，将每一个Word文档的全部内容复制到剪切板并粘贴到新建的Word文档中。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_0633_WordW1.png" alt=""></p>
<p>图1 将多个Word文档合并为一个Word文档 实例运行中单击”选择”按钮，会将用户所选择Word文档的路径放入文件列表中，后期可以遍历文件列表将多个Word文档合并到一个Word文档中，合并前的多个Word文档如图2、3、4和5所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_0633_WordW2.png" alt=""></p>
<p>图2 合并前的第一个Word文档</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_0633_WordW3.png" alt=""></p>
<p>图3 合并前的第二个Word文档</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_0633_WordW4.png" alt=""></p>
<p>图4 合并前的第3个Word文档</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_0633_WordW5.png" alt=""></p>
<p>图5 合并前的第4个Word文档 实例运行中单击”开始合并”按钮，会将用户选择的多个Word文档合并为一个Word文档，合并后的Word文档如图6所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_0633_WordW6.png" alt=""></p>
<p>图6 合并后的Word文档</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍怎样将多个Word文档的内容合并为一个Word文档以及使用Documents对象的Open方法打开指定Word文档，下面对本实例用到的关键技术进行详细讲解。</p>
<p>说明：实例中用到了Range对象的Copy方法和Paste方法分别复制和粘贴Word文档中的内容。</p>
<p>（1）合并Word文档 将多个Word文档的内容合并为一个Word文档的实现方法很简单，首先创建并打开一个新的Word文档用于存放多个文档的内容，然后根据用户指定的Word文档路径的集合依次打开每一个Word文档，并将Word文档中的所有内容粘贴到新建Word文档中。 （2）Documents对象的Open方法 使用Documents对象的Open方法可以方便的打开Word文档，Open方法的语法格式如下：</p>
<p>Document Open(ref object FileName, ref object ConfirmConversions, ref object ReadOnly, ref object AddToRecentFiles, ref object PasswordDocument, ref object PasswordTemplate, ref object Revert, ref object WritePasswordDocument, ref object WritePasswordTemplate, ref object Format, ref object Encoding, ref object Visible, ref object OpenAndRepair, ref object DocumentDirection, ref object NoEncodingDialog, ref object XMLTransform);</p>
<p>Open方法中的参数说明如表1所示。 表1 Open方法中的参数说明</p>
<p>参数</p>
<p>描述</p>
<p>FileName</p>
<p>将要打开的Word文档名称及路径</p>
<p>ConfirmConversions</p>
<p>如果Open方法中FileName参数指定的不是Word格式文件，则需要将该参数设置为true，表示显示文件转换对话框</p>
<p>ReadOnly</p>
<p>是否以只读方式打开文档，默认值为false</p>
<p>AddToRecentFiles</p>
<p>是否将文件名称添加到文件菜单中的最近使用文件列表中，默认为true</p>
<p>PasswordDocument</p>
<p>如果文档有密码保护，可以使用此参数传递密码的字符串值，用于打开文档</p>
<p>PasswordTemplate</p>
<p>如果模板有密码保护，可以使用此参数传递密码的字符串值，用于打开模板</p>
<p>Revert</p>
<p>使用Open方法打开已经被打开的文档，如果此参数为true时，则放弃已打开文档中尚未保存的修改。如果此参数为false，则激活已打开文档</p>
<p>WritePasswordDocument</p>
<p>如果文档有密码保护，可以使用此参数传递密码的字符串值，用于保存文档</p>
<p>WritePasswordTemplate</p>
<p>如果模板有密码保护，可以使用此参数传递密码的字符串值，用于保存模板</p>
<p>Format</p>
<p>WdOpenFormat枚举类型参数，用于在打开文档时指定所使用的文件转换器</p>
<p>Encoding</p>
<p>Office.MsoEncoding枚举类型参数，用于指定打开文档时所使用的代码页或字符集</p>
<p>Visible</p>
<p>是否在可见窗口中打开文档，如果为true，则在可见窗口中打开，默认为true</p>
<p>OpenAndRepair</p>
<p>是否尝试修复损坏文档，true为修复</p>
<p>DocumentDirection</p>
<p>WdDocumentDirection枚举类型参数，用于指定已打开文档中文本的水平流动方式</p>
<p>NoEncodingDialog</p>
<p>如果为true，表示在不能确定文档编码方式时，阻止显示编码对话框</p>
<p>XMLTransform</p>
<p>XML转换格式</p>
<p>注意：Documents的Add方法中只有第一个参数FileName是必选的，其它参数都是可选参数。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为WordMerge。 （2）使用C#操作Word文档，需要引用相关的COM组件，引用COM组件的步骤请参照实例426中的设计过程。 （3）更改默认窗体Form1中的Name属性为Frm_Main，更改Text属性为”将多个Word文档合并为一个Word文档”，向窗体中添加一个ListBox控件，此控件用于显示将要合并的Word文档的集合；向窗体中添加3个Button按钮，分别用于添加将要合并的Word文档、选择合并文档的保存位置和开始合并Word文档。 （4）程序主要代码如下：</p>
<p>private void btn_split_Click(object sender, EventArgs e)<br>{<br>    btn_Merge.Enabled = false;                                                //启用合并按钮<br>    ThreadPool.QueueUserWorkItem(                                            //开始线程池<br>        (pp) =&gt;                                                        //使用lambda表达式<br>        {<br>            G_wa = new Microsoft.Office.Interop.Word.Application();                        //创建应用程序对象<br>            Word.Document P_MainDocument =                                    //新建合并文档对象<br>                G_wa.Documents.Add(ref G_missing, ref G_missing<br>                , ref G_missing, ref G_missing);<br>            foreach (string P_Str in G_Str_Files)                                    //遍历文档的集合<br>            {<br>                object P_strs = P_Str;                                            //创建object对象<br>                Word.Document P_Document = G_wa.Documents.Open(                    //打开Word文档<br>                    ref P_strs, ref G_missing, ref G_missing, ref G_missing<br>                    , ref G_missing, ref G_missing, ref G_missing, ref G_missing<br>                    , ref G_missing, ref G_missing, ref G_missing, ref G_missing<br>                    , ref G_missing, ref G_missing, ref G_missing, ref G_missing);<br>                Word.Range P_Range_temp =                                     //得到文档全部范围<br>                    P_Document.Range(ref G_missing, ref G_missing);<br>                P_Range_temp.Select();                                        //选择文档全部范围<br>                P_Range_temp.Copy();                                        //复制文档全部范围<br>                Word.Range P_Range_temp2 =                                    //得到文档的范围<br>                    P_MainDocument.Range(ref G_missing, ref G_missing);<br>                object P_end= Word.WdCollapseDirection.wdCollapseEnd;                    //创建object对象<br>                P_Range_temp2.Collapse(ref P_end);                                //折叠文档范围<br>                P_Range_temp2.Select();                                        //选择档的最后位置<br>                P_Range_temp2.Paste();                                        //粘贴文档内容<br>                ((Word._Document)P_Document).Close(ref G_missing, ref G_missing,            //关闭文档<br>                    ref G_missing);<br>            }<br>            object P_SavePath=G_SaveFileDialog.FileName;                            //创建object对象<br>            P_MainDocument.SaveAs(                                        //保存合并后的文档<br>                ref P_SavePath, ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                ref G_missing, ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                ref G_missing, ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                ref G_missing);<br>            ((Word._Application)G_wa.Application).Quit(                                //退出应用程序<br>                ref G_missing, ref G_missing, ref G_missing);<br>            this.Invoke(                                                    //调用窗体线程<br>                (MethodInvoker)(() =&gt;                                        //使用lambda表达式<br>                {<br>                    Clipboard.Clear();                                        //清空剪切板<br>                    MessageBox.Show(“成功合并Word文档！”, “提示！”);                    //弹出消息对话框<br>                    btn_Merge.Enabled = true;                                    //停用合并按钮<br>                }));<br>        });<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟010：以只读方式打开Word文档！ 本实例已经介绍了怎样使用Documents对象的Open方法方便的打开Word文档，如果想使用只读的方式打开Word文档，可以设置Open方法的第三个参数为true使文档以只读方式打开。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>将数据利用Excel生成图表</title>
    <url>/zh-CN/2019/08/08/e5-b0-86-e6-95-b0-e6-8d-ae-e5-88-a9-e7-94-a8excel-e7-94-9f-e6-88-90-e5-9b-be-e8-a1-a8.html</url>
    <content><![CDATA[<h2 id="将数据利用Excel生成图表"><a href="#将数据利用Excel生成图表" class="headerlink" title="将数据利用Excel生成图表"></a>将数据利用Excel生成图表</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用C#代码实现了在Excel中生成图表的功能。运行本实例，首先单击工具栏中的“打开Excel文件”按钮，打开指定的Excel文件，并且选择要操作的工作表；然后单击“生成图表”按钮，即可在指定的工作表中生成一个柱形图，如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-08-13473350.png" alt=""> 图1 将数据利用Excel生成图表</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现在Excel中生成图表时，主要用到了Microsoft Excel自动化对象模型的Chart对象的ChartWizard方法，下面对其进行详细讲解。 Chart对象是公开事件的图表对象，它可以绑定到数据，其ChartWizard方法用来修改给定Chart控件的属性，以便绘制一个新的图表，该方法语法格式如下：</p>
<p>public void ChartWizard(Object Source,Object Gallery,Object Format,Object PlotBy,Object CategoryLabels,Object SeriesLabels,Object HasLegend,Object Title,Object CategoryTitle,Object ValueTitle,Object ExtraTitle)</p>
<p>ChartWizard方法语法中的参数说明如表1所示。 表1 ChartWizard方法语法中的参数说明</p>
<p>参数</p>
<p>描述</p>
<p>Source</p>
<p>包含新图表的源数据的范围</p>
<p>Gallery</p>
<p>图表类型</p>
<p>Format</p>
<p>内置自动套用格式的选项编号</p>
<p>PlotBy</p>
<p>指定每个系列的数据是按行绘制还是按列绘制</p>
<p>CategoryLabels</p>
<p>指定源范围中包含类别标签的行数或列数</p>
<p>SeriesLabels</p>
<p>指定源范围中包含系列标签的行数或列数</p>
<p>HasLegend</p>
<p>指定是否包含图例</p>
<p>Title</p>
<p>指定标题文本</p>
<p>CategoryTitle</p>
<p>分类轴标题文本</p>
<p>ValueTitle</p>
<p>数值轴标题文本</p>
<p>ExtraTitle</p>
<p>三维图表的系列轴标题或二维图表的第二个数值轴标题</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为ExcelChart。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个ToolStrip控件，用来作为程序的工具栏，该工具栏用来选择Excel文件及其工作表，并执行生成图表操作；添加一个WebBrowser控件，用来显示Excel文件及生成的图表。 （3）程序主要代码如下：</p>
<p>private void tsbtn_Build_Click(object sender, EventArgs e)<br>{<br>    CloseProcess(“EXCEL”);                                            //关闭所有Excel进程<br>object missing = System.Reflection.Missing.Value;                            //定义object缺省值<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.Application();<br>    //打开Excel文件<br>    Microsoft.Office.Interop.Excel.Workbook workbook = excel.Workbooks.Open(tstxt_Excel.Text, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>Microsoft.Office.Interop.Excel.Worksheet worksheet;                                //声明工作表<br>//获取选择的工作表<br>    worksheet = ((Microsoft.Office.Interop.Excel.Worksheet)workbook.Worksheets[tscbox_Sheet.Text]);<br>    Microsoft.Office.Interop.Excel.Range searchRange = worksheet.get_Range(“A1”, “E1”);        //定义标题范围<br>    object[] P_obj_Items = { “编程词典”, “VC编程词典”, “JAVA编程词典”, “ASP.NET编程词典”, “C#编程词典” };<br>    searchRange.set_Value(missing, P_obj_Items);                                //绘制标题<br>    searchRange.Font.Bold = true;                                        //设置字体加粗<br>    searchRange.Font.Name = “宋体”;                                        //设置字体样式<br>    searchRange.Font.Size = 10;                                            //设置字体大小<br>    searchRange.HorizontalAlignment = Microsoft.Office.Interop.Excel.XlHAlign.xlHAlignCenter;    //设置标题对齐方式<br>    //获得要生成图表的数据<br>    for (int i = 0; i &lt; 13; i++)<br>    {<br>        worksheet.Cells[2 + i, 1] = i;<br>        worksheet.Cells[2 + i, 2] = i + 1;<br>        worksheet.Cells[2 + i, 3] = i + 2;<br>        worksheet.Cells[2 + i, 4] = i + 3;<br>        worksheet.Cells[2 + i, 5] = i + 4;<br>    }<br>    //创建Excel绘图对象<br>Microsoft.Office.Interop.Excel.Chart chart = (Microsoft.Office.Interop.Excel.Chart)workbook.Charts.Add(missing, missing, missing, missing);<br>//定义绘制图表范围<br>    Microsoft.Office.Interop.Excel.Range chartRange = worksheet.get_Range(“A1:A14”, “B1:E14”);<br>    //在指定范围绘制图表<br>    chart.ChartWizard(chartRange, Microsoft.Office.Interop.Excel.XlChartType.xl3DColumn, missing, Microsoft.Office.Interop.Excel.XlRowCol.xlColumns, 1, 1, true, “编程词典销量分析”, “月份”, “销量”, missing);<br>    excel.DisplayAlerts = false;                                            //设置保存Excel时不显示对话框<br>    workbook.Save();                                                //保存工作簿<br>    workbook.Close(false, missing, missing);                                    //关闭工作簿<br>    CloseProcess(“EXCEL”);                                            //关闭所有Excel进程<br>    WBrowser_Excel.Navigate(tstxt_Excel.Text);                                //在窗体中重新显示Excel文件内容<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟049：通过Cells属性为单元格赋值。 Excel对象的Cells属性用来指定Excel工作簿中单元格的内容，例如，下面的代码用来指定Excel工作簿中第一行第一列的单元格中的内容为“Excel”：</p>
<p>excel.Cells[1, 1] = “Excel”;</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>将文本文件数据分解到Excel中的不同数据表</title>
    <url>/zh-CN/2019/08/25/e5-b0-86-e6-96-87-e6-9c-ac-e6-96-87-e4-bb-b6-e6-95-b0-e6-8d-ae-e5-88-86-e8-a7-a3-e5-88-b0excel-e4-b8-ad-e7-9a-84-e4-b8-8d-e5-90-8c-e6-95-b0-e6-8d-ae-e8-a1-a8.html</url>
    <content><![CDATA[<h2 id="将文本文件数据分解到Excel中的不同数据表"><a href="#将文本文件数据分解到Excel中的不同数据表" class="headerlink" title="将文本文件数据分解到Excel中的不同数据表"></a>将文本文件数据分解到Excel中的不同数据表</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用C#代码实现了将文本文件中的内容分解到Excel中不同数据表的功能。运行本实例，如图1所示，单击第一个“选择”按钮，选择要读取的文本文件；单击第二个“选择”按钮，选择Excel文件；然后单击“读取”按钮，将文本文件中的数分解到Excel文件的不同数据表中；单击“查看”按钮，查看分解完数据之后的Excel文件。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-00551033.png" alt=""> 图1 将文本文件数据分解到Excel中的不同数据表 例如，将如图2所示的文本文件内容分解到Excel文件的不同数据表中，则分解之后的Excel文件如图3所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-00551594.png" alt=""> 图2 文本文件数据 图3 分解之后的Excel文件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在将文本文件的内容分解到Excel中的不同数据表中时，首先需要使用StreamReader类的ReadLine方法依次读取文本文件中的内容，然后使用Excel自动化对象模型的Worksheets对象的Add方法添加多个工作表，最后通过Excel自动化对象模型的Excel对象的Cells属性为工作表的单元格设置值。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为TxtToMulSheets。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加两个TextBox控件，分别用来显示选择的文本文件路径和Excel文件路径；添加4个Button控件，分别用来执行选择文本文件、选择Excel文件、将文本文件中数据导入到Excel文件中的不同工作表和查看Excel文件操作。 （3）程序主要代码如下：</p>
<p>private void btn_Read_Click(object sender, EventArgs e)<br>{<br>    int P_int_Count = 0;                                        //记录正在读取的行数<br>    string P_str_Line, P_str_Content = “”;                            //记录读取行的内容及遍历到的内容<br>    List<string> P_str_List = new List<string>();                        //存储读取的所有内容<br>    StreamReader SReader = new StreamReader(txt_Txt.Text, Encoding.Default);        //创建流读取对象<br>    while ((P_str_Line = SReader.ReadLine()) != null)                        //循环读取文本文件中的每一行<br>    {<br>        P_str_List.Add(P_str_Line);                                //将读取到的行内容添加到泛型集合中<br>        P_int_Count++;                                        //使当前读取行数加1<br>}<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.Application();<br>    object missing = System.Reflection.Missing.Value;                    //获取缺少的object类型值<br>    //打开指定的Excel文件<br>    Microsoft.Office.Interop.Excel.Workbook workbook = excel.Application.Workbooks.Open(txt_Excel.Text, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing, missing);<br>    Microsoft.Office.Interop.Excel.Worksheet newWorksheet;                //声明工作表对象<br>    for (int i = 0; i &lt; P_str_List.Count; i++)                            //遍历泛型集合<br>    {<br>        P_str_Content = P_str_List[i];                                //记录遍历到的值<br>//创建新工作表<br>        newWorksheet = (Microsoft.Office.Interop.Excel.Worksheet)workbook.Worksheets.Add(missing, missing, missing, missing);<br>        newWorksheet.Cells[1, 1] = P_str_Content;                        //直接将遍历到的内容添加到工作表中<br>    }<br>    excel.Application.DisplayAlerts = false;                            //不显示提示对话框<br>    workbook.Save();                                        //保存工作表<br>    workbook.Close(false, missing, missing);                            //关闭工作表<br>    MessageBox.Show(“已经将文本文件的内容分解到了Excel的不同数据表中！”, “提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟033：合理使用StreamReader对象的ReadToEnd方法！ 使用StreamReader对象的ReadToEnd方法可以方便的一次性全部读取出文本文件的所有文本信息，适当的使用此方法会使文件操作更加便捷。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>将文本文件转换成网页文件</title>
    <url>/zh-CN/2019/08/02/e5-b0-86-e6-96-87-e6-9c-ac-e6-96-87-e4-bb-b6-e8-bd-ac-e6-8d-a2-e6-88-90-e7-bd-91-e9-a1-b5-e6-96-87-e4-bb-b6.html</url>
    <content><![CDATA[<h2 id="将文本文件转换成网页文件"><a href="#将文本文件转换成网页文件" class="headerlink" title="将文本文件转换成网页文件"></a>将文本文件转换成网页文件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在“东方网页王”和Microsoft Word等软件中，用户只要在其中添加一些文字和图片等元素，就会自动生成一个网页。实际上，生成网页的技术并不难，因为网页文件本质上就是带有HTML控制符号的纯文本文件，用户只要在文本文件的前后加上HTML语言标识符，并保存为.htm文件即可。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-02-12023119.png" alt=""> 图1 将文本文件转换成网页文件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现将RichTextBox控件中的文本转换为网页格式的文本，主要用到了RichTextBox控件的AppendText方法和SaveFile方法，下面对本实例中用到的关键技术进行详细讲解。 （1）RichTextBox控件的AppendText方法 该方法实现向文本框的当前文本追加文本。其语法格式如下： public void AppendText(string text) 参数说明 text：要向文本框的当前内容追加的文本。 （2）RichTextBox控件的SaveFile方法 该方法实现将RichTextBox 中的内容保存到特定类型的文件中。其语法格式如下： public void SaveFile(string path, RichTextBoxStreamType fileType) 参数说明 path：要保存的文件的名称和位置。 fileType：RichTextBoxStreamType类型的枚举值之一，其枚举值及说明如表1所示。 表1 RichTextBoxStreamType枚举值及说明</p>
<p>枚举值</p>
<p>说明</p>
<p>RichText</p>
<p>RTF 格式流</p>
<p>PlainText</p>
<p>用空格代替对象链接与嵌入 (OLE) 对象的纯文本流</p>
<p>RichNoOleObjs</p>
<p>用空格代替 OLE 对象的丰富文本格式（RTF 格式）流</p>
<p>TextTextOleObjs</p>
<p>具有 OLE 对象的文本表示形式的纯文本流</p>
<p>UnicodePlainText</p>
<p>包含用空格代替对象链接与嵌入 (OLE) 对象的文本流</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为ConvertTxtToWeb。 （2）在默认窗体Form1中添加一个RichTextBox控件，用来显示网页的文本和HTML语言标识符；添加一个Button控件，用来生成网页。 （3）程序主要代码如下：</p>
<p>private void button1_Click(object sender, EventArgs e)<br>{<br>    try<br>{<br>    //设置网页显示的文本<br>        string strContent = “明日科技有限公司是一家以计算机软件技术为核心的高科技企业，多年来始终致力于行业管理软件开发、数字化出版物制作、计算机网络系统综合应用以及行业电子商务网站开发领域，涉及生产、管理、控制、仓储、物流、营销、服务等行业。公司拥有软件开发和项目实施方面的资深专家和学习型技术团队，多年来积累了丰富的技术文档和学习资料，公司的开发团队不仅是开拓进取的技术实践者，更致力于成为技术的普及和传播者。”;<br>        string strCompany = “吉林省明日科技有限公司”;<br>        string strWeb = “<a href="http://www.mingrisoft.com&quot;" target="_blank" rel="noopener">www.mingrisoft.com&quot;</a>;<br>        string strFileName = “公司网页.htm”;<br>        richTextBox1.Clear();<br>        richTextBox1.AppendText(“<HTML>“);                                //添加网页的HTML语言标识符<br>        richTextBox1.AppendText(“<HEAD>“);                                //设置网页的HEAD元素<br>        richTextBox1.AppendText(“<TITLE>“);                                //设置网页的TITLE元素<br>        richTextBox1.AppendText(strCompany);                                //添加网页的标题内容<br>        richTextBox1.AppendText(“</TITLE>“);<br>        richTextBox1.AppendText(“</HEAD>“);<br>        richTextBox1.AppendText(“<BODY BGCOLOR='TAN'>“);<br>        richTextBox1.AppendText(“<CENTER>“);                                //设置文本居中的标记<br>        richTextBox1.AppendText(“<H2>“ + strCompany + “</H2>“);<br>        String strHyper = “<H4><A HREF='" + strWeb + "'>欢迎访问明日科技公司网站：”;<br>        richTextBox1.AppendText(strHyper + strWeb + “</A></H4>“);<br>        richTextBox1.AppendText(“</CENTER>“);<br>        richTextBox1.AppendText(strContent);<br>        richTextBox1.AppendText(“</BODY>“);<br>        richTextBox1.AppendText(“</HTML>“);<br>        richTextBox1.SaveFile(strFileName, RichTextBoxStreamType.PlainText);            //保存文本框的内容为纯文本流<br>        System.Diagnostics.Process.Start(strFileName);                            //通过文档名启动进程资源<br>    }<br>    catch (Exception ex)<br>    {<br>        MessageBox.Show(ex.Message, “信息提示”, MessageBoxButtons.OK, MessageBoxIcon.Information);<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟009：通过指定文档来启动进程资源。 调用Process.Start方法可实现通过指定文档来启动进程资源，并将资源与新的Process 组件关联。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>将汇总数据利用柱形图分析</title>
    <url>/zh-CN/2019/07/07/e5-b0-86-e6-b1-87-e6-80-bb-e6-95-b0-e6-8d-ae-e5-88-a9-e7-94-a8-e6-9f-b1-e5-bd-a2-e5-9b-be-e5-88-86-e6-9e-90.html</url>
    <content><![CDATA[<h2 id="将汇总数据利用柱形图分析"><a href="#将汇总数据利用柱形图分析" class="headerlink" title="将汇总数据利用柱形图分析"></a>将汇总数据利用柱形图分析</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在开发数据库系统管理软件时，通常使用图表分析数据库中的汇总数据。本实例通过柱形图对水果市场进行抽样调查，评选出最受欢迎的3种水果。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-07-09414680.png" alt=""> 图1 将汇总数据利用柱形图分析</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例主要通过调用Graphics类的FillRectangle方法来绘制表示汇总数据的柱形图。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为GatherDataAnalyse。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个Panel控件，用于显示绘图结果。 （3）程序主要代码如下：</p>
<p>private void ShowPic()<br>{<br>Conn();                                                        //打开数据库连接<br>//创建SqlCommand对象<br>    using (cmd = new SqlCommand(“SELECT TOP 3 * FROM tb_Rectangle order by t_Num desc”, con));<br>    {<br>        SqlDataReader dr = cmd.ExecuteReader();                                //创建SqlDataReader对象<br>        Bitmap bitM = new Bitmap(this.panel1.Width, this.panel1.Height);                //创建一个新画布<br>        Graphics g = Graphics.FromImage(bitM);                                //创建Graphics对象<br>        g.Clear(Color.White);                                            //设置画布背景<br>        for (int i = 0; i &lt; 5; i++)<br>        {<br>            g.DrawLine(new Pen(new SolidBrush(Color.Red), 2.0f), 50, this.panel1.Height - 20 - i * 20, this.panel1.Width - 40, this.panel1.Height - 20 - i * 20);                                                        //绘制水平直线<br>            g.DrawString(Convert.ToString(i * 100), new Font(“Times New Roman”, 10, FontStyle.Regular), new SolidBrush(Color.Black), 20, this.panel1.Height - 27 - i * 20);                                            //绘制文字<br>        }<br>        for (int j = 0; j &lt; 4; j++)<br>        {<br>            g.DrawLine(new Pen(new SolidBrush(Color.Red), 1.0f), 50+ 40 * j, this.panel1.Height - 20, 50 + 40 * j, 20);                                                                                    //绘制垂直直线<br>            if (dr.Read())<br>            {<br>                int x,y,w,h;                                            //声明变量存储坐标和宽高<br>                g.DrawString(dr[0].ToString(), new Font(“宋体”, 8, FontStyle.Regular), new SolidBrush(Color.Black), 76 + 40 * j, this.panel1.Height-16);                                                //绘制说明文字<br>                x = 78+ 40 * j;                                            //X轴<br>//Y轴<br>                y = this.panel1.Height - 20 - Convert.ToInt32((Convert.ToDouble(Convert.ToDouble(dr[1].ToString()) * 20 / 100)));<br>                w = 24;                                                //宽<br>                h = Convert.ToInt32(Convert.ToDouble(dr[1].ToString()) * 20 / 100);         //高<br>                g.FillRectangle(new SolidBrush(Color.FromArgb(56,129,78)), x,y,w,h);        //绘制柱形图<br>            }<br>        }<br>        this.panel1.BackgroundImage = bitM;                                    //将画布设为panel1控件的背景图<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟003：有效回收对象资源！ 程序设计过程中，可以手动回收文件资源，但是使用using关键字则更为简洁友好。当using关键字下面的代码执行完毕后，将会自动将using小括号中创建的对象隐式转换为IDisposable接口类型，并调用接口方法Dispose释放对象资源。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>将DataGridView中数据导出到Excel</title>
    <url>/zh-CN/2019/10/03/e5-b0-86datagridview-e4-b8-ad-e6-95-b0-e6-8d-ae-e5-af-bc-e5-87-ba-e5-88-b0excel.html</url>
    <content><![CDATA[<h2 id="将DataGridView中数据导出到Excel"><a href="#将DataGridView中数据导出到Excel" class="headerlink" title="将DataGridView中数据导出到Excel"></a>将DataGridView中数据导出到Excel</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>Microsoft Excel具有强大的数据统计功能，并且使用它设计报表简单方便、美观实用，所以在软件开发中常需要把应用程序中的数据到出到Excel文件中。本实例实现把DataGridView中数据导出到Excel。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/10/100319_0849_DataGridVie1.png" alt=""></p>
<p>图1 将DataGridView中数据导出到Excel</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现时主要用到了Microsoft Excel对象模型的Workbooks接口的Add方法，该方法实现创建一个新的工作簿，其语法格式如下：</p>
<p>Workbook Add(object Template)</p>
<p>参数说明 R Template：工作簿的模板。  返回值：新建的工作簿实例。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为GridToExcel。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个DataGridView控件，用来显示数据；添加一个Button控件，用来实现把DataGridView控件中的数据导出到Excel文档。 （3）程序主要代码如下： 在窗体的Load事件中，首先绑定DataGridView控件到数据集合，具体代码如下：</p>
<p>private void Frm_Main_Load(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>dgv_Message.DataSource = new List&lt;Fruit&gt;() {                    //绑定数据集合</code></pre><p>new Fruit(){Name=”苹果”,Price=30},</p>
<p>new Fruit(){Name=”橘子”,Price=40},</p>
<p>new Fruit(){Name=”鸭梨”,Price=33},</p>
<p>new Fruit(){Name=”水蜜桃”,Price=31}};</p>
<pre><code>dgv_Message.Columns\[0\].Width = 200;                        //设置列宽度


dgv_Message.Columns\[1\].Width = 170;                        //设置列宽度</code></pre><p>}</p>
<p>单击窗体的”导出到Excel文档”按钮，实现把DataGridView控件中的数据导出到Excel文档，具体代码如下：</p>
<p>private Excel.Application G_ea;                                //定义Word应用程序字段</p>
<p>private object G_missing = System.Reflection.Missing.Value;                //定义G_missing字段并添加引用</p>
<p>private void btn_OutPut_Click(object sender, EventArgs e)</p>
<p>{</p>
<pre><code>List&lt;Fruit&gt; P_Fruit = new List&lt;Fruit&gt;();                        //创建数据集合


foreach (DataGridViewRow dgvr in dgv_Message.Rows)


{


    P_Fruit.Add(new Fruit()                                //向数据集合添加数据


    {


        Name = dgvr.Cells\[0\].Value.ToString(),


        Price = Convert.ToSingle(dgvr.Cells\[1\].Value.ToString())


    });


}


SaveFileDialog P_SaveFileDialog = new SaveFileDialog();            //创建保存文件对话框对象


P_SaveFileDialog.Filter = &quot;*.xls|*.xls&quot;;


if (DialogResult.OK == P_SaveFileDialog.ShowDialog())                //确认是否保存文件


{


    ThreadPool.QueueUserWorkItem(                        //开始线程池


    (pp) =&gt;                                        //使用lambda表达式</code></pre><p>{</p>
<pre><code>G_ea = new Microsoft.Office.Interop.Excel.Application();        //创建应用程序对象


Excel.Workbook P\_wk = G\_ea.Workbooks.Add(G_missing);        //创建Excel文档


Excel.Worksheet P\_ws = (Excel.Worksheet)P\_wk.Worksheets.Add(G\_missing, G\_missing, G\_missing, G\_missing);//创建工作区域


for (int i = 0; i &lt; P_Fruit.Count; i++)


{


    P\_ws.Cells\[i + 1, 1\] = P\_Fruit\[i\].Name;                //向Excel文档中写入内容


    P\_ws.Cells\[i + 1, 2\] = P\_Fruit\[i\].Price.ToString();        //向Excel文档中写入内容


}


P_wk.SaveAs(                                //保存Word文件</code></pre><p>P_SaveFileDialog.FileName, G_missing, G_missing, G_missing,</p>
<p>G_missing, G_missing, Excel.XlSaveAsAccessMode.xlShared, G_missing,</p>
<p>G_missing, G_missing, G_missing, G_missing);</p>
<pre><code>((Excel.\_Application)G\_ea.Application).Quit();                //退出应用程序


this.Invoke(                                    //调用窗体线程


(MethodInvoker)(() =&gt;                        //使用lambda表达式</code></pre><p>{</p>
<pre><code>MessageBox.Show(&quot;成功创建Excel文档！&quot;, &quot;提示！&quot;);    //弹出消息对话框</code></pre><p>}));</p>
<p>});</p>
<pre><code>}</code></pre><p>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟018：使用ThreadPool创建线程。 在应用程序开发中，如果做一些比较耗时的工作或启动其它应用程序，那么可以通过线程池创建一个新的线程来处理这些任务，这样可以防止因主线程繁忙而出现”假死”现象。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>将DataGridView中数据导出到Word</title>
    <url>/zh-CN/2020/03/02/e5-b0-86datagridview-e4-b8-ad-e6-95-b0-e6-8d-ae-e5-af-bc-e5-87-ba-e5-88-b0word.html</url>
    <content><![CDATA[<h2 id="将DataGridView中数据导出到Word"><a href="#将DataGridView中数据导出到Word" class="headerlink" title="将DataGridView中数据导出到Word"></a>将DataGridView中数据导出到Word</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>Microsoft Word具有很强的文档处理功能，将C#程序与Word文档相结合，就能够设计出更加强大的应用程序。本实例通过使用Microsoft Word自动化对象模型中的Cell对象，将DataGridView控件中的数据导出到Word文档表格中。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2020/03/030220_0400_DataGridVie2.png" alt=""></p>
<p>图1 将DataGridView中数据导出到Word  </p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在使实现时主要用到了Word对象模型中Tables接口的Add方法和Table接口的Cell方法，下面对本实例中用到的关键技术进行详细讲解。 （1）Tables接口的Add方法 该方法实现在文档中添加指定行数和列数的表格，其语法格式如下：</p>
<p>Table Add(Range Range, int NumRows, int NumColumns, ref object DefaultTableBehavior, ref object AutoFitBehavior)</p>
<p>Add方法的参数及说明如表1所示。 表1 Add方法的参数及说明</p>
<p>枚举值</p>
<p>说明</p>
<p>Range</p>
<p>表示文档范围</p>
<p>NumRows</p>
<p>Word表格的行数</p>
<p>NumColumns</p>
<p>Word表格的列数</p>
<p>DefaultTableBehavior</p>
<p>文档中表格行为</p>
<p>AutoFitBehavior</p>
<p>文档中表格格式</p>
<p>返回值</p>
<p>Word表格对象</p>
<p>（2）Table接口的Cell方法  该方法实现获取Word表格中指定行和列的表格，其语法格式如下：</p>
<p>Cell Cell(int Row, int Column)</p>
<p>参数说明： R Row：指定的行。  Column：指定的列。 } 返回值：Word表格中指定行和列的表格。  </p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为GridToWord。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个DataGridView控件，用来显示数据；添加一个Button控件，用来实现把DataGridView控件中的数据导出到Word文档。 （3）程序主要代码如下： 在窗体的Load事件中，首先绑定DataGridView控件到数据集合，具体代码如下：</p>
<p>private void Frm_Main_Load(object sender, EventArgs e)<br>{<br>    dgv_Message.DataSource = new List<Fruit>() {                        //绑定数据集合<br>new Fruit(){Name=”苹果”,Price=30},<br>new Fruit(){Name=”橘子”,Price=40},<br>new Fruit(){Name=”鸭梨”,Price=33},<br>new Fruit(){Name=”水蜜桃”,Price=31}};<br>    dgv_Message.Columns[0].Width = 200;                            //设置列宽度<br>    dgv_Message.Columns[1].Width = 170;                            //设置列宽度<br>}</p>
<p>  单击窗体的”导出到Word文档”按钮，实现把DataGridView控件中的数据导出到Word文档，具体代码如下：</p>
<p>private Word.Application G_wa;                                    //定义Word应用程序字段<br>private object G_missing = System.Reflection.Missing.Value;                    //定义G_missing字段并添加引用<br>private void btn_OutPut_Click(object sender, EventArgs e)<br>{<br>    List<Fruit> P_Fruit = new List<Fruit>();                            //创建数据集合<br>    foreach (DataGridViewRow dgvr in dgv_Message.Rows)<br>    {<br>        P_Fruit.Add(new Fruit()                                    //向数据集合添加数据<br>        {<br>            Name = dgvr.Cells[0].Value.ToString(),<br>            Price = Convert.ToSingle(dgvr.Cells[1].Value.ToString())<br>        });<br>    }<br>    SaveFileDialog P_SaveFileDialog = new SaveFileDialog();                //创建保存文件对话框对象<br>    P_SaveFileDialog.Filter = “<em>.doc|</em>.doc”;<br>    if (DialogResult.OK == P_SaveFileDialog.ShowDialog())                    //确认是否保存文件<br>    {<br>        ThreadPool.QueueUserWorkItem(                            //开始线程池<br>        (pp) =&gt;                                            //使用lambda表达式<br>{<br>    G_wa = new Microsoft.Office.Interop.Word.Application();            //创建应用程序对象<br>    object P_obj = “Normal.dot”;//定义文档模板<br>    Word.Document P_wd = G_wa.Documents.Add(                //向Word应用程序中添加文档<br>    ref P_obj, ref G_missing, ref G_missing, ref G_missing);<br>    Word.Range P_Range = P_wd.Range(                        //得到文档范围<br>ref G_missing, ref G_missing);<br>    object o1 = Word.WdDefaultTableBehavior.wdWord8TableBehavior;    //设置文档中表格格式<br>    object o2 = Word.WdAutoFitBehavior.wdAutoFitWindow;            //设置文档中表格格式<br>    Word.Table P_WordTable = P_Range.Tables.Add(P_Range,            //在文档中添加表格<br>    P_Fruit.Count, 2, ref o1, ref o2);<br>    P_WordTable.Cell(1, 1).Range.Text = “水果”;                    //向表格中添加信息<br>    P_WordTable.Cell(1, 2).Range.Text = “价格”;                    //向表格中添加信息<br>    for (int i = 2; i &lt; P_Fruit.Count + 1; i++)<br>    {<br>        P_WordTable.Cell(i, 1).Range.Text = P_Fruit[i - 2].Name;        //向表格中添加信息<br>        P_WordTable.Cell(i, 2).Range.Text = P_Fruit[i - 2].Price.ToString();    //向表格中添加信息<br>    }<br>    object P_Path = P_SaveFileDialog.FileName;<br>    P_wd.SaveAs(                                    //保存Word文件<br>ref P_Path,<br>ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>ref G_missing, ref G_missing, ref G_missing);<br>    ((Word._Application)G_wa.Application).Quit(                    //退出应用程序<br>ref G_missing, ref G_missing, ref G_missing);<br>    this.Invoke(                                        //调用窗体线程<br>(MethodInvoker)(() =&gt;                            //使用lambda表达式<br>{<br>MessageBox.Show(“成功创建Word文档！”, “提示！”);        //弹出消息对话框<br>}));<br>});<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟017：使用lambda表达式。 在本实例中应用了lambda表达式，带有表达式体的lambda表达式可以转换为表达式树。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>将Excel数据分解到多个文本文件</title>
    <url>/zh-CN/2019/08/14/e5-b0-86excel-e6-95-b0-e6-8d-ae-e5-88-86-e8-a7-a3-e5-88-b0-e5-a4-9a-e4-b8-aa-e6-96-87-e6-9c-ac-e6-96-87-e4-bb-b6.html</url>
    <content><![CDATA[<h2 id="将Excel数据分解到多个文本文件"><a href="#将Excel数据分解到多个文本文件" class="headerlink" title="将Excel数据分解到多个文本文件"></a>将Excel数据分解到多个文本文件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>本实例使用C#代码实现了将Excel文件中的数据分解到多个文本文件中的功能。运行本实例，如图1所示，单击“选择”按钮，选择要分解的Excel文件；然后在下拉列表中分别选择要分解的工作表和要分解的文本文件个数，单击“导出到文本文件”按钮，将Excel文件中指定工作表的内容分解到指定个数的文本文件中，如图2所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-14-10184115.png" alt=""> 图1 将Excel数据分解到多个文本文件 图2 分解之后的文本文件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在将Excel中的数据分解到多个文本文件时，首先需要循环读取出Excel文件中的内容，然后根据要分解的文本文件个数，使用StreamWriter类的Write方法向各个文件中写入不同的内容即可。 说明：关于StreamWriter类的Write方法的详细讲解，请参见实例“读取Excel指定表数据到文本文件”中的关键技术。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为ExcelToMultiTxt。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个TextBox控件，用来显示选择的Excel文件；添加两个ComboBox控件，分别用来显示指定Excel文件中的所有工作表名称和要分解为的文本文件个数；添加两个Button控件，分别用来执行选择Excel文件操作和将Excel文件中指定表的数据分解到多个文本文件的操作。 （3）程序主要代码如下：</p>
<p>//将Excel数据分解到多个文本文件中<br>private void WriteContent()<br>{<br>    int P_int_Counts = CBoxShowCount().Tables[0].Rows.Count;                    //获取记录总数<br>    int P_int_Page = Convert.ToInt32(cbox_Count.Text);                        //记录要分解为几个文件<br>    int P_int_PageRow = Convert.ToInt32(P_int_Counts / P_int_Page);                //记录每个文件的记录数<br>    for (int i = 0; i &lt; P_int_Page; i++)                                    //循环访问每个文件<br>{<br>//创建写入流对象<br>        using (StreamWriter SWriter = new StreamWriter(cbox_SheetName.Text + i + “.txt”, false, Encoding.Default))<br>        {<br>            string P_str_Content = “”;                                    //存储读取的内容<br>            for (int r = i * P_int_PageRow; r &lt; (i + 1) * P_int_PageRow; r++)            //遍历数据集中表的行数<br>            {<br>                if (r &lt; P_int_Counts)                                    //判断遍历到的行数是否小于总行数<br>                {<br>//遍历数据集中表的列数<br>                    for (int c = 0; c &lt; CBoxShowCount().Tables[0].Columns.Count; c++)<br>                    {<br>//记录当前遍历到的内容<br>                        P_str_Content += CBoxShowCount().Tables[0].Rows[r][c].ToString() + “  “;<br>                    }<br>                    P_str_Content += Environment.NewLine;                    //字符串换行<br>                }<br>            }<br>            SWriter.Write(P_str_Content);                                //先文本文件中写入内容<br>            SWriter.Close();                                        //关闭写入流对象<br>        }<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟040：轻松回收StreamWriter对象资源！ 程序设计过程中，可以手动调用StreamWriter对象的Close方法回收文件资源，但是使用using关键字则更为简洁友好。当using关键字下面的代码执行完毕后，将会自动将using小括号中创建的StreamWriter对象隐式转换为IDisposable接口类型，并调用接口方法Dispose释放对象资源。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>将Excel文件嵌入到WinForm窗体中</title>
    <url>/zh-CN/2019/08/25/e5-b0-86excel-e6-96-87-e4-bb-b6-e5-b5-8c-e5-85-a5-e5-88-b0winform-e7-aa-97-e4-bd-93-e4-b8-ad.html</url>
    <content><![CDATA[<h2 id="将Excel文件嵌入到WinForm窗体中"><a href="#将Excel文件嵌入到WinForm窗体中" class="headerlink" title="将Excel文件嵌入到WinForm窗体中"></a>将Excel文件嵌入到WinForm窗体中</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>Excel是微软公司提供的用于办公管理的应用软件，它在人们的日常办公应用中经常用到，本实例使用C#代码将Excel文件嵌入到了Windows窗体中，运行本实例，选择菜单栏中的“打开Excel文件”选项，即可将选择的Excel文件显示在Windows窗体中。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-25-01222150.png" alt=""> 图1 将Excel文件嵌入到WinForm窗体中</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现在Windows窗体中显示Excel文件时，主要用到了WebBrowser控件的Navigate方法，下面对其进行详细讲解。 WebBrowser控件是Windows应用程序中的一种标准控件，它为WebBrowser ActiveX控件提供了托管包装，该托管包装可以使用户在Windows窗体客户端应用程序中显示网页等文件，其Navigate方法用来将指定位置的文档加载到WebBrowser控件中，该方法常用的语法格式如下： public void Navigate(string urlString) 参数说明 urlString：要加载的文档的URL地址。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为ExcelToWinForm。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个MenuStrip控件，用来作为窗体的菜单栏；添加一个OpenFileDialog组件，用来显示“打开文件”对话框；添加一个WebBrowser控件，用来显示打开的Excel文件。 （3）程序主要代码如下：</p>
<p>private void 打开Excel文件ToolStripMenuItem_Click(object sender, EventArgs e)<br>{<br>    OpenFileDialog.Filter=”Excel文件|*.xls”;                        //设置打开文件筛选器<br>    OpenFileDialog.Title = “打开Excel文件”;                        //设置打开对话框标题<br>    if (OpenFileDialog.ShowDialog() == DialogResult.OK)                //判断是否选择了文件<br>    {<br>        WBrowser_Excel.Navigate(OpenFileDialog.FileName);            //在窗体中显示Excel文件内容<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟027：使用WebBrowser控件轻松的在窗体中浏览网页信息！ WebBrowser控件可以在Windows窗体客户端应用程序中显示网页，使用WebBrowser控件显示网页信息非常方便，只需执行Navigate方法，并在方法参数中加入网址信息字符串即可。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>将Sql Server数据查询结果输出到Excel</title>
    <url>/zh-CN/2019/08/14/e5-b0-86sql-server-e6-95-b0-e6-8d-ae-e6-9f-a5-e8-af-a2-e7-bb-93-e6-9e-9c-e8-be-93-e5-87-ba-e5-88-b0excel.html</url>
    <content><![CDATA[<p><strong>将Sql Server数据查询结果输出到Excel</strong></p>
<p>实例说明</p>
<p>本实例使用C#代码实现了将Sql Server数据查询结果输出到Excel的功能。运行本实例，如图1所示，首先选择查询条件，并输入查询关键字，单击”查询”按钮，在Sql Server数据库中执行查询，并将查询结果显示在数据表格控件中；然后单击”导出Excel”按钮，将数据表格控件中的查询结果输出到Excel文件中。</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/081419_1107_SqlServer1.png" alt=""></p>
<p>图1 将Sql Server数据查询结果输出到Excel</p>
<p>例如，在如图2所示的Sql Server数据库中查询性别为”男”的数据，并将查询之后的数据输出到Excel文件中，则输入之后的Excel文件如图3所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/081419_1107_SqlServer2.png" alt=""></p>
<p>图2 Sql Server数据库中的数据</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/081419_1107_SqlServer3.png" alt=""></p>
<p>图3 输入数据之后的Excel文件</p>
<p>关键技术</p>
<p>本实例在将Sql Server数据库的查询结果输出到Excel时，首先需要将Sql Server数据库的查询结果显示在DataGridView控件中，然后遍历DataGridView控件中的数据，并通过设置Excel对象的Cells属性来将遍历到的值填充到Excel的单元格中。</p>
<p>设计过程</p>
<p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为SqlToExcel。</p>
<p>（2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个ComboBox控件，用来选择查询条件；添加一个TextBox控件，用来输入查询关键字；添加一个DataGridView控件，用来显示Sql Server数据库中的数据；添加两个Button控件，分别用来执行数据库查询和将数据库查询结果输出到Excel文件中的操作。</p>
<p>（3）程序主要代码如下：</p>
<p>private void btn_Excel_Click(object sender, EventArgs e)<br>{<br>    if (dgv_Info.Rows.Count == 0)                                //判断是否有数据<br>        return;                                            //返回<br>//创建Excel对象<br>    Microsoft.Office.Interop.Excel.Application excel = new Microsoft.Office.Interop.Excel.Application();<br>    excel.Application.Workbooks.Add(true);                            //在Excel中添加一个工作簿<br>    excel.Visible = true;                                        //设置Excel显示<br>    //生成字段名称<br>    for (int i = 0; i &lt; dgv_Info.ColumnCount; i++)<br>    {<br>        excel.Cells[1, i + 1] = dgv_Info.Columns[i].HeaderText;                //将数据表格控件中的列表头填充到Excel中<br>    }<br>    //填充数据<br>    for (int i = 0; i &lt; dgv_Info.RowCount - 1; i++)                        //遍历数据表格控件的所有行<br>    {<br>        for (int j = 0; j &lt; dgv_Info.ColumnCount; j++)                    //遍历数据表格控件的所有列<br>        {<br>            if (dgv_Info[j, i].ValueType == typeof(string))                    //判断遍历到的数据是否是字符串类型<br>            {<br>                excel.Cells[i + 2, j + 1] = “‘“ + dgv_Info[j, i].Value.ToString();        //填充Excel表格<br>            }<br>            else<br>            {<br>                excel.Cells[i + 2, j + 1] = dgv_Info[j, i].Value.ToString();        //填充Excel表格<br>            }<br>        }<br>    }<br>}</p>
<p>秘笈心法</p>
<p>心法领悟036：如何连接Sql Server数据库？</p>
<p>C#中连接Sql Server数据库时，需要使用SqlConnection类，该类位于System.Data.SqlClient命名空间下。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>将SQL Server数据查询结果输出到Word</title>
    <url>/zh-CN/2019/08/27/e5-b0-86sql-server-e6-95-b0-e6-8d-ae-e6-9f-a5-e8-af-a2-e7-bb-93-e6-9e-9c-e8-be-93-e5-87-ba-e5-88-b0word.html</url>
    <content><![CDATA[<h2 id="将SQL-Server数据查询结果输出到Word"><a href="#将SQL-Server数据查询结果输出到Word" class="headerlink" title="将SQL Server数据查询结果输出到Word"></a>将SQL Server数据查询结果输出到Word</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>SQl Server数据库中存储着大量的数据，我们可以使用C#从数据库中取出数据信息，并处理这些信息。本实例将会介绍一种方法，将SQL Server中查询所得到的数据输出到Word文档。首先得到从SQL Server数据库中查询到的数据集合，然后将数据集合中的信息写入到Word文档中。实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/08/2019-08-27-03200074.png" alt=""> 图1 将SQL Server数据查询结果输出到Word 实例运行中单击“读取SQL数据并写入Word文档”按钮，此时会读取SQL Server中的数据到新创建的Word文档中，SQL Server中的数据如图2所示。被写入数据的Word文档如图3所示。 图2 SQL Server中的数据 图3 被写入数据的Word文档</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍怎样将SQL Server数据查询结果输出到Word，下面对本实例用到的关键技术进行详细讲解。 注意：如果操作SQL Server数据库，那么在代码中要引用SQL命名空间，如using System.Data.SqlClient，下面再次涉及到SQL Server的使用时，将不再提示。 要将SQL Server中的数据插入到Word，首先可以使用SqlDataAdapter对象填充DataTable，然后遍历DataTable中的数据并添加到数据集合，最后将数据集合中的数据写入到Word文档。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为SQLToWord。 （2）使用C#操作Word文档，需要引用相关的COM组件，引用COM组件的步骤请参照实例“创建Word文档”中的设计过程。 （3）更改默认窗体Form1的Name属性为Frm_Main，更改Text属性为“将SQL Server数据查询结果输出到Word”，向窗体中添加4个TextBox控件，分别用于填写SQL服务器信息和显示Word文档保存路径；向窗体中添加3个Button按钮，分别用于选择Word文档保存路径、读取SQL数据并写入Word文档和显示Word文档。 （4）程序主要代码如下：</p>
<p>private void btn_New_Click(object sender, EventArgs e)<br>{<br>    btn_New.Enabled = false;                                    //停用新建按钮<br>    ThreadPool.QueueUserWorkItem(                                //开始线程池<br>        (pp) =&gt;                                            //使用lambda表达式<br>        {<br>            G_wa = new Microsoft.Office.Interop.Word.Application();            //创建应用程序对象<br>            object P_obj = “Normal.dot”;                            //定义文档模板<br>            Word.Document P_wd = G_wa.Documents.Add(                //创建Word文档<br>                ref P_obj, ref G_missing, ref G_missing, ref G_missing);<br>            Word.Range P_Range = P_wd.Range(                        //得到文档范围<br>                ref G_missing, ref G_missing);<br>            string P_Server = string.Empty;                            //定义字符串变量用于存放服务器信息<br>            string P_DataBase = string.Empty;                        //定义字符串变量用于存放数据库名称<br>            string P_UserName = string.Empty;                        //定义字符串变量用于存放用户名<br>            string P_PassWord = string.Empty;                        //定义字符串变量用于存放密码<br>            this.Invoke(<br>                (MethodInvoker)(() =&gt;<br>                {<br>                    P_Server = txt_Server.Text;                        //得到数据库服务器信息<br>                    P_DataBase = txt_DataBase.Text;                    //得到数据库名称<br>                    P_UserName = txt_UserName.Text;                    //得到数据库用户名<br>                    P_PassWord = txt_PassWord.Text;                    //得到数据库密码<br>                }));<br>            DataTier P_DataTier = new DataTier(                        //创建数据层对象<br>                P_Server, P_DataBase, P_UserName, P_PassWord);<br>            List<string> P_List_Str = P_DataTier.GetMessage();                //得到数据集合<br>            foreach (string P_str in P_List_Str)                        //遍历数据集合<br>            {<br>                P_Range.Text += P_str;                            //向文档中添加数据<br>            }<br>            G_str_path = string.Format(                            //计算文件保存路径<br>                @”{0}\{1}”, G_FolderBrowserDialog.SelectedPath,<br>                DateTime.Now.ToString(“yyyy年M月d日h时s分m秒fff毫秒”) + “.doc”);<br>            P_wd.SaveAs(                                    //保存Word文件<br>                ref G_str_path,<br>                ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                ref G_missing, ref G_missing, ref G_missing);<br>            ((Word._Application)G_wa.Application).Quit(                    //退出应用程序<br>                ref G_missing, ref G_missing, ref G_missing);<br>            this.Invoke(                                        //调用窗体线程<br>                (MethodInvoker)(() =&gt;                            //使用lambda表达式<br>                {<br>                    MessageBox.Show(“成功创建Word文档！”, “提示！”);    //弹出消息对话框<br>                    btn_display.Enabled = true;                        //启用显示按钮<br>                }));<br>        });<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟015：使用Foreach循环方便的将字符串集合中的信息写入Word文档！ 现在，我们可以使用Range对象的Text属性轻松的向Word文档中写入文字信息，那么，怎样将字符串集合中的字符信息写入Word文档呢？可以使用Foreach遍历集合中的每一个字符串，并使用Range对象的Text属性将字符串信息添加到Word文档中。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>将Word中数据分解到多个文本文件中</title>
    <url>/zh-CN/2019/08/27/e5-b0-86word-e4-b8-ad-e6-95-b0-e6-8d-ae-e5-88-86-e8-a7-a3-e5-88-b0-e5-a4-9a-e4-b8-aa-e6-96-87-e6-9c-ac-e6-96-87-e4-bb-b6-e4-b8-ad.html</url>
    <content><![CDATA[<h2 id="将Word中数据分解到多个文本文件中"><a href="#将Word中数据分解到多个文本文件中" class="headerlink" title="将Word中数据分解到多个文本文件中"></a>将Word中数据分解到多个文本文件中</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>将Word中的数据分解到多个文本文件的实现方法非常简单，首先要读取Word文档中所有文本内容，然后根据用户选择分解Word文档的方式将Word文档分解为多个字符串，最后，使用StreamWriter将多个字符串分别写入到多个文本文件中，实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082719_0304_Word1.png" alt=""></p>
<p>图1 将Word中数据分解到多个文本文件中 实例运行中单击”开始分割”按钮，此时会读取Word文档中的文本内容并按照用户指定的方式分割到多个文本文件中，Word文档中的文本内容如图2所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082719_0304_Word2.png" alt=""></p>
<p>图2 Word文档中的文本内容 实例运行中单击”开始分割”按钮，此时会读取Word文档中的文本内容并按照用户指定的方式分割到多个文本文件中，分割后的多个文本文件如图3、4、5和6所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082719_0304_Word3.png" alt=""></p>
<p>图3 第一个文本文件中的文本内容</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082719_0304_Word4.png" alt=""></p>
<p>图4 第二个文本文件中的文本内容</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082719_0304_Word5.png" alt=""></p>
<p>图5 第3个文本文件中的文本内容</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082719_0304_Word6.png" alt=""></p>
<p>图6 第4个文本文件中的文本内容</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍怎样将Word中数据分解到多个文本文件中，下面对本实例用到的关键技术进行详细讲解。 如果将Word中的文本信息分解到多个文本文件中，首先应当根据用户指定的方式提取Word文档中的文本信息，并将文本信息保存到多个文本文件中。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为WordToMulti-Txt。 （2）使用C#操作Word文档，需要引用相关的COM组件，引用COM组件的步骤请参照实例”创建Word文档”中的设计过程。 （3）更改默认窗体Form1的Name属性为Frm_Main，更改Text属性为”将Word中数据分解到多个文本文件中”，向窗体中添加两个TextBox控件，分别用于显示打开Word文档的路径和保存文本文件路径；向窗体中添加3个Button按钮，分别用于选择将要打开的Word文档、选择文本文件保存的路径和分解Word文档的内容到多个文本文件。 （4）程序主要代码如下：</p>
<p>private void btn_split_Click(object sender, EventArgs e)<br>{<br>    btn_split.Enabled = false;                                                //停用分解按钮<br>    ThreadPool.QueueUserWorkItem(                                            //开始线程池<br>        (pp) =&gt;                                                        //使用lambda表达式<br>        {<br>            G_wa = new Microsoft.Office.Interop.Word.Application();                        //创建应用程序对象<br>            object P_OpenFileDialog = G_OpenFileDialog.FileName;                         //创建object对象<br>            Word.Document P_Document = G_wa.Documents.Open(                        //打开Word文档<br>                ref P_OpenFileDialog, ref G_missing, ref G_missing, ref G_missing<br>                , ref G_missing, ref G_missing, ref G_missing, ref G_missing<br>                , ref G_missing, ref G_missing, ref G_missing, ref G_missing<br>                , ref G_missing, ref G_missing, ref G_missing, ref G_missing);<br>            bool P_bl = false;                                                //定义布尔变量<br>            this.Invoke(                                                    //调用窗体线程<br>                 (MethodInvoker)(() =&gt;                                        //使用lambda表达式<br>                 {<br>                     P_bl = cbox_Select.SelectedIndex == 0;<br>                 }));<br>            if (P_bl)                                                    //判断怎样分割文档<br>            {<br>                foreach (Word.Paragraph Paragraph in G_wa.ActiveDocument.Paragraphs)<br>                {<br>                    AddFile(Paragraph.Range.Text);                                //将文本写入文本文件<br>                }<br>            }<br>            else<br>            {<br>                Word.Range P_Range = G_wa.ActiveDocument.Content;                    //得到文档区域<br>                int P_int_count = P_Range.Text.Length;                                //得到文档字符总长度<br>                int P_int_i = P_int_count / 100;                                    //计算循环次数<br>                if (P_int_i &gt; 0)                                                //如果文字大于100个<br>                {<br>                    for (int i = 0; i &lt; P_int_i; i++)                                    //开始循环创建文档<br>                    {<br>                        object P_o1 = i == 0 ? 0 : i * 100 + 1;                            //复制范围的开始部份<br>                        object P_o2 = i * 100 + 101;                                //复制范围的结尾部份<br>                        Word.Range P_Range_temp =                                 //得到文档的范围<br>                            G_wa.ActiveDocument.Range(ref P_o1, ref P_o2);<br>                        AddFile(P_Range_temp.Text);                                //将文本写入文本文件<br>                    }<br>                    object P_o11 = P_int_i * 100 + 1;                                //复制范围的开始部份<br>                    Word.Range P_Range_temp1 =                                 //得到文档的范围<br>                        G_wa.ActiveDocument.Range(ref P_o11, ref G_missing);<br>                    AddFile(P_Range_temp1.Text);                                //将文本写入文本文件<br>                }<br>                else<br>                {<br>                    Word.Range P_Range2 = G_wa.ActiveDocument.Content;                    //得到文档区域<br>                    AddFile(P_Range2.Text);                                    //将文本写入文本文件<br>                }<br>            }<br>            ((Word._Application)G_wa.Application).Quit(                                //退出应用程序<br>                ref G_missing, ref G_missing, ref G_missing);<br>            this.Invoke(                                                    //调用窗体线程<br>                (MethodInvoker)(() =&gt;                                        //使用lambda表达式<br>                {<br>                    Clipboard.Clear();                                        //清空剪切板<br>                    MessageBox.Show(“成功分解Word文档！”, “提示！”);                    //弹出消息对话框<br>                    btn_split.Enabled = true;                                    //启用分解按钮<br>                }));<br>        });<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟018：使用DateTime.Now属性获取系统时间！ 使用DateTime.Now属性可以方便的获取系统时间，而且可以使用格式化方式方便的得到系统时间的字符串表示，代码如下：</p>
<p>string P_str = DateTime.Now.ToString(“yyyy年M月d日h时m分s秒fff毫秒”);</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>将Word文档嵌入到WinForm窗体中</title>
    <url>/zh-CN/2019/09/10/e5-b0-86word-e6-96-87-e6-a1-a3-e5-b5-8c-e5-85-a5-e5-88-b0winform-e7-aa-97-e4-bd-93-e4-b8-ad.html</url>
    <content><![CDATA[<h2 id="将Word文档嵌入到WinForm窗体中"><a href="#将Word文档嵌入到WinForm窗体中" class="headerlink" title="将Word文档嵌入到WinForm窗体中"></a>将Word文档嵌入到WinForm窗体中</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>Office是我们日常工作中经常用到的办公软件，然而，随着信息技术的飞速发展，已经有越来越多的人使用Word写作文档、使用Excel制做报表、使用OutLook方便的收发电子邮件。一切的操作都是这么轻松，实例中将会介绍怎样使用C#在Form窗体中显示Word文档，运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/09/091019_1531_WordWinFo1.png" alt=""></p>
<p>图1 将Word文档嵌入到WinForm窗体中</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍怎样使用WebBrowser控件显示Word文档，下面对本实例中所用到的关键技术进行详细讲解。 WebBrowser控件是Windows窗体应用程序的标准控件，使用WebBrowser控件可以在窗体中显示网页信息，通过WebBrowser控件的Navigate方法可以将指定位置的文档加载到WebBrowser控件中，该方法常用的语法格式如下：</p>
<p>public void Navigate(string urlString)</p>
<p>参数说明 R urlString：要加载的文档的URL地址。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为WordInForm。 （2）更改默认窗体Form1的Name属性为Frm_Main，更改Text属性为”将Word文档嵌入到WinForm窗体中”，并向窗体中添加一个MenuStrip菜单控件，向菜单中添加两个菜单项”打开”和”退出”分别用于打开Word文档和退出应用程序；向窗体中添加WebBrowser控件，此控件用于显示Word文档。 （3）程序主要代码如下：</p>
<p>private void 打开ToolStripMenuItem_Click(object sender, EventArgs e)<br>{<br>    OpenFileDialog P_GetFile = new OpenFileDialog();                            //创建打开文件对话框对象<br>    DialogResult P_dr = P_GetFile.ShowDialog();                                //显示打开文件对话框<br>    if (P_dr == DialogResult.OK)                                            //是否单击确定<br>    {<br>        WebBrowser.Navigate(P_GetFile.FileName);                                //打开Word文档并显示<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟001：使用WebBrowser控件轻松的在窗体中浏览网页信息！ WebBrowser控件可以在Windows窗体客户端应用程序中显示网页，使用WebBrowser控件显示网页信息非常方便，只需执行Navigate方法，并在方法参数中加入网址信息字符串即可！</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>将Word文档转换为HTML网页</title>
    <url>/zh-CN/2019/08/25/e5-b0-86word-e6-96-87-e6-a1-a3-e8-bd-ac-e6-8d-a2-e4-b8-bahtml-e7-bd-91-e9-a1-b5.html</url>
    <content><![CDATA[<h2 id="将Word文档转换为HTML网页"><a href="#将Word文档转换为HTML网页" class="headerlink" title="将Word文档转换为HTML网页"></a>将Word文档转换为HTML网页</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>我们可以使用C#方便的读取Word文档中的文本内容，并将文本内容保存到文本文件，但是保存的文本内容是没有格式的，那么，有什么好的方法可以解决上面的问题吗？将Word文档的内容转换为HTML网页是一个不错的选择，本实例将介绍一种方法可以轻松的将Word文档转换为HTML网页。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082519_0133_WordHTML1.png" alt=""></p>
<p>图1 将Word文档转换为HTML网页</p>
<p>实例运行中单击”打开Word文档”或”创建Word文档”按钮，此时会打开Word文档，用户可以手动向文档中添加文本信息如图2所示。单击”转换为HTML”按钮，可以将Word文档转换为HTML网页如图3所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082519_0133_WordHTML2.png" alt=""></p>
<p>图2 Word文档中的文本内容</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082519_0133_WordHTML3.png" alt=""></p>
<p>图3 HTML网页中的文本内容</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍怎样使用Document对象的SaveAs方法将Word文档转换为HTML网页，下面对本实例用到的关键技术进行详细讲解。 在Word文档的操作过程中，我们经常可以使用SaveAs方法保存Word文档，实例中将会使用SaveAs方法将Word文档另存为HTML网页文件格式。SaveAs方法的语法格式如下：</p>
<p>public virtual void SaveAs(ref object FileName, ref object FileFormat, ref object LockComments, ref object Password, ref object AddToRecentFiles, ref object WritePassword, ref object ReadOnlyRecommended, ref object EmbedTrueTypeFonts, ref object SaveNativePictureFormat, ref object SaveFormsData, ref object SaveAsAOCELetter, ref object Encoding, ref object InsertLineBreaks, ref object AllowSubstitutions, ref object LineEnding, ref object AddBiDiMarks);</p>
<p>SaveAs方法中的参数说明如表1所示。 表1 SaveAs方法中的参数说明</p>
<p>参数</p>
<p>描述</p>
<p>FileName</p>
<p>代表文件名称及路径，如果已有FileName指定的文档，则覆盖此文档，而且在覆盖前不会提示</p>
<p>FileFormat</p>
<p>文档的保存格式。可以是WdSaveFormat枚举类型值</p>
<p>LockComments</p>
<p>如果为true，则锁定文档以进行注释。默认值为false</p>
<p>Password</p>
<p>打开文档的口令</p>
<p>AddToRecentFiles</p>
<p>如果为true，则将该文档添加到”文件”菜单上最近使用的文件列表中。默认值为true</p>
<p>WritePassword</p>
<p>如果为true，则将TrueType字体随文档一起保存</p>
<p>ReadOnlyRecommended</p>
<p>如果为true，则让Microsoft Office Word在打开文档时建议只读状态。默认值为false</p>
<p>EmbedTrueTypeFonts</p>
<p>如果为true，则将TrueType字体随文档一起保存</p>
<p>SaveNativePictureFormat</p>
<p>如果为true，则从其它系统平台（例如Macintosh）导入的图形仅保存其Windows版本</p>
<p>SaveFormsData</p>
<p>如果为true，则将用户在窗体中输入的数据另存为数据记录</p>
<p>SaveAsAOCELetter</p>
<p>如果文档包含一个附件，当此属性值为true时，将文档保存为一篇AOCE信函(同时保存邮件)</p>
<p>Encoding</p>
<p>要用于另存为编码文本文件的文档的代码页或字符集。默认值是系统代码页</p>
<p>InsertLineBreaks</p>
<p>如果文档另存为文本文件，则true表示在每行文本末尾插入分行符</p>
<p>AllowSubstitutions</p>
<p>如果文档另存为文本文件，则true允许Word将某些符号替换为外观与之类似的文本</p>
<p>LineEnding</p>
<p>参数为WdLineEndingType枚举类型值，Word在另存为文本文件的文档中标记分行符和换段符</p>
<p>AddBiDiMarks</p>
<p>如果为true，则向输出文件添加控制字符，以便保留原始文档中文本的双向布局</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为WordToHTML。 （2）使用C#操作Word文档，需要引用相关的COM组件，引用COM组件的步骤请参照实例”创建Word文档”中的设计过程。 （3）更改默认窗体Form1的Name属性为Frm_Main，更改Text属性为”将Word文档转换为HTML网页”，向窗体中添加3个Button按钮，分别用于打开Word文档、创建Word文档和将Word文档转换为HTML网页。 （4）程序主要代码如下：</p>
<p>private void btn_SaveAs_Click(object sender, EventArgs e)<br>{<br>    btn_SaveAs.Enabled = false;                                                //停用转换按钮<br>    try<br>    {<br>        G_wa.ActiveDocument.Save();                                            //保存文档<br>        ((Word._Application)G_wa.Application).Quit(                                //退出应用程序<br>          ref G_missing, ref G_missing, ref G_missing);<br>    }<br>    catch (Exception ex)<br>    {<br>        Console.WriteLine(ex.Message);<br>    }<br>    SaveFileDialog P_SaveFileDialog = new SaveFileDialog();                             //创建保存文件对话框<br>    P_SaveFileDialog.Filter = “<em>.html|</em>.html”;                                        //筛选文件扩展名<br>    DialogResult P_DialogResult = P_SaveFileDialog.ShowDialog();                         //打开保存文件对话框<br>    if (P_DialogResult == DialogResult.OK)                                        //判断是否保存文件<br>    {<br>        object P_str_path = P_SaveFileDialog.FileName;                                //创建object对象<br>        ThreadPool.QueueUserWorkItem(                                        //开始线程澉<br>            (pp) =&gt;                                                    //使用Lambda表达式<br>            {<br>                G_wa =                                                 //创建应用程序对象<br>                  new Microsoft.Office.Interop.Word.Application();<br>                G_wa.Visible = false;<br>                Word.Document P_wd = G_wa.Documents.Open(                        //打开Word文档<br>                   ref G_FilePath, ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                   ref G_missing, ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                   ref G_missing, ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                   ref G_missing);<br>                object P_Format = Word.WdSaveFormat.wdFormatHTML;                    //创建保存文档参数<br>                P_wd.SaveAs(                                                //保存Word文件<br>                    ref P_str_path,<br>                    ref P_Format, ref G_missing, ref G_missing, ref G_missing,<br>                    ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                    ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                    ref G_missing, ref G_missing, ref G_missing);<br>                ((Word._Application)G_wa.Application).Quit(                            //退出应用程序<br>                    ref G_missing, ref G_missing, ref G_missing);<br>                this.Invoke(                                                //调用窗体线程<br>                    (MethodInvoker)(() =&gt;                                        //使用lambda表达式<br>                    {<br>                        btn_Open.Enabled = true;                                    //启用打开按钮<br>                        btn_New.Enabled = true;                                    //启用新建按钮<br>                        MessageBox.Show(“文件已经创建”, “提示！”);                    //提示已经创建Word<br>                    }));<br>            });<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟023：将Word转换为rtf文档！ 实例中详细的介绍了怎样使用Dcoument对象的SaveAs方法，将Word文档转换为HTML网页。SaveAs方法还可以将Word文档轻松的转换为rtf文档。只要将实例中的代码：</p>
<p>object P_Format = Word.WdSaveFormat.wdFormatHTML;</p>
<p>替换为：</p>
<pre><code>object P_Format = Word.WdSaveFormat.wdFormatRTF;</code></pre><p>并相应的更改保存文件的扩展名即可！</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title>将XML中的数据读取到Word文档中</title>
    <url>/zh-CN/2019/08/27/e5-b0-86xml-e4-b8-ad-e7-9a-84-e6-95-b0-e6-8d-ae-e8-af-bb-e5-8f-96-e5-88-b0word-e6-96-87-e6-a1-a3-e4-b8-ad.html</url>
    <content><![CDATA[<h3 id="将XML中的数据读取到Word文档中实例说明"><a href="#将XML中的数据读取到Word文档中实例说明" class="headerlink" title="将XML中的数据读取到Word文档中实例说明"></a><strong>将XML中的数据读取到Word文档中</strong>实例说明</h3><p>在程序设计过程中，我们经常用到XML（Extensible Markup Language 可扩展标记语言），XML是一种严谨的描述数据的语言，在C#中可以使用XmlReader和XmlDocument对象方便的读取XML文件的内容。在实例中将会使用XmlDocument对象读取指定XML文件内容，并将XML的文本内容写入到Word文档中。实例运行效果如图1所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082719_0313_XMLWord1.png" alt=""></p>
<p>图1 将XML中的数据读取到Word文档中 实例运行中单击”读取XML内容并写入Word文档”按钮，此时会读取XML文档的内容到新创建的Word文档中，XML文档中的内容如图2所示。被写入数据的Word文档如图3所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082719_0313_XMLWord2.png" alt=""></p>
<p>图2 XML文档内容</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082719_0313_XMLWord3.png" alt=""></p>
<p>图3 被写入XML信息的Word文档</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例重点在于向读者介绍怎样使用XmlDocument对象读取XML文档，并将文档的文本内容写入Word文档，下面对本实例用到的关键技术进行详细讲解。 引用了相应的命名空间后，我们可以使用XmlDocument对象轻松的读取Xml文档中的文本内容，XmlDocument对象的使用方法如图4所示。</p>
<p><img data-src="https://cdn.fesugar.com/2019/08/082719_0313_XMLWord4.png" alt=""></p>
<p>图4 使用XmlDocument对象读取XML文档信息 从图4中可以看到，首先创建XmlDocument对象，通过XmlDocument对象的Load方法载入XML文档，然后使用DocumentElement属性返回XmlElement根结点对象，通过根结点对象的ChildNodes属性得到根节点中所有子节点的集合，最后遍历子节点集合中的每一个子节点，从每一个子节点所包含的节点集合中得到相应的字符串信息。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为XMLToWord。 （2）使用C#操作Word文档，需要引用相关的COM组件，引用COM组件的步骤请参照实例”创建Word文档”中的设计过程。 （3）更改默认窗体Form1的Name属性为Frm_Main，更改Text属性为”将XML中的数据读取到Word文档中”，向窗体中添加一个TextBox控件，用于显示Word文档保存路径；向窗体中添加3个Button按钮，分别用于选择Word文档保存路径、读取XML内容并写入Word文档和显示Word文档。 （4）程序主要代码如下：</p>
<p>private void btn_New_Click(object sender, EventArgs e)<br>{<br>    btn_New.Enabled = false;                                            //停用新建按钮<br>    ThreadPool.QueueUserWorkItem(                                        //使用线程池<br>        (P_temp) =&gt;                                                //使用lambda表达式<br>        {<br>            G_wa = new Word.Application();                                    //创建Word应用程序对象<br>            Word.Document P_wd = G_wa.Documents.Add(                        //建立新文档<br>                ref G_missing, ref G_missing, ref G_missing, ref G_missing);<br>            Word.Range P_Range = P_wd.Paragraphs[1].Range;                        //得到文档段落范围<br>            XmlDocument P_XML = new XmlDocument();                        //创建XML对象<br>            P_XML.Load(“test.xml”);                                        //打开XML文档<br>            XmlElement P_XmlElement = P_XML.DocumentElement;                    //得到XML根节点<br>            XmlNodeList P_XmlNodeList = P_XmlElement.ChildNodes;                    //得到子节点集合<br>            string P_Str_Message = string.Empty;                                //创建空字符串对象<br>            foreach (XmlNode xn in P_XmlNodeList)                            //遍历所有子节点<br>            {<br>                foreach (XmlNode xn2 in xn.ChildNodes)                            //遍历子节点中的节点<br>                {<br>                    P_Str_Message += xn2.InnerText + “\r\n”;                        //得到字符串信息<br>                }<br>            }<br>            P_Range.Text = P_Str_Message;                                    //向Word中添加字符串<br>            G_str_path = string.Format(                                    //计算文件保存路径<br>                @”{0}\{1}”, G_FolderBrowserDialog.SelectedPath,<br>                DateTime.Now.ToString(“yyyy年M月d日h时s分m秒fff毫秒”) + “.doc”);<br>            P_wd.SaveAs(                                            //保存Word文件<br>                ref G_str_path,<br>                ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                ref G_missing, ref G_missing, ref G_missing, ref G_missing,<br>                ref G_missing, ref G_missing, ref G_missing);<br>            ((Word._Application)G_wa.Application).Quit(                            //退出应用程序<br>                ref G_missing, ref G_missing, ref G_missing);<br>            this.Invoke(                                                //开始执行窗体线程<br>                (MethodInvoker)(() =&gt;                                    //使用lambda表达式<br>                {<br>                    btn_Display.Enabled = true;                                //启用显示按钮<br>                    MessageBox.Show(“成功创建Word文档！”, “提示！”);                //弹出消息对话框<br>                }));<br>        });<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟016：使用XmlReader可以轻松读取XML文档的内容！ 使用XmlDocument可以通过节点和元素的方式轻松的读取XML文档中的信息，同样，也可以使用XmlReader通过游标的方式读取XML文档中的信息。XmlReader简单演示代码如下：</p>
<p>private void button2_Click(object sender, EventArgs e)<br>{<br>    XmlReader P_xr = XmlReader.Create(@”XML文档路径”);                        //创建XmlReader对象<br>    string P_str = string.Empty;                                            //创建空字符串对象<br>    while (P_xr.Read())                                                //读取下一个节点<br>    {<br>        if (P_xr.NodeType == XmlNodeType.Text)                                //判断节点类型<br>            P_str += P_xr.Value;                                        //添加字符串信息<br>    }<br>    MessageBox.Show(P_str,””);                                            //弹出消息对话框<br>}</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序radio默认样式更改</title>
    <url>/zh-CN/2018/01/07/e5-b0-8f-e7-a8-8b-e5-ba-8fradio-e9-bb-98-e8-ae-a4-e6-a0-b7-e5-bc-8f-e6-9b-b4-e6-94-b9.html</url>
    <content><![CDATA[<p>在做小程序的过程中，就是用radio和checkbox做选择功能的时候，比较简单，比自定义要容易很多，但也遇到一个问题，就是默认样式，一直找不到方法修改，做出来的样子很丑，不是自己想要的效果。 今天终于做出来了，找到了修改默认样式的方法，现在就来看看是怎么做的呢？ 1、部分前台wxml代码如下：</p>
<radio-group class="group">
      <view class="attr_value">
           <radio color=''></radio>
           <label class='radio_label'>颜色</label>
      </view>
</radio-group>

<p>2、重点wxss样式如下：</p>
<p>.attr_value {<br>      float: left;<br>      margin-right:20rpx;<br>      position: relative;<br>}<br>.radio_label{<br>      display: block;<br>      padding:0 24rpx;<br>      height: 40rpx;<br>      line-height: 40rpx;<br>}<br>/*radio默认样式重置*/<br>radio {<br>      box-sizing: border-box;<br>      background: none;<br>      position: absolute;<br>      width: 100%;<br>      height: 100%;<br>      top:0;<br>      left:0;<br>}</p>
<p>radio .wx-radio-input {<br>      margin-right: 15rpx;<br>      position: absolute;<br>      width: 100%;<br>      height: 100%;<br>      top:0;<br>      left:0;<br>      background: none;<br>      border-radius: 6rpx;<br>      box-sizing: border-box;<br>}</p>
<p>radio .wx-radio-input.wx-radio-input-checked {<br>      background-color:transparent;<br>      border-color:#FF2150;<br>      overflow: hidden;<br>      box-sizing: border-box;<br>}</p>
<p>radio .wx-radio-input.wx-radio-input-checked::before {<br>      content: ‘\e60d’;<br>      font-family:”iconfont” !important;<br>      font-size:30rpx;<br>      color: #FF2150;<br>      top:auto;<br>      left:auto;<br>      right:-4rpx;<br>      bottom:-4rpx;<br>      transform:translate(0, 0) scale(1);<br>      -webkit-transform:translate(0, 0) scale(1);<br>}<br>/*radio默认样式重置*/</p>
<p>  修改前的默认radio效果如下： <img data-src="https://cdn.fesugar.com/2018/01/2018-01-07-12035623.png" alt=""> 修改后的radio效果如下： <img data-src="https://cdn.fesugar.com/2018/01/2018-01-07-12035892.png" alt=""> radio .wx-radio-input.wx-radio-input-checked::before 中的 content: ‘\e60d’ 我用的是阿里图标代替了默认的图标。 修改后的radio样式是不是漂亮多了呢？这个写css样式不难，相信做前端的大家都会写，重点是找不到默认css的标签，只要找到了，就很好做了。百度了几次，也都是让自定义，模仿radio，但那个太麻烦了，我就将修改默认样式的这个方法，贴出来分享给大家。</p>
]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>开发一个语音计算器</title>
    <url>/zh-CN/2019/07/15/e5-bc-80-e5-8f-91-e4-b8-80-e4-b8-aa-e8-af-ad-e9-9f-b3-e8-ae-a1-e7-ae-97-e5-99-a8.html</url>
    <content><![CDATA[<h2 id="开发一个语音计算器"><a href="#开发一个语音计算器" class="headerlink" title="开发一个语音计算器"></a>开发一个语音计算器</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在使用计算器对数字进行计算时，有时会输入错误的数字进行计算，但操作者并不知道，这样，会对工作带来不必要的麻烦。本实例将制作一个带语音的计算器，运行本程序，效果效果如图1所示，当用户在语音计算器的主窗体上单击右键时，可以在快捷菜单中选择“设置声音”菜单项，弹出“语音设置”对话框，如图2所示，该对话框中可以对各个按键的声音进行设置。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-15-03390825.png" alt=""> 图1 语音计算器 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-15-03390928.png" alt=""> 图2 “语音设置”对话框</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例主要使用API函数mciSendString来实现语音文件的播放与关闭。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为SoundCalculator。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个TextBox控件，用于显示输入的数字及运算结果；添加23个Button控件，用来设置计算器中的按键。 （3）在项目中添加一个新的Windows窗体，命名为Frm_Set.cs，该窗体用来对各个按键的声音进行设置。 （4）程序主要代码如下：</p>
<p>public void sound(string FileName)<br>{<br>    if (FileName == null)                                        //如果文件为空<br>        return;                                            //退出操作<br>    if (FileName.IndexOf(“ “) == -1)                                //如果路径中没有空格<br>    {<br>        if (tem_FileName.Length!=0)                                //如果有播放的文件<br>            mciSendString(“close “ + tem_FileName, null, 0, 0);                //关闭当前文件的播放<br>        n=mciSendString(“open “ + FileName , null, 0 , 0);                    //打开要播放的文件<br>        n=mciSendString(“play “ + FileName, null, 0, 0);                    //播放当前文件<br>        tem_FileName = FileName;                                //记录播放文件的路径<br>    }<br>}<br>private void pict_Back_Click(object sender, EventArgs e)<br>{<br>    tem_Value = ((PictureBox)sender).AccessibleName;                    //获取当前按钮的标识<br>    switch (tem_Value)<br>    {<br>        case “0”: num(tem_Value); sound(VoxPath[0]); break;                //实现按钮的语音功能<br>        case “1”: num(tem_Value); sound(VoxPath[1]); break;<br>        case “2”: num(tem_Value); sound(VoxPath[2]); break;<br>        case “3”: num(tem_Value); sound(VoxPath[3]); break;<br>        case “4”: num(tem_Value); sound(VoxPath[4]); break;<br>        case “5”: num(tem_Value); sound(VoxPath[5]); break;<br>        case “6”: num(tem_Value); sound(VoxPath[6]); break;<br>        case “7”: num(tem_Value); sound(VoxPath[7]); break;<br>        case “8”: num(tem_Value); sound(VoxPath[8]); break;<br>        case “9”: num(tem_Value); sound(VoxPath[9]); break;<br>        case “+”: js(tem_Value); sound(VoxPath[10]); break;<br>        case “-“: js(tem_Value); sound(VoxPath[11]); break;<br>        case “*”: js(tem_Value); sound(VoxPath[12]); break;<br>        case “/“: js(tem_Value); sound(VoxPath[13]); break;<br>        case “=”: js(tem_Value); sound(VoxPath[14]); break;<br>        case “C”: Aclose(); sound(VoxPath[15]); break;<br>        case “CE”: ce(); sound(VoxPath[16]); break;<br>        case “Back”: backspace(); sound(VoxPath[17]); break;<br>        case “%”: bai(); sound(VoxPath[18]); break;<br>        case “X”: ji(); sound(VoxPath[19]); break;<br>        case “.”: dian(); sound(VoxPath[20]); break;<br>        case “+-“:<br>            {<br>                zf();<br>                if (Convert.ToInt32(textBox1.Text) &gt; 0)                    //如果当前为正数<br>                    sound(VoxPath[21]);                            //实现正数发音<br>                else<br>                    sound(VoxPath[22]);                            //实现负数发音<br>                break;<br>            }<br>        case “Sqrt”: kfang(); sound(VoxPath[23]); break;<br>    }<br>    textBox1.Select(textBox1.Text.Length, 0);<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟020：switch语句的使用注意事项！ 使用switch语句时需要注意以下3点： （1）每个case后面的【常量表达式】的值必须是与【表达式】的类型相同的一个常量，不能是变量； （2）同一个switch语句中的两个或多个case标签中指定同一个常数值，会导致编译出错； （3）一个switch语句中最多只能有一个default标签，并且每一个标签后边都需要一个break语句跳过switch语句的其他标签。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>开启或者禁用本地连接</title>
    <url>/zh-CN/2016/11/07/e5-bc-80-e5-90-af-e6-88-96-e8-80-85-e7-a6-81-e7-94-a8-e6-9c-ac-e5-9c-b0-e8-bf-9e-e6-8e-a5.html</url>
    <content><![CDATA[<p>在某些时候我们可能需要在特定的程序中实现开启或者禁用计算机的本地连接，在不手动操作的情况下，可以使用内部 netsh 命令来完成。   先通过网络管理面板来看下都有那些连接 <img data-src="https://cdn.fesugar.com/2016/11/2016-11-07-13053471.png" alt="8720161107204736"> 也可以通 netsh interface ip show config 命令来查看所有连接 <img data-src="https://cdn.fesugar.com/2016/11/2016-11-07-13065998.png" alt="8720161107205240"> 使用下列命令可以启用或停用相关连接</p>
<p>//禁用以太网连接<br>netsh interface set interface name=”以太网” admin=disable</p>
<p>//启用以太网连接<br>netsh interface set interface name=”以太网” admin=enable</p>
<p>  netsh 还有更多的功能，具体可以查看 <a href="https://technet.microsoft.com/zh-CN/library/bb490943.aspx" target="_blank" rel="noopener">Microsoft TechNet</a> 资料</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>异步加载并播放声音文件</title>
    <url>/zh-CN/2019/07/18/e5-bc-82-e6-ad-a5-e5-8a-a0-e8-bd-bd-e5-b9-b6-e6-92-ad-e6-94-be-e5-a3-b0-e9-9f-b3-e6-96-87-e4-bb-b6.html</url>
    <content><![CDATA[<h2 id="异步加载并播放声音文件"><a href="#异步加载并播放声音文件" class="headerlink" title="异步加载并播放声音文件"></a>异步加载并播放声音文件</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>一般情况下，在加载某些文件时，如果都进行同步加载，那么将浪费很多不必要的时间，因为有些文件并不是用户想要的，因此应该实现异步加载，只加载需要的文件。本实例实现了异步加载并播放声音的功能，实例运行结果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-18-15094990.png" alt=""> 图1 异步加载并播放声音文件</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例实现时主要用到SoundPlayer类，该类用来控制.wav文件中的声音播放。在播放.wav文件前，首先定位该文件的位置，此时用到该类的SoundLocation属性，该属性的功能是获取或设置要加载的.wav文件的文件路径或URL。然后用到该类的LoadAsync方法，该方法的作用是使用新线程从流或Web资源中加载.wav文件。下面对本实例中用到的关键技术进行详细的讲解。 （1）SoundLocation属性 该属性值的类型是System.String，它的作用是从中加载.wav文件的文件路径或URL，如果不存在文件路径，则为String.Empty。默认为String.Empty。其语法格式如下： public string SoundLocation { get; set; } （2）LoadAsync方法 该方法用来从流中或者Web资源中异步加载文件，其语法格式如下： public void LoadAsync() <img data-src="https://cdn.fesugar.com/2019/07/2019-07-18-15095149.jpeg" alt="提示"> 说明：程序中使用SoundPlayer类时，首先需要在命名空间区域添加System.Media命名空间。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为AsynchronismLoadPlayVoice。 （2）更改默认窗体Form1的Name属性为Frm_Main，在该窗体中添加一个TextBox控件，用来显示所要播放的文件路径；添加两个Button控件，分别用来打开.wav文件和播放音乐文件。 （3）程序主要代码如下：</p>
<p>private void play_Click(object sender,EventArgs e)<br>{<br>    try<br>    {<br>        SoundPlayer player = new SoundPlayer();                //声明一个控制WAV文件的声音播放文件对象<br>        player.SoundLocation = path.Text;                    //指定声音文件的路径<br>        player.LoadAsync();                            //设置播放的方法<br>        player.Play();                                //播放声音文件<br>    }<br>    catch (Exception ex)<br>    {<br>        MessageBox.Show(ex.Message);<br>    }<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟008：使用Exception类捕捉异常。 所有.NET里的异常都可被称为Exception。虽然说异常多种多样，但基本上它们都是Exception。这个说法可以打一个简单比喻，就像是无论黑猫、白猫、花猫，它们都是“猫”一样。</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>抓取鼠标形状</title>
    <url>/zh-CN/2019/07/15/e6-8a-93-e5-8f-96-e9-bc-a0-e6-a0-87-e5-bd-a2-e7-8a-b6.html</url>
    <content><![CDATA[<h2 id="抓取鼠标形状"><a href="#抓取鼠标形状" class="headerlink" title="抓取鼠标形状"></a>抓取鼠标形状</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>在Windows系统中，用户利用Print Screen SysRq键抓取窗口时，不能够抓取鼠标形状。但在一些抓图软件中，却能够抓取鼠标形状，该功能是如何实现的呢？本实例中实现了抓取鼠标形状的功能，实例运行效果如图1所示。 <img data-src="https://cdn.fesugar.com/2019/07/2019-07-15-03273151.png" alt=""> 图1 抓取鼠标形状</p>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>本实例在实现抓取鼠标形状功能时，使用了Cursor类的Draw方法，该方法用来在指定边界内和指定的表面上绘制光标，其语法格式如下： public void Draw ( Graphics g, Rectangle targetRect) 参数说明 g：要在其上绘制Cursor的Graphics表面。 targetRect：代表Cursor限定范围的Rectangle。</p>
<h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>（1）打开Visual Studio 2008开发环境，新建一个Windows窗体应用程序，命名为SnatchAtMouse。 （2）更改默认窗体Form1的Name属性为Frm_Main。 （3）程序主要代码如下：</p>
<p>private void Frm_Main_MouseUp(object sender, MouseEventArgs e)<br>{<br>    Graphics myGraphics = this.CreateGraphics();                //创建窗体的Graphics对象<br>    Cursor.Draw(myGraphics, new Rectangle(e.X, e.Y, 10, 10));        //调用Cursor类的Draw方法抓取鼠标形状<br>}</p>
<h3 id="秘笈心法"><a href="#秘笈心法" class="headerlink" title="秘笈心法"></a>秘笈心法</h3><p>心法领悟003：用窗体的CreateGraphics方法创建Graphics对象。 在程序中绘图时，可以调用窗体的CreateGraphics方法来获取对Graphics对象的引用，该对象表示窗体的绘图画面。例如，本实例中创建Graphics对象的代码如下： Graphics graphics = this.CreateGraphics( ); //创建窗体的Graphics对象</p>
]]></content>
      <categories>
        <category>书籍文档</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Visual Studio</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 数组转为 Table</title>
    <url>/zh-CN/2016/07/01/chsarp%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%20Table.html</url>
    <content><![CDATA[<p>C# 数组转为table的实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.ComponentModel;</span><br><span class="line">using System.Data;</span><br><span class="line">using System.Drawing;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Windows.Forms;</span><br><span class="line"></span><br><span class="line">namespace WindowsFormsApplication1</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;Holmes-Jin&#x2F;archive&#x2F;2012&#x2F;04&#x2F;25&#x2F;2470671.html</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    public partial class Form1 : Form</span><br><span class="line">    &#123;</span><br><span class="line">        public Form1()</span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        private void button1\_Click\_1(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            dataGridView1.DataSource &#x3D; ArrayToDataTable.Convert(&quot;haha&quot;, new string\[\] &#123; &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot; &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void button2\_Click\_1(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            string\[,\] array3D &#x3D; &#123;   </span><br><span class="line">                                        &#123; &quot;1&quot;, &quot;数组转DataTable 1&quot;, &quot;0&quot;&#125;,   </span><br><span class="line">                                        &#123; &quot;2&quot;, &quot;数组转DataTable 2&quot;, &quot;1&quot;&#125;,   </span><br><span class="line">                                        &#123; &quot;3&quot;, &quot;数组转DataTable 3&quot;, &quot;1&quot;&#125;,   </span><br><span class="line">                                        &#123; &quot;4&quot;, &quot;数组转DataTable 4&quot;, &quot;2&quot;&#125;,   </span><br><span class="line">                                        &#123; &quot;5&quot;, &quot;数组转DataTable 5&quot;, &quot;2&quot;&#125;,   </span><br><span class="line">                                        &#123; &quot;6&quot;, &quot;数组转DataTable 6&quot;, &quot;5&quot;&#125;,   </span><br><span class="line">                                        &#125;;</span><br><span class="line">            dataGridView1.DataSource &#x3D; ArrayToDataTable.Convert(new string\[\] &#123; &quot;haha1&quot;, &quot;haha2&quot;, &quot;haha3&quot; &#125;, array3D);</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class ArrayToDataTable</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 把一个一维数组转换为DataTable  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;ColumnName&quot;&gt;列名&lt;&#x2F;param&gt;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;Array&quot;&gt;一维数组&lt;&#x2F;param&gt;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;returns&gt;返回DataTable&lt;&#x2F;returns&gt;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;remarks&gt;柳永法 http:&#x2F;&#x2F;www.yongfa365.com&#x2F; &lt;&#x2F;remarks&gt;  </span><br><span class="line">        public static DataTable Convert(string ColumnName, string\[\] Array)</span><br><span class="line">        &#123;</span><br><span class="line">            DataTable dt &#x3D; new DataTable();</span><br><span class="line">            dt.Columns.Add(ColumnName, typeof(string));</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 0; i &lt; Array.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                DataRow dr &#x3D; dt.NewRow();</span><br><span class="line">                dr\[ColumnName\] &#x3D; Array\[i\].ToString();</span><br><span class="line">                dt.Rows.Add(dr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return dt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 反一个M行N列的二维数组转换为DataTable  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;ColumnNames&quot;&gt;一维数组，代表列名，不能有重复值&lt;&#x2F;param&gt;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;Arrays&quot;&gt;M行N列的二维数组&lt;&#x2F;param&gt;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;returns&gt;返回DataTable&lt;&#x2F;returns&gt;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;remarks&gt;柳永法 http:&#x2F;&#x2F;www.yongfa365.com&#x2F; &lt;&#x2F;remarks&gt;  </span><br><span class="line">        public static DataTable Convert(string\[\] ColumnNames, string\[,\] Arrays)</span><br><span class="line">        &#123;</span><br><span class="line">            DataTable dt &#x3D; new DataTable();</span><br><span class="line"></span><br><span class="line">            foreach (string ColumnName in ColumnNames)</span><br><span class="line">            &#123;</span><br><span class="line">                dt.Columns.Add(ColumnName, typeof(string));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i1 &#x3D; 0; i1 &lt; Arrays.GetLength(0); i1++)</span><br><span class="line">            &#123;</span><br><span class="line">                DataRow dr &#x3D; dt.NewRow();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; ColumnNames.Length; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dr\[i\] &#x3D; Arrays\[i1, i\].ToString();</span><br><span class="line">                &#125;</span><br><span class="line">                dt.Rows.Add(dr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return dt;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 反一个M行N列的二维数组转换为DataTable  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;Arrays&quot;&gt;M行N列的二维数组&lt;&#x2F;param&gt;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;returns&gt;返回DataTable&lt;&#x2F;returns&gt;  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;remarks&gt;柳永法 http:&#x2F;&#x2F;www.yongfa365.com&#x2F; &lt;&#x2F;remarks&gt;  </span><br><span class="line">        public static DataTable Convert(string\[,\] Arrays)</span><br><span class="line">        &#123;</span><br><span class="line">            DataTable dt &#x3D; new DataTable();</span><br><span class="line"></span><br><span class="line">            int a &#x3D; Arrays.GetLength(0);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; Arrays.GetLength(1); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                dt.Columns.Add(&quot;col&quot; + i.ToString(), typeof(string));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i1 &#x3D; 0; i1 &lt; Arrays.GetLength(0); i1++)</span><br><span class="line">            &#123;</span><br><span class="line">                DataRow dr &#x3D; dt.NewRow();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; Arrays.GetLength(1); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dr\[i\] &#x3D; Arrays\[i1, i\].ToString();</span><br><span class="line">                &#125;</span><br><span class="line">                dt.Rows.Add(dr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return dt;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
</search>
